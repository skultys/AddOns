local GlobalAddonName, ExRT = ...

local GetTime, IsEncounterInProgress, RAID_CLASS_COLORS, GetInstanceInfo, GetSpellCharges = GetTime, IsEncounterInProgress, RAID_CLASS_COLORS, GetInstanceInfo, GetSpellCharges
local string_gsub, wipe, tonumber, pairs, ipairs, string_trim, format, floor, ceil, abs, type, sort = string.gsub, table.wipe, tonumber, pairs, ipairs, string.trim, format, floor, ceil, abs, type, sort
local UnitIsDeadOrGhost, UnitIsConnected, UnitName, UnitCreatureFamily, UnitIsDead, UnitIsGhost, UnitGUID, UnitInRange = UnitIsDeadOrGhost, UnitIsConnected, UnitName, UnitCreatureFamily, UnitIsDead, UnitIsGhost, UnitGUID, UnitInRange

local RaidInCombat, ClassColorNum, GetDifficultyForCooldownReset, DelUnitNameServer, NumberInRange = ExRT.F.RaidInCombat, ExRT.F.classColorNum, ExRT.F.GetDifficultyForCooldownReset, ExRT.F.delUnitNameServer, ExRT.F.NumberInRange
local GetEncounterTime, UnitCombatlogname, GetUnitInfoByUnitFlag, ScheduleTimer, CancelTimer, GetRaidDiffMaxGroup, round, table_wipe2, dtime = ExRT.F.GetEncounterTime, ExRT.F.UnitCombatlogname, ExRT.F.GetUnitInfoByUnitFlag, ExRT.F.ScheduleTimer, ExRT.F.CancelTimer, ExRT.F.GetRaidDiffMaxGroup, ExRT.F.Round, ExRT.F.table_wipe, ExRT.F.dtime

local VExRT, VExRT_CDE = nil

local module = ExRT.mod:New("ExCD2",ExRT.L.cd2)
local ELib,L = ExRT.lib,ExRT.L

-- SetTexture doesnt work for numbers vaules, use SetColorTexture instead. Check builds when it will be fixed or rewrite addon
---- Quick alpha build fix
local CreateFrame = CreateFrame
if ExRT.is7 then
	local _CreateFrame = CreateFrame
	local function SetTexture(self,arg1,arg2,...)
		if arg2 and type(arg2)=='number' and arg2 <= 1 then	--GetSpellTexture now return spellid (number) with more than 1 arg
			return self:SetColorTexture(arg1,arg2,...)
		else
			return self:_SetTexture(arg1,arg2,...)
		end
	end
	local function CreateTexture(self,...)
		local ret1,ret2,ret3,ret4,ret5 = self:_CreateTexture(...)
		ret1._SetTexture = ret1.SetTexture
		ret1.SetTexture = SetTexture
		return ret1,ret2,ret3,ret4,ret5
	end
	function CreateFrame(...)
		local ret1,ret2,ret3,ret4,ret5 = _CreateFrame(...)
		ret1._CreateTexture = ret1.CreateTexture
		ret1.CreateTexture = CreateTexture 
		return ret1,ret2,ret3,ret4,ret5
	end
end

local is6 = not ExRT.is7

module._C = {}
module.db.spellDB = {
{31821,	"PALADIN",	nil,			{31821,	180,	6},	nil,			nil,			},	--Аура благочестия
{62618,	"PRIEST",	nil,			{62618,	180,	10},	nil,			nil,			},	--Слово силы: Барьер
{97462,	"WARRIOR",	nil,			{97462,	180,	10},	{97462,	180,	10},	nil,			},	--Ободряющий клич
{76577,	"ROGUE",	{76577,	180,	5},	nil,			nil,			nil,			},	--Дымовая шашка
{51052,	"DEATHKNIGHT",	{51052,	120,	3},	nil,			nil,			nil,			},	--Зона антимагии
{98008,	"SHAMAN",	nil,			nil,			nil,			{98008,	180,	6},	},	--Тотем духовной связи
{115310,"MONK",		nil,			nil,			nil,			{115310,180,	0},	},	--Восстановление сил
{64843,	"PRIEST",	nil,			nil,			{64843,	180,	8},	nil,			},	--Божественный гимн
{740,	"DRUID",	nil,			nil,			nil,			nil,{740,180,	8},	},	--Спокойствие
{108280,"SHAMAN",	nil,			nil,			nil,			{108280,180,	10},	},	--Тотем целительного прилива
{108281,"SHAMAN",	{108281,120,	10},	nil,			nil,			nil,			},	--Наставления предков
{15286,	"PRIEST",	nil,			nil,			nil,			{15286,	180,	15},	},	--Объятия вампира
{187614,"NO",		{187614,120,	15},	nil,			nil,			nil,			},	--Legendary DD
{187612,"NO",		{187612,120,	15},	nil,			nil,			nil,			},	--Legendary Heal
{187613,"NO",		{187613,120,	15},	nil,			nil,			nil,			},	--Legendary Tank
{161642,"NO",		{161642,0,	0},	nil,			nil,			nil,			},	--Resurrecting [Raid Combat Res]
{20484,	"DRUID",	{20484,	600,	0},	nil,			nil,			nil,			},	--Возрождение
{20707,	"WARLOCK",	{20707,	600,	0},	nil,			nil,			nil,			},	--Камень души
{61999,	"DEATHKNIGHT",	{61999,	600,	0},	nil,			nil,			nil,			},	--Воскрешение союзника
{20608,	"SHAMAN",	{21169,	1800,	0},	nil,			nil,			nil,			},	--Реинкарнация
{47788,	"PRIEST",	nil,			nil,			{47788,	180,	10},	nil,			},	--Оберегающий дух
{33206,	"PRIEST",	nil,			{33206,	180,	8},	nil,			nil,			},	--Подавление боли
{6940,	"PALADIN",	{6940,	120,	12},	nil,			nil,			{6940,	90,	12},	},	--Длань жертвенности
{102342,"DRUID",	nil,			nil,			nil,			nil,{102342,60,	12},	},	--Железная кора
{114030,"WARRIOR",	{114030,120,	12},	nil,			nil,			nil,			},	--Бдительность
{1022,	"PALADIN",	{1022,	300,	10},	nil,			nil,			nil,			},	--Длань защиты
{106898,"DRUID",	{106898,120,	8},	nil,			nil,			nil,			},	--Тревожный рев
{73325,	"PRIEST",	{73325,	90,	0},	nil,			nil,			nil,			},	--Духовное рвение
{115176,"MONK",		{115176,180,	8},	nil,			nil,			nil,			},	--Дзен-медитация
{108199,"DEATHKNIGHT",	{108199,60,	0},	nil,			nil,			nil,			},	--Хватка Кровожада
{110913,"WARLOCK",	{110913,180,	8},	nil,			nil,			nil,			},	--Темная сделка
{116849,"MONK",		nil,			nil,			nil,			{116849,100,	12},	},	--Исцеляющий кокон
{114039,"PALADIN",	{114039,30,	6},	nil,			nil,			nil,			},	--Длань очищения
{118038,"WARRIOR",	nil,			{118038,120,	8},	{118038,120,	8},	nil,			},	--Бой насмерть
{1044,	"PALADIN",	{1044,	25,	6},	nil,			nil,			nil,			},	--Длань свободы
{633,	"PALADIN",	{633,	600,	0},	nil,			nil,			nil,			},	--Возложение рук
{2825,	"SHAMAN",	{2825,	300,	40},	nil,			nil,			nil,			},	--Жажда крови
{80353,	"MAGE",		{80353,	300,	40},	nil,			nil,			nil,			},	--Искажение времени
--{id,	class,		all specs,		spec1,			spec2={spellid,cd,duration},spec3,spec4		},	--name
}

if ExRT.is7 then
module.db.spellDB = {
{161642,"NO",		{161642,0,	0},	nil,			nil,			nil,			},	--Resurrecting [Raid Combat Res]
{20484,	"DRUID",	{20484,	600,	0},	nil,			nil,			nil,			},	--Возрождение
{20707,	"WARLOCK",	{20707,	600,	0},	nil,			nil,			nil,			},	--Камень души
{61999,	"DEATHKNIGHT",	{61999,	600,	0},	nil,			nil,			nil,			},	--Воскрешение союзника
{20608,	"SHAMAN",	{21169,	1800,	0},	nil,			nil,			nil,			},	--Реинкарнация
{6940,	"PALADIN",	{6940,	240,	12},	nil,			nil,			nil,			},	--Длань жертвенности
{633,	"PALADIN",	{633,	600,	0},	nil,			nil,			nil,			},	--Возложение рук
{97462,	"WARRIOR",	nil,			{97462,	180,	10},	{97462,	180,	10},	nil,			},	--Ободряющий клич
{114030,"WARRIOR",	{114030,120,	12},	nil,			nil,			nil,			},	--Бдительность
{62618,	"PRIEST",	nil,			{62618,	180,	10},	nil,			nil,			},	--Слово силы: Барьер
{64843,	"PRIEST",	nil,			nil,			{64843,	180,	8},	nil,			},	--Божественный гимн
{15286,	"PRIEST",	nil,			nil,			nil,			{15286,	180,	15},	},	--Объятия вампира
{47788,	"PRIEST",	nil,			nil,			{47788,	240,	10},	nil,			},	--Оберегающий дух
{33206,	"PRIEST",	nil,			{33206,	300,	8},	nil,			nil,			},	--Подавление боли
{51052,	"DEATHKNIGHT",	{51052,	120,	5},	nil,			nil,			nil,			},	--Зона антимагии
{108199,"DEATHKNIGHT",	nil,			{108199,180,	0},	nil,			nil,			},	--Хватка Кровожада
{98008,	"SHAMAN",	nil,			nil,			nil,			{98008,	180,	6},	},	--Тотем духовной связи
{108280,"SHAMAN",	nil,			nil,			nil,			{108280,180,	10},	},	--Тотем целительного прилива
{108281,"SHAMAN",	{108281,120,	10},	nil,			nil,			nil,			},	--Наставления предков
{740,	"DRUID",	nil,			nil,			nil,			nil,{740,180,	8},	},	--Спокойствие
{102342,"DRUID",	nil,			nil,			nil,			nil,{102342,90,	12},	},	--Железная кора
{115310,"MONK",		nil,			nil,			nil,			{115310,180,	0},	},	--Восстановление сил
{116849,"MONK",		nil,			nil,			nil,			{116849,180,	12},	},	--Исцеляющий кокон
}
end

module.db.Cmirror = module._C
module.db.dbCountDef = #module.db.spellDB
module.db.findspecspells = {
	[7268] = 62,[30451] = 62,[114923] = 62,[44425] = 62,
	[11366] = 63,[133] = 63,[2948] = 63,
	[30455] = 64,[116] = 64,[112948] = 64,
	[20473] = 65,[85222] = 65,[82326] = 65,[82327] = 65,
	[53600] = 66,[119072] = 66,[159556] = 66,[31935] = 66,
	[53385] = 70,[879] = 70,[85256] = 70,[31884] = 70,
	[12294] = 71,[167105] = 71,[163201] = 71,
	[85288] = 72,[23881] = 72,[100130] = 72,
	[20243] = 73,[23922] = 73,[6572] = 73,[2565] = 73,
	[2912] = 102,[48505] = 102,[93402] = 102,[78674] = 102,
	[5221] = 103,[106785] = 103,[1079] = 103,[1822] = 103,
	[33745] = 104,[6807] = 104,[62606] = 104,
	[8936] = 105,[48438] = 105,[18562] = 105,[33763] = 105,
	[56222] = 250,[48982] = 250,[49222] = 250,
	[49143] = 251,[49020] = 251,[49184] = 251,[130735] = 251,
	[49206] = 252,[85948] = 252,[55090] = 252,
	[34026] = 253,[82692] = 253,[19574] = 253,
	[19434] = 254,[53209] = 254,
	[53301] = 255,[77767] = 255,
	[152118] = 256,[81700] = 256,[47750] = 256,[132157] = 256,[47666] = 256,
	[34861] = 257,[139] = 257,[64844] = 257,
	[147193] = 258,[34914] = 258,[8092] = 258,[2944] = 258,
	[1329] = 259,[111240] = 259,
	[84617] = 260,[51690] = 260,[13750] = 260,
	[51713] = 261,[53] = 261,[14183] = 261,
	[165462] = 262,[8042] = 262,[61882] = 262,
	[60103] = 263,[1535] = 263,[17364] = 263,
	[1064] = 264,[61295] = 264,[77472] = 264,[108280] = 264,
	[103103] = 265,[30108] = 265,[48181] = 265,[980] = 265,
	[105174] = 266,[6353] = 266,[157695] = 266,[603] = 266,
	[29722] = 267,[348] = 267,[157701] = 267,
	[119582] = 268,[115308] = 268,[121253] = 268,[115295] = 268,
	[117418] = 269,[152174] = 269,[116740] = 269,
	[115151] = 270,[115175] = 270,[116670] = 270,
}
module.db.classNames = is6 and {"WARRIOR","PALADIN","HUNTER","ROGUE","PRIEST","DEATHKNIGHT","SHAMAN","MAGE","WARLOCK","MONK","DRUID"} or
	{"WARRIOR","PALADIN","HUNTER","ROGUE","PRIEST","DEATHKNIGHT","SHAMAN","MAGE","WARLOCK","MONK","DRUID","DEMONHUNTER"}

module.db.specByClass = is6 and {
	["HUNTER"] = {0,253,254,255,},
	["WARRIOR"] = {0,71,72,73,},
	["PALADIN"] = {0,65,66,70,},
	["MAGE"] = {0,62,63,64,},
	["PRIEST"] = {0,256,257,258,},
	["MONK"] = {0,268,269,270,},
	["WARLOCK"] = {0,265,266,267,},
	["SHAMAN"] = {0,262,263,264,},
	["ROGUE"] = {0,259,260,261,},
	["DRUID"] = {0,102,103,104,105,},
	["DEATHKNIGHT"] = {0,250,251,252,},
} or {
	["WARRIOR"] = {0,71,72,73,},
	["PALADIN"] = {0,65,66,70,},
	["HUNTER"] = {0,253,254,255,},
	["ROGUE"] = {0,259,260,261,},
	["PRIEST"] = {0,256,257,258,},
	["DEATHKNIGHT"] = {0,250,251,252,},
	["SHAMAN"] = {0,262,263,264,},
	["MAGE"] = {0,62,63,64,},
	["WARLOCK"] = {0,265,266,267,},
	["MONK"] = {0,268,269,270,},
	["DRUID"] = {0,102,103,104,105,},
	["DEMONHUNTER"] = {0,577,581},
}

module.db.specIcons = {
	[62] = "Interface\\Icons\\Spell_Holy_MagicalSentry",
	[63] = "Interface\\Icons\\Spell_Fire_FireBolt02",
	[64] = "Interface\\Icons\\Spell_Frost_FrostBolt02",
	[65] = "Interface\\Icons\\Spell_Holy_HolyBolt",
	[66] = "Interface\\Icons\\Ability_Paladin_ShieldoftheTemplar",
	[70] = "Interface\\Icons\\Spell_Holy_AuraOfLight",
	[71] = "Interface\\Icons\\Ability_Warrior_SavageBlow",
	[72] = "Interface\\Icons\\Ability_Warrior_InnerRage",
	[73] = "Interface\\Icons\\Ability_Warrior_DefensiveStance",
	[102] = "Interface\\Icons\\Spell_Nature_StarFall",
	[103] = "Interface\\Icons\\Ability_Druid_CatForm",
	[104] = "Interface\\Icons\\Ability_Racial_BearForm",
	[105] = "Interface\\Icons\\Spell_Nature_HealingTouch",
	[250] = "Interface\\Icons\\Spell_Deathknight_BloodPresence",
	[251] = "Interface\\Icons\\Spell_Deathknight_FrostPresence",
	[252] = "Interface\\Icons\\Spell_Deathknight_UnholyPresence",
	[253] = "INTERFACE\\ICONS\\ability_hunter_bestialdiscipline",
	[254] = "Interface\\Icons\\Ability_Hunter_FocusedAim",
	[255] = "INTERFACE\\ICONS\\ability_hunter_camouflage",
	[256] = "Interface\\Icons\\Spell_Holy_PowerWordShield",
	[257] = "Interface\\Icons\\Spell_Holy_GuardianSpirit",
	[258] = "Interface\\Icons\\Spell_Shadow_ShadowWordPain",
	[259] = "Interface\\Icons\\Ability_Rogue_Eviscerate",
	[260] = "Interface\\Icons\\Ability_BackStab",
	[261] = "Interface\\Icons\\Ability_Stealth",
	[262] = "Interface\\Icons\\Spell_Nature_Lightning",
	[263] = "Interface\\Icons\\Spell_Shaman_ImprovedStormstrike",
	[264] = "Interface\\Icons\\Spell_Nature_MagicImmunity",
	[265] = "Interface\\Icons\\Spell_Shadow_DeathCoil",
	[266] = "Interface\\Icons\\Spell_Shadow_Metamorphosis",
	[267] = "Interface\\Icons\\Spell_Shadow_RainOfFire",
	[268] = "Interface\\Icons\\spell_monk_brewmaster_spec",
	[269] = "Interface\\Icons\\spell_monk_windwalker_spec",
	[270] = "Interface\\Icons\\spell_monk_mistweaver_spec",
	[577] = GetSpellTexture(185164),	--NYI
	[581] = GetSpellTexture(203747),	--NYI	
}
module.db.specInDBase = {
	[253] = 4,	[254] = 5,	[255] = 6,
	[71] = 4,	[72] = 5,	[73] = 6,
	[65] = 4,	[66] = 5,	[70] = 6,
	[62] = 4,	[63] = 5,	[64] = 6,
	[256] = 4,	[257] = 5,	[258] = 6,
	[265] = 4,	[266] = 5,	[267] = 6,
	[250] = 4,	[251] = 5,	[252] = 6,
	[259] = 4,	[260] = 5,	[261] = 6,
	[102] = 4,	[103] = 5,	[104] = 6,	[105] = 7,
	[268] = 4,	[269] = 5,	[270] = 6,
	[262] = 4,	[263] = 5,	[264] = 6,
	[577] = 4,	[581] = 5,
	[0] = 3,
}

do
	local specList = {
		[62] = "MAGEDPS1",
		[63] = "MAGEDPS2",
		[64] = "MAGEDPS3",
		[65] = "PALADINHEAL",
		[66] = "PALADINTANK",
		[70] = "PALADINDPS",
		[71] = "WARRIORDPS1",
		[72] = "WARRIORDPS2",
		[73] = "WARRIORTANK",
		[102] = "DRUIDDPS1",
		[103] = "DRUIDDPS2",
		[104] = "DRUIDTANK",
		[105] = "DRUIDHEAL",
		[250] = "DEATHKNIGHTTANK",
		[251] = "DEATHKNIGHTDPS1",
		[252] = "DEATHKNIGHTDPS2",
		[253] = "HUNTERDPS1",
		[254] = "HUNTERDPS2",
		[255] = "HUNTERDPS3",
		[256] = "PRIESTHEAL1",
		[257] = "PRIESTHEAL2",
		[258] = "PRIESTDPS",
		[259] = "ROGUEDPS1",
		[260] = "ROGUEDPS2",
		[261] = "ROGUEDPS3",
		[262] = "SHAMANDPS1",
		[263] = "SHAMANDPS2",
		[264] = "SHAMANHEAL",
		[265] = "WARLOCKDPS1",
		[266] = "WARLOCKDPS2",
		[267] = "WARLOCKDPS3",
		[268] = "MONKTANK",
		[269] = "MONKDPS",
		[270] = "MONKHEAL",
		[577] = "DEMONHUNTERDPS",
		[581] = "DEMONHUNTERTANK",
		[0] = "NO",
	}
	module.db.specInLocalizate = setmetatable({},{__index = function (t,k)
		if tonumber(k) then
			return specList[k] 
		else
			for i,val in pairs(specList) do
				if val == k then
					return i
				end
			end
		end
	end})
end

module.db.historyUsage = {}

module.db.testMode = nil
module.db.isEncounter = nil

local cdsNav_wipe,cdsNav_set = nil
do
	local cdsNavData = {}
	local nilData = {}
	module.db.cdsNav = setmetatable({}, {
		__index = function (t,k) 
			return cdsNavData[k] or nilData
		end
	})
	function cdsNav_wipe()
		wipe(cdsNavData)
	end
	function cdsNav_set(playerName,spellID,pos)
		local e = cdsNavData[playerName]
		if not e then
			e = {}
			cdsNavData[playerName] = e
		end
		e[spellID] = pos
	end
end

do
	local sessionData = {}
	local nilData = {}
	module.db.session_gGUIDs = setmetatable({}, {
		__index = function (t,k) 
			return sessionData[k] or nilData
		end,
		__newindex = function (t,k,v)
			local e = sessionData[k]
			if not e then
				e = {}
				sessionData[k] = e
			end
			if v > 0 then
				e[v] = true
			else
				e[-v] = nil
			end
		end
	})	
end

module.db.session_Pets = {}
module.db.session_PetOwner = {}

module.db.spell_isTalent = {		-- SpellID талантов
	[55694]=2,	[103840]=2,	[107570]=4,	[46968]=4,	[118000]=4,	[114028]=5,	[114029]=5,	
	[114030]=5,	[107574]=6,	[12292]=6,	[46924]=6,	[152277]=7,	[176289]=7,	[85499]=1,	
	[105593]=2,	[20066]=2,	[115750]=2,	[114163]=3,	[20925]=3,	[114039]=4,	[105809]=5,	
	[114165]=6,	[114158]=6,	[114157]=6,	[156910]=7,	[157007]=7,	[152262]=7,	[109248]=2,	
	[19386]=2,	[19577]=2,	[109304]=3,	[120679]=4,	[131894]=5,	[121818]=5,	[117050]=6,	
	[109259]=6,	[120360]=6,	[74001]=2,	[36554]=4,	[137619]=6,	[152151]=7,	[152150]=7,	
	[19236]=1,	[112833]=1,	[123040]=3,	[129250]=3,	[108920]=4,	[8122]=4,	[10060]=5,	
	[109964]=5,	[121135]=6,	[127632]=6,	[110744]=6,	[122121]=6,	[120517]=6,	[120644]=6,	
	[123693]=1,	[115989]=1,	[49039]=2,	[51052]=2,	[96268]=3,	[108194]=3,	[48743]=5,	
	[108199]=6,	[108200]=6,	[108201]=6,	[152280]=7,	[152279]=7,	[108270]=1,	[108271]=1,	
	[51485]=2,	[108273]=2,	[108285]=3,	[108287]=3,	[16166]=4,	[16188]=4,	[108281]=5,	
	[117014]=6,	[157153]=7,	[152256]=7,	[152255]=7,	[157913]=1,	[108843]=1,	[108978]=2,	
	[11426]=2,	[113724]=3,	[111264]=3,	[102051]=3,	[110959]=4,	[11958]=4,	[55342]=6,	
	[152087]=7,	[153626]=7,	[153561]=7,	[153595]=7,	[108359]=1,	[5484]=2,	[6789]=2,	
	[30283]=2,	[108416]=3,	[110913]=3,	[111397]=4,	[108482]=4,	[108501]=5,	[108503]=5,	
	[137587]=6,	[108508]=6,	[152108]=7,	[116841]=1,	[115098]=2,	[124081]=2,	[123986]=2,	
	[116844]=4,	[119392]=4,	[119381]=4,	[122278]=5,	[122783]=5,	[116847]=6,	[123904]=6,	
	[157535]=7,	[152175]=7,	[152173]=7,	[102280]=1,	[102401]=1,	[108238]=2,	[102351]=2,	
	[102359]=3,	[132469]=3,	[102560]=4,	[102543]=4,	[102558]=4,	[33891]=4,	[99]=5,	
	[102793]=5,	[5211]=5,	[108291]=6,	[108292]=6,	[108293]=6,	[108294]=6,	[124974]=6,	
	[155835]=7,	
	
	--Other & items
	[67826]=true,
}

-- 1:01 22.09.2014; build 18918
module.db.spell_talentsList = {
	["WARRIOR"] = {
		103826,103827,103828,
		55694,29838,103840,
		{56636,169679,169680},29725,{1464,169683,169685},
		107570,46968,118000,
		114028,114029,114030,
		107574,12292,46924,
		152278,152277,{176289,152276},
	},
	["PALADIN"] = {
		85499,87172,26023,
		105593,20066,115750,
		85804,114163,{148039,20925},
		114039,114154,105622,
		105809,{53376,171648},86172,
		114165,114158,114157,
		{156910,152263},{157007,152262},{157047,152261,157048},
	},
	["HUNTER"] = {
		109215,109298,118675,
		109248,19386,19577,
		109304,109260,109212,
		177667,120679,109306,
		131894,130392,121818,
		117050,109259,120360,
		162534,{152245,163485},{152244,155228},
	},
	["ROGUE"] = {
		14062,108208,108209,
		26679,108210,74001,
		31230,108211,79008,
		138106,36554,108212,
		131511,154904,108216,
		114014,137619,114015,
		152152,152151,152150,
	},
	["PRIEST"] = {
		19236,112833,108945,
		64129,121536,108942,
		{109186,162448},123040,{129250,139139},
		108920,8122,605,
		109142,10060,{109964,109175,162452},
		{121135,127632},{110744,122121},{120517,120644},
		{152118,155245,155246},{152117,155361},{152116,155271},
	},
	["DEATHKNIGHT"] = {
		161497,123693,115989,
		49039,51052,114556,
		96268,50041,108194,
		45529,81229,51462,
		48743,108196,119975,
		108199,108200,108201,
		152281,152280,152279,
	},
	["SHAMAN"] = {
		30884,108270,108271,
		63374,51485,108273,
		108285,108284,108287,
		16166,16188,108283,
		147074,108281,108282,
		{165477,117012,165479},117013,117014,
		{152257,157153},152256,{152255,157154},
	},
	["MAGE"] = {
		157913,108843,108839,
		108978,140468,11426,
		113724,111264,102051,
		110959,86949,11958,
		{114923,44457,112948},157976,{157980,157981,157997},
		55342,116011,1463,
		{155147,155148,155149},152087,{153626,153561,153595},
	},
	["WARLOCK"] = {
		108359,108370,{108371,174848},
		5484,6789,30283,
		108415,108416,110913,
		111397,111400,108482,
		108499,108501,{108503,171975},
		108505,137587,108508,
		{152109,157695,157696},152108,152107,
	},
	["MONK"] = {
		115173,116841,115174,
		115098,124081,123986,
		121817,115396,115399,
		116844,119392,119381,
		122280,122278,122783,
		116847,123904,115008,
		{157533,157535,152175},{157676,157675,152174},{152173,173841},
	},
	["DRUID"] = {
		131768,102280,102401,
		145108,108238,102351,
		{102355,106707},102359,132469,
		{114107,158476,158477,158478},{102560,102543,102558,33891},{33831,102703,102706,102693},
		99,102793,5211,
		{108291,108292,108293,108294},{108373,158497,158501,158504},124974,
		{152222,155580,155578,155577},{152221,155672,80313,155675},{152220,171746,155835,155834},
	},
}
module.db.spell_glyphsList = {
	["WARRIOR"] = {
		[94374]=true,	[58356]=true,	[63328]=true,	[63325]=true,	[58387]=true,	[63329]=true,	[159708]=true,	[58386]=true,
	},
	["PALADIN"] = {
		[63223]=true,	[146955]=true,	[54939]=true,	[162604]=true,	[159573]=true,	[171929]=true,	[159548]=true,
	},
	["HUNTER"] = {
		[63068]=true,
	},
	["ROGUE"] = {
		[63249]=true,	[56819]=true,	[89758]=true,	[63253]=true,	[56805]=true,	[146629]=true,	[56799]=true,	[159638]=true,	[159635]=true,
	},
	["PRIEST"] = {
		[55688]=true,	[55678]=true,	[120584]=true,	[63229]=true,	[159598]=true,	[171921]=true,	[159628]=true,	[159626]=true,
	},
	["DEATHKNIGHT"] = {
		[58686]=true,	[146646]=true,	[58673]=true,	[63331]=true,	[159428]=true,
	},
	["SHAMAN"] = {
		[55446]=true,	[63270]=true,	[55443]=true,	[55454]=true,	[55451]=true,	[63291]=true,	[55441]=true,	[55442]=true,	[55455]=true,	[171933]=true,	[159640]=true,	[159643]=true,	[159648]=true,	[159650]=true,
	},
	["MAGE"] = {
		[115703]=true,	[146659]=true,	[56368]=true,	[56376]=true,	[62210]=true,
	},
	["WARLOCK"] = {
		[63309]=true,	[146964]=true,	[146962]=true,	[159665]=true,	[159697]=true,
	},
	["MONK"] = {
		[171926]=true,	[123391]=true,	[123023]=true,
	},
	["DRUID"] = {
		[62970]=true,	[114223]=true,	[116216]=true,	[116238]=true,	[59219]=true,	[116203]=true,	[54825]=true,	[171924]=true,	[159445]=true,
	}
}
module.db.spell_charge_fix = {		--Спелы с зарядами
	[161642]=1,

	[6940]=105622,
	[1022]=105622,
	[1044]=105622,
	[1038]=105622,
	[100]=103827,
	[108839]=108839,
	[77801]=108505,
	[113860]=108505,
	[113858]=108505,
	[113861]=108505,
	[1953]=146659,
	[80240]=146962,
	[109132]=1,
	[115008]=1,
	[19263]=1,
	[148467]=1,
	[61336]=1,
	[4987]=171929,
	[115450]=171926,
	[88423]=171924,
	[527]=171921,
	[77130]=171933,
	[115295]=1,
	
	[61882]=108283,
	[98008]=108283,
	[31884]=185581,
	
	--[774]=1,
}
module.db.spell_durationByTalent_fix = {	--Изменение длительности талантом\глифом   вид: [спелл] = {spellid глифа\таланта, изменение времени (-10;10;*0.5;*1.5)}
	[31884] = {53376,"*1.5"},
	[31842] = {53376,"*1.5"},
	[76577] = {56819,2},
	[1719] = {94374,"*1.5"},
	[53271] = {63068,4},
	[79140] = {63249,10},
	[1856] = {89758,2},
	[5277] = {56799,5},
	[15286] = {120584,-5},
	[48792] = {58673,"*0.25"},
	[77606] = {63331,4},
	[79206] = {55446,5,159650,-7},
	[108269] = {55442,-2},
	[11129] = {56368,"*2"},
	[12042] = {62210,"*2"},
	[61336] = {114223,"*0.5"},
	[52174] = {159708,3},
	[47585] = {159598,3},	
	[51533] = {159640,-15},
	[113860] = {159665,"*0.5"},
	[113861] = {159665,"*0.5"},
	[113858] = {159665,"*0.5"},
	[112071] = {159445,45},
	[82692] = {188200,1},
}
module.db.spell_cdByTalent_fix = {		--Изменение кд талантом\глифом   вид: [спелл] = {spellid глифа\таланта, изменение времени (-60;60);spellid2,time2;spellid3,time3;...}
	[498] = {114154,"*0.5"},
	[633] = {54939,120,	114154,"*0.5"},
	[642] = {114154,"*0.5"},
	[100] = {103826,-8},
	[781] = {118675,-10},
	[19263] = {118675,-60},
	[148467] = {118675,-60},
	[109132] = {115173,-5},
	[115008] = {115173,-5},
	[31821] = {146955,-60},
	[6343] = {58356,3},
	[23920] = {63328,-5},
	[52174] = {63325,-15},
	[6673] = {58387,-30},
	[1784] = {63253,-4},
	[1766] = {56805,-2},
	[64044] = {55688,-10},
	[6346] = {55678,-60},
	[47585] = {63229,-15},
	[47528] = {58686,-1},
	[48792] = {58673,"*0.5"},
	[77606] = {63331,-30},
	[51490] = {63270,-10,	131549,"*0.5"},
	[8056] = {55443,-2},
	[58875] = {55454,"*0.75"},
	[57994] = {55451,3},
	[51514] = {63291,-10},
	[8177] = {55441,20,159643,-3},
	[2894] = {55455,"*0.5"},
	[2139] = {115703,4},
	[11129] = {56368,"*2",	123101,"*0.8"},
	[122] = {56376,-5},
	[12042] = {62210,"*2"},
	[48020] = {63309,-4},
	[104773] = {146964,-60,159697,60},
	[80240] = {146962,35},
	[48438] = {62970,2},
	[61336] = {114223,-40},
	[106839] = {116216,5},
	[1850] = {59219,-60},
	[871] = {63329,120},
	[1044] = {159573,-5},
	[1856] = {159638,-60},
	[5277] = {159635,-30},
	[4987] = {171929,4},
	[115450] = {171926,4},
	[88423] = {171924,4},
	[527] = {171921,4},
	[77130] = {171933,4},
	[586] = {159628,60},
	[15487] = {159626,-25},
	[48982] = {159428,10},
	[51533] = {159640,-60},
	[30823] = {159648,60},
	[79206] = {159650,-60},
	[113860] = {159665,"*0.5"},
	[113861] = {159665,"*0.5"},
	[113858] = {159665,"*0.5"},
	[115080] = {123391,120},
	[119996] = {123023,-5},

	[31842] = {144613,-60,162604,"*0.5"},
	[1719] = {123144,-90},
	[12975] = {123146,-60,185796,"*0.5"},
	[55233] = {123079,-20},
	[20473] = {123103,-1},
	[31850] = {123104,-60},
	[12472] = {123101,"*0.5"},
	[45438] = {131619,-30},
	[34861] = {123113,-4},
	[18562] = {123089,-3,	38417,-2},
	[102342] = {131739,-30},
	[116680] = {138289,-5},
	[113656] = {123149,-5},
	
	[34433] = {186980,-160},
	[123040] = {186980,-40},
}
module.db.tierSetsSpells = {	--[specID.tierID.tierMark] = {2P Bonus Spell ID, 4P Bonus Spell ID}
	[65161] = {nil,144613},		--> Paladin,Holy,T16
	[65141] = {nil,123103},		--> Paladin,Holy,T14
	[66141] = {123104,nil},		--> Paladin,Tank,T14
	[71141] = {nil,123144},		--> Warrior,DPS,T14
	[73141] = {123146,nil},		--> Warrior,Tank,T14
	[250151] = {138195,nil},	--> DK,Tank,T15
	[250141] = {123079,nil},	--> DK,Tank,T14
	[62141] = {nil,123101},		--> Mage,DPS,T14
	[62162] = {nil,131619},		--> Mage,DPS,A15
	[256141] = {nil,123113},	--> Priest,Heal,T14
	[262162] = {nil,131549},	--> Shaman,Elem,A15
	[104141] = {123086,nil},	--> Druid,Tank,T14
	[105141] = {nil,123089},	--> Druid,Heal,T14
	[105162] = {38417,131739},	--> Druid,Heal,A15
	[270151] = {nil,138289},	--> Monk,Heal,T15
	[269141] = {123149,nil},	--> Monk,DPS,T14
	[259141] = {nil,123122},	--> Rogue,DPS,T14
	[11171] = {{165437},{166677}},	--> Druid T17
	[7171] = {{165605},nil},	--> Shaman T17
	
	[5181] = {186980,nil},		--> Priest T18
	[10181] = {nil,185399},		--> Monk T18
	[2181] = {185581,nil},		--> Paladin T18
	[1181] = {185796,185799},	--> Warrior T18
	[3181] = {188200,nil},		--> Hunter T18
	[4181] = {nil,186279},		--> Rouge T18
}
module.db.tierSetsList = {	-- [itemID] = specID.tierID.tierMark
	[99377] = 65161, [99378] = 65161, [99375] = 65161, [99376] = 65161, [99374] = 65161, [99133] = 65161, [99124] = 65161, [99125] = 65161, [99134] = 65161, [99135] = 65161, [99626] = 65161, [99666] = 65161, [99656] = 65161, [99648] = 65161, [99665] = 65161, [99003] = 65161, [98980] = 65161, [99076] = 65161, [98982] = 65161, [98979] = 65161,
	[87108] = 65141, [87107] = 65141, [87106] = 65141, [87105] = 65141, [87104] = 65141, [85344] = 65141, [85345] = 65141, [85346] = 65141, [85347] = 65141, [85348] = 65141, [86684] = 65141, [86685] = 65141, [86686] = 65141, [86687] = 65141, [86688] = 65141,
	[87113] = 66141, [87112] = 66141, [87111] = 66141, [87110] = 66141, [87109] = 66141, [85319] = 66141, [85320] = 66141, [85321] = 66141, [85322] = 66141, [85323] = 66141, [86659] = 66141, [86660] = 66141, [86661] = 66141, [86662] = 66141, [86663] = 66141,
	[87196] = 71141, [87195] = 71141, [87194] = 71141, [87193] = 71141, [87192] = 71141,  [85332] = 71141, [85329] = 71141, [85330] = 71141, [85331] = 71141, [85333] = 71141, [86669] = 71141, [86670] = 71141, [86671] = 71141, [86672] = 71141, [86673] = 71141,	
	[87201] = 73141, [87199] = 73141, [87200] = 73141, [87198] = 73141, [87197] = 73141, [85324] = 73141, [85325] = 73141, [85326] = 73141, [85327] = 73141, [85328] = 73141, [86664] = 73141, [86665] = 73141, [86666] = 73141, [86667] = 73141, [86668] = 73141,	
	[96574] = 250151, [96575] = 250151, [96576] = 250151, [96578] = 250151, [96577] = 250151, [95230] = 250151, [95231] = 250151, [95232] = 250151, [95233] = 250151, [95234] = 250151, [95830] = 250151, [95831] = 250151, [95832] = 250151, [95833] = 250151, [95834] = 250151,	
	[86922] = 250141, [86921] = 250141, [86919] = 250141, [86920] = 250141, [86918] = 250141, [85314] = 250141, [85315] = 250141, [85316] = 250141, [85317] = 250141, [85318] = 250141, [86654] = 250141, [86655] = 250141, [86656] = 250141, [86657] = 250141, [86658] = 250141,	
	[87011] = 62141, [87010] = 62141, [87009] = 62141, [87008] = 62141, [87007] = 62141, [85374] = 62141, [85375] = 62141, [85376] = 62141, [85377] = 62141, [85378] = 62141, [86714] = 62141, [86715] = 62141, [86716] = 62141, [86717] = 62141, [86718] = 62141,	
	[84413] = 62162, [84414] = 62162, [84415] = 62162, [84416] = 62162, [84417] = 62162, [84837] = 62162, [84855] = 62162, [84875] = 62162, [84904] = 62162, [84917] = 62162, [85016] = 62162, [85031] = 62162, [85062] = 62162, [85068] = 62162, [85085] = 62162, [88251] = 62162, [88252] = 62162, [88253] = 62162, [88254] = 62162, [88255] = 62162, [91232] = 62162, [91233] = 62162, [91234] = 62162, [91235] = 62162, [91236] = 62162, [91237] = 62162, [91238] = 62162, [91239] = 62162, [91240] = 62162, [91241] = 62162, [91585] = 62162, [91587] = 62162, [91589] = 62162, [91591] = 62162, [91593] = 62162, [93499] = 62162, [93500] = 62162, [93501] = 62162, [93502] = 62162, [93503] = 62162, [94362] = 62162, [94381] = 62162, [94389] = 62162, [94431] = 62162, [94451] = 62162, [98825] = 62162, [98826] = 62162, [98827] = 62162, [98828] = 62162, [98829] = 62162, [99852] = 62162, [99853] = 62162, [99854] = 62162, [99855] = 62162, [99856] = 62162, [100032] = 62162, [100051] = 62162, [100059] = 62162, [100101] = 62162, [100121] = 62162, [100328] = 62162, [100329] = 62162, [100330] = 62162, [100331] = 62162, [100332] = 62162, [100333] = 62162, [100334] = 62162, [100335] = 62162, [100336] = 62162, [100337] = 62162, [100592] = 62162, [100611] = 62162, [100619] = 62162, [100661] = 62162, [100681] = 62162, [102648] = 62162, [102667] = 62162, [102673] = 62162, [102715] = 62162, [102735] = 62162, [102845] = 62162, [102864] = 62162, [102870] = 62162, [102912] = 62162, [102932] = 62162, [103224] = 62162, [103225] = 62162, [103226] = 62162, [103227] = 62162, [103228] = 62162, [103421] = 62162, [103422] = 62162, [103423] = 62162, [103424] = 62162, [103425] = 62162,
	[85359] = 256141, [85360] = 256141, [85361] = 256141, [85362] = 256141, [85363] = 256141, [86699] = 256141, [86700] = 256141, [86701] = 256141, [86702] = 256141, [86703] = 256141, [87114] = 256141, [87115] = 256141, [87116] = 256141, [87117] = 256141, [87118] = 256141,
	[85379] = 104141, [85380] = 104141, [85381] = 104141, [85382] = 104141, [85383] = 104141, [86719] = 104141, [86720] = 104141, [86721] = 104141, [86722] = 104141, [86723] = 104141, [86938] = 104141, [86939] = 104141, [86940] = 104141, [86941] = 104141, [86942] = 104141,
	[85354] = 105141, [85355] = 105141, [85356] = 105141, [85357] = 105141, [85358] = 105141, [86694] = 105141, [86695] = 105141, [86696] = 105141, [86697] = 105141, [86698] = 105141, [86928] = 105141, [86929] = 105141, [86930] = 105141, [86931] = 105141, [86932] = 105141,
	[84483] = 262162, [84484] = 262162, [84485] = 262162, [84486] = 262162, [84487] = 262162, [84798] = 262162, [84845] = 262162, [84860] = 262162, [84879] = 262162, [84924] = 262162, [84988] = 262162, [85012] = 262162, [85036] = 262162, [85048] = 262162, [85079] = 262162, [88216] = 262162, [88217] = 262162, [88218] = 262162, [88219] = 262162, [88220] = 262162, [91380] = 262162, [91381] = 262162, [91382] = 262162, [91383] = 262162, [91384] = 262162, [91385] = 262162, [91386] = 262162, [91387] = 262162, [91388] = 262162, [91389] = 262162, [91733] = 262162, [91735] = 262162, [91737] = 262162, [91739] = 262162, [91741] = 262162, [93590] = 262162, [93591] = 262162, [93592] = 262162, [93593] = 262162, [93594] = 262162, [94350] = 262162, [94408] = 262162, [94409] = 262162, [94459] = 262162, [94497] = 262162, [98905] = 262162, [98906] = 262162, [98907] = 262162, [98908] = 262162, [98909] = 262162, [99927] = 262162, [99928] = 262162, [99929] = 262162, [99930] = 262162, [99931] = 262162, [100020] = 262162, [100078] = 262162, [100079] = 262162, [100129] = 262162, [100167] = 262162, [100470] = 262162, [100471] = 262162, [100472] = 262162, [100473] = 262162, [100474] = 262162, [100475] = 262162, [100476] = 262162, [100477] = 262162, [100478] = 262162, [100479] = 262162, [100580] = 262162, [100638] = 262162, [100639] = 262162, [100689] = 262162, [100727] = 262162, [102637] = 262162, [102692] = 262162, [102693] = 262162, [102743] = 262162, [102781] = 262162, [102834] = 262162, [102889] = 262162, [102890] = 262162, [102940] = 262162, [102978] = 262162, [103299] = 262162, [103300] = 262162, [103301] = 262162, [103302] = 262162, [103303] = 262162, [103496] = 262162, [103497] = 262162, [103498] = 262162, [103499] = 262162, [103500] = 262162,
	[84385] = 105162, [84386] = 105162, [84387] = 105162, [84388] = 105162, [84389] = 105162, [84833] = 105162, [84850] = 105162, [84882] = 105162, [84907] = 105162, [84927] = 105162, [85026] = 105162, [85043] = 105162, [85051] = 105162, [85071] = 105162, [85082] = 105162, [88201] = 105162, [88202] = 105162, [88203] = 105162, [88204] = 105162, [88205] = 105162, [91172] = 105162, [91173] = 105162, [91174] = 105162, [91175] = 105162, [91176] = 105162, [91177] = 105162, [91178] = 105162, [91179] = 105162, [91180] = 105162, [91181] = 105162, [91420] = 105162, [91422] = 105162, [91424] = 105162, [91426] = 105162, [91428] = 105162, [91525] = 105162, [91527] = 105162, [91529] = 105162, [91531] = 105162, [91533] = 105162, [93466] = 105162, [93467] = 105162, [93468] = 105162, [93469] = 105162, [93470] = 105162, [98797] = 105162, [98798] = 105162, [98799] = 105162, [98800] = 105162, [98801] = 105162, [99819] = 105162, [99820] = 105162, [99821] = 105162, [99822] = 105162, [99823] = 105162, [100041] = 105162, [100042] = 105162, [100107] = 105162, [100147] = 105162, [100162] = 105162, [100268] = 105162, [100269] = 105162, [100270] = 105162, [100271] = 105162, [100272] = 105162, [100273] = 105162, [100274] = 105162, [100275] = 105162, [100276] = 105162, [100277] = 105162, [100601] = 105162, [100602] = 105162, [100667] = 105162, [100707] = 105162, [100722] = 105162, [102657] = 105162, [102658] = 105162, [102721] = 105162, [102761] = 105162, [102776] = 105162, [102854] = 105162, [102855] = 105162, [102918] = 105162, [102958] = 105162, [102973] = 105162, [103192] = 105162, [103193] = 105162, [103194] = 105162, [103195] = 105162, [103196] = 105162, [103389] = 105162, [103390] = 105162, [103391] = 105162, [103392] = 105162, [103393] = 105162,
	[95270] = 270151, [95271] = 270151, [95272] = 270151, [95273] = 270151, [95274] = 270151, [95900] = 270151, [95901] = 270151, [95902] = 270151, [95903] = 270151, [95904] = 270151, [96644] = 270151, [96645] = 270151, [96646] = 270151, [96647] = 270151, [96648] = 270151,
	[85394] = 269141, [85395] = 269141, [85396] = 269141, [85397] = 269141, [85398] = 269141, [86734] = 269141, [86735] = 269141, [86736] = 269141, [86737] = 269141, [86738] = 269141, [87084] = 269141, [87085] = 269141, [87086] = 269141, [87087] = 269141, [87088] = 269141,
	[85299] = 259141, [85300] = 259141, [85301] = 259141, [85302] = 259141, [85303] = 259141, [86639] = 259141, [86640] = 259141, [86641] = 259141, [86642] = 259141, [86643] = 259141, [87124] = 259141, [87125] = 259141, [87126] = 259141, [87127] = 259141, [87128] = 259141,
	[115540] = 11171, [115541] = 11171, [115542] = 11171, [115543] = 11171, [115544] = 11171, 
	[115575] = 7171, [115576] = 7171, [115577] = 7171, [115578] = 7171, [115579] = 7171, 
	[124155] = 5181, [124161] = 5181, [124166] = 5181, [124172] = 5181, [124178] = 5181,
	[124247] = 10181, [124256] = 10181, [124262] = 10181, [124268] = 10181, [124273] = 10181,
	[124319] = 1181, [124329] = 1181, [124334] = 1181, [124340] = 1181, [124346] = 1181,
	[124318] = 2181, [124328] = 2181, [124333] = 2181, [124339] = 2181, [124345] = 2181,
	[124284] = 3181, [124292] = 3181, [124296] = 3181, [124301] = 3181, [124307] = 3181,
	[124248] = 4181, [124257] = 4181, [124263] = 4181, [124269] = 4181, [124274] = 4181,
}

module.db.spell_talentReplaceOther = {		--Спелы, показ которых нужно убрать при наличии таланта (талант заменяет эти спелы)
	[85673] = 114163,
	[3411] = 114029,
	[853] = 105593,
	[34433] = 123040,
	[47476] = 108194,
	[2484] = 51485,
	[66] = 110959,
	[109132] = 115008,
	[101546] = 116847,
	[5246] = 176289,
	[23920] = 114028,
	[43265] = 152280,
	[45438] = 157913,
}

module.db.spell_aura_list = {		--Спелы, время действия которых отменять при отмене бафа 	[buff_sid] = spellID
	[109964]=109964,
	[33206]=33206,
	[47788]=47788,
	[6940]=6940,
	[1022]=1022,
	[15286]=15286,
	[115176]=115176,
	[110913]=110913,
	[116849]=116849,
	[108281]=108281,
	[102342]=102342,
	[114039]=114039,
	[118038]=118038,
	[1044]=1044,
	[1038]=1038,
	[114030]=114030,
	[147833]=3411,
	[114192]=114192,
	[31850]=31850,
	[74001]=74001,
	[79140]=79140,
	[114018]=114018,
	[112833]=112833,
	[47585]=47585,
	[48707]=48707,
	[110960]=110959,
	[45438]=45438,
	[32612]=66,
	[116680]=116680,
	[122470]=122470,
	[122278]=122278,
	[112071]=112071,
}
module.db.spell_speed_list = {		--Спелы, которым менять время действия на основании спелхасты
	[740]=true,
	[64843]=true,
}
module.db.spell_afterCombatReset = {	--Принудительный сброс кд после боя с боссом (для спелов с кд менее 5 мин., 3мин после 6.1)
	[740]=true,
	[86659]=true,
	[161642]=true,
	
	[31884]=true,
	[12042]=true,
	
	[77801]=true,	--??? not sure, 6.2
}
module.db.spell_afterCombatNotReset = {	--Запрещать сброс кд после боя с боссом (для петов, например; для спелов с кд 5 и более мин., для анха)
	[90355]=true,
	[126393]=true,
	[53478]=true,
	[55709]=true,
	[20608]=true,
	[21169]=true,
	[159931]=true,
	[159956]=true,
	
	[26297]=true,
	[67826]=true,
}
module.db.spell_reduceCdByHaste = {	--Заклинания, кд которых уменьшается хастой
	[20473]=true,
}
module.db.spell_resetOtherSpells = {	--Заклинания, которые откатывают другие заклинания
	[11958]={45438,122},
	[108285]={108269,8177,51485,8143,5394,108270,108273},
	[14185]={1856,2983,5277},
}
module.db.spell_sharingCD = {		--Заклинания, которые запускают кд на другие заклинания 	[spellID] = {[otherSpellID] = CD}
	[102060]={[6552]=15,},
	[6552]={[102060]=15,},
	[5118]={[172106]=10,[13159]=10,},
	[172106]={[5118]=10,[13159]=10,},
	[13159]={[172106]=10,[5118]=10,},
}
module.db.spell_runningSameSpell = {	--Схожие заклинания
	[121093]={59545,59543,59548,59542,59544,59547,28880},
	[59545]={121093,59543,59548,59542,59544,59547,28880},
	[59543]={59545,121093,59548,59542,59544,59547,28880},
	[59548]={59545,59543,121093,59542,59544,59547,28880},
	[59542]={59545,59543,59548,121093,59544,59547,28880},
	[59544]={59545,59543,59548,59542,121093,59547,28880},
	[59547]={59545,59543,59548,59542,59544,121093,28880},
	[28880]={59545,59543,59548,59542,59544,59547,121093},
	[69041]={69070},
	[69070]={69041},
	[28730]={69179,129597,80483,155145,25046,50613},
	[69179]={28730,129597,80483,155145,25046,50613},
	[129597]={69179,28730,80483,155145,25046,50613},
	[80483]={69179,129597,28730,155145,25046,50613},
	[155145]={69179,129597,80483,28730,25046,50613},
	[25046]={69179,129597,80483,155145,28730,50613},
	[50613]={69179,129597,80483,155145,25046,28730},
	[106898]={77764,77761},
	[77764]={106898,77761},
	[77761]={77764,106898},
	[187611] = {187614,187615},
	[187614] = {187611,187615},
	[187615] = {187611,187614},
}

module.db.spell_reduceCdCast = {	--Заклинания, применение которых уменьшает время восстановления других заклинаний
	[2098]={13750,-10,51690,-10,2983,-10},
	[121411]={13750,-10,51690,-10,2983,-10},
	[5185]={{132158,54825},-2},
	[5176]={{112071,166677},-3},
	[2912]={{112071,166677},-3},
	[17364]={{51533,165605},-5},
	
	[167105]={{871,152278},-0.333,{1160,152278},-0.333,{12975,152278},-0.333,{1719,152278},-0.333,{118038,152278},-0.333},	--Anger Management
	[174926]={{871,152278},-0.666,{1160,152278},-0.666,{12975,152278},-0.666,{1719,152278},-0.666,{118038,152278},-0.666},	--Anger Management
	[12328]={{871,152278},-0.333,{1160,152278},-0.333,{12975,152278},-0.333,{1719,152278},-0.333,{118038,152278},-0.333},	--Anger Management
	[1464]={{871,152278},-0.333,{1160,152278},-0.333,{12975,152278},-0.333,{1719,152278},-0.333,{118038,152278},-0.333},	--Anger Management
	[1715]={{871,152278},-0.333,{1160,152278},-0.333,{12975,152278},-0.333,{1719,152278},-0.333,{118038,152278},-0.333},	--Anger Management
	[85288]={{871,152278},-0.333,{1160,152278},-0.333,{12975,152278},-0.333,{1719,152278},-0.333,{118038,152278},-0.333},	--Anger Management
	[103840]={{871,152278},-0.333,{1160,152278},-0.333,{12975,152278},-0.333,{1719,152278},-0.333,{118038,152278},-0.333},	--Anger Management
	[1680]={{871,152278},-0.666,{1160,152278},-0.666,{12975,152278},-0.666,{1719,152278},-0.666,{118038,152278},-0.666},	--Anger Management
	[12323]={{871,152278},-0.333,{1160,152278},-0.333,{12975,152278},-0.333,{1719,152278},-0.333,{118038,152278},-0.333},	--Anger Management
	[2565]={{871,152278},-2,{1160,152278},-2,{12975,152278},-2,{1719,152278},-2,{118038,152278},-2},			--Anger Management
	[100130]={{871,152278},-1.5,{1160,152278},-1.5,{12975,152278},-1.5,{1719,152278},-1.5,{118038,152278},-1.5},		--Anger Management
	[156321]={{871,152278},-0.666,{1160,152278},-0.666,{12975,152278},-0.666,{1719,152278},-0.666,{118038,152278},-0.666},	--Anger Management
	[6343]={{871,152278},-0.333,{1160,152278},-0.333,{12975,152278},-0.333,{1719,152278},-0.333,{118038,152278},-0.333},	--Anger Management
	[12294]={{871,152278},-0.666,{1160,152278},-0.666,{12975,152278},-0.666,{1719,152278},-0.666,{118038,152278},-0.666},	--Anger Management
	[163201]={{871,152278},-0.333,{1160,152278},-0.333,{12975,152278},-0.333,{1719,152278},-0.333,{118038,152278},-0.333},	--Anger Management
	[5308]={{871,152278},-1,{1160,152278},-1,{12975,152278},-1,{1719,152278},-1,{118038,152278},-1},			--Anger Management
	[772]={{871,152278},-0.167,{1160,152278},-0.167,{12975,152278},-0.167,{1719,152278},-0.167,{118038,152278},-0.167},	--Anger Management
	
	[115072]={{115295,185399},-5},
	[2098]={{1856,186279},-5},
	[1943]={{1856,186279},-5},
}
module.db.spell_increaseDurationCast = {	--Заклинания, продляющие время действия
	[12294]={{118038,58386},2},
	[100130]={{118038,58386},0.25},
	[30455]={{12472,155149},2},
}
module.db.spell_dispellsFix = {}
module.db.spell_dispellsList = {	--Заклинания-диспелы (мгновенно откатываются, если ничего не диспелят)
	[4987] = true,
	[527] = true,
	[51886] = true,
	[77130] = true,
	[475] = true,
	[115450] = true,
	[2782] = true,
	[88423] = true,
}
module.db.spell_notInCLEU_fix = {	--Заклинания, которые не отображаются в комбат-логе; выполнять проверку по UNIT_SPELLCAST_SUCCEEDED
	--[86659] = true,	-- Was fixed in 6.1
}

module.db.spell_startCDbyAuraFade = {	--Заклинания, кд которых запускается только при спадении ауры
	[89485]=true,
	[132158]=true,
	[34477]=true,
}
module.db.spell_startCDbyAuraApplied = {	--Заклинания, кд которых запускается только при наложении ауры (вида [aura_spellID] = CD_spellID)
	[117679]=33891,
}
module.db.spell_startCDbyAuraApplied_fix = {}
for _,spellID in pairs(module.db.spell_startCDbyAuraApplied) do module.db.spell_startCDbyAuraApplied_fix[spellID] = true end

module.db.spell_reduceCdByAuraFade = {	--Заклинания, кд которых уменьшается при спадении ауры до окончания времени действия. !Важно обязательное время действия для таких заклинаний
	[31850]={{31850,159548},-120},
}
module.db.spell_battleRes = {		--Заклинания-воскрешения [WOD]
	[20484]=true,
	[20707]=true,
	[61999]=true,
	--[126393]=true,
	[161642]=true,
	--[159931]=true,
	--[159956]=true,
}
module.db.isResurectDisabled = nil

module.db.spell_isRacial = {		--Расовые заклинания
	[68992]="Worgen",
	[20589]="Gnome",
	[20594]="Dwarf",
	[121093]="Draenei",
	[59545]="Draenei",
	[59543]="Draenei",
	[59548]="Draenei",
	[59542]="Draenei",
	[59544]="Draenei",
	[59547]="Draenei",
	[28880]="Draenei",
	[58984]="NightElf",
	[107079]="Pandaren",
	[59752]="Human",
	[69041]="Goblin",
	[69070]="Goblin",
	[69046]="Goblin",
	[7744]="Undead",
	[20577]="Undead",
	[20572]="Orc",
	[33697]="Orc",
	[33702]="Orc",
	[20549]="Tauren",
	[26297]="Troll",
	[28730]="BloodElf",
	[69179]="BloodElf",
	[129597]="BloodElf",
	[80483]="BloodElf",
	[155145]="BloodElf",
	[25046]="BloodElf",
	[50613]="BloodElf",
}

module.db.def_col = {			--Стандартные положения в колонках
	["31821;2"]=1,
	["62618;2"]=1,
	["97462;2"]=1,
	["97462;3"]=1,
	["114203;1"]=1,
	["76577;1"]=1,
	["115213;4"]=1,
	["51052;1"]=1,
	["98008;4"]=1,
	["115310;4"]=1,
	["64843;3"]=1,
	["740;5"]=1,
	["108280;4"]=1,
	["108281;1"]=1,
	["172106;1"]=1,
	["172106;1"]=1,
	["161642;1"]=3,
	["20484;1"]=3,
	["20707;1"]=3,
	["61999;1"]=3,
	["64901;1"]=3,
	["47788;3"]=2,
	["33206;2"]=2,
	["6940;1"]=2,
	["6940;4"]=2,
	["102342;5"]=2,
	["114030;1"]=2,
	["1022;1"]=2,
	["16190;4"]=3,
	["114207;1"]=3,
	["120668;1"]=3,
	["106898;1"]=3,
	["77764;3"]=3,
	["77761;4"]=3,
	["29166;1"]=3,
	["73325;1"]=3,
	["108968;1"]=2,
	["142723;4"]=2,
	["115176;1"]=3,
	["57934;1"]=3,
	["108199;1"]=3,
	["110913;1"]=2,
	["116849;4"]=2,
	["114039;1"]=2,
	["118038;2"]=3,
	["118038;3"]=3,
	["1044;1"]=3,
	["1038;1"]=3,
	["633;1"]=2,
	["109964;2"]=3,
	["2825;1"]=3,
	["80353;1"]=3,
	["20608;1"]=3,
}

module.db.petsAbilities = {	--> PetTypes = HUNTERS[ Tenacity [1], Cunning = [2], Ferocity[3] ]
	[0] = 						{},
	[L.creatureNames["Basilisk"]] = 		{1,	{159733,45},	},
	[L.creatureNames["Bat"]] = 		{2,	},
	[L.creatureNames["Bear"]] = 		{1,	{50256,10},	},
	[L.creatureNames["Beetle"]] = 		{1,	{90339,60,12},	},
	[L.creatureNames["Bird of Prey"]] = 	{2,	},
	[L.creatureNames["Boar"]] = 		{1,	},
	[L.creatureNames["Carrion Bird"]] = 	{3,	{24423,6},	},
	[L.creatureNames["Cat"]] = 		{3,	{24450,10},	{93435,45},	},
	[L.creatureNames["Chimaera"]] = 		{2,	{54644,10},	},
	[L.creatureNames["Core Hound"]] = 		{3,	{90355,360,40},	},
	[L.creatureNames["Crab"]] = 		{1,	{159926,60,12},	},
	[L.creatureNames["Crane"]] = 		{2,	{159931,600},	},
	[L.creatureNames["Crocolisk"]] = 		{1,	{50433,10},	},
	[L.creatureNames["Devilsaur"]] = 		{3,	{159953,60},	{54680,8},	},
	[L.creatureNames["Direhorn"]] = 		{1,	{137798,30},	},
	[L.creatureNames["Dog"]] = 		{3,	},
	[L.creatureNames["Dragonhawk"]] = 		{2,	},
	[L.creatureNames["Fox"]] = 		{3,	{160011,120},	},
	[L.creatureNames["Goat"]] = 		{3,	},
	[L.creatureNames["Gorilla"]] = 		{1,	},
	[L.creatureNames["Hyena"]] = 		{3,	{128432,90},	},
	[L.creatureNames["Monkey"]] = 		{2,	{160044,120},	},
	[L.creatureNames["Moth"]] = 		{3,	{159956,600},	},
	[L.creatureNames["Nether Ray"]] = 		{2,	{90355,360,40},	},
	[L.creatureNames["Porcupine"]] = 		{1,	},
	[L.creatureNames["Quilen"]] = 		{3,	{126393,600},	},
	[L.creatureNames["Raptor"]] = 		{3,	{160052,45},	},
	[L.creatureNames["Ravager"]] = 		{2,	},
	["Clefthoof"] = 				{1,	},					-- Clefthoof[WOD] = Rhino
	[L.creatureNames["Scorpid"]] = 		{1,	{160060,6},	},
	[L.creatureNames["Serpent"]] = 		{2,	{128433,90},	},
	[L.creatureNames["Shale Spider"]] = 	{1,	{160063,60,12},	},
	[L.creatureNames["Silithid"]] = 		{2,	{160065,10},	},
	[L.creatureNames["Spider"]] = 		{2,	{160067,10},	},
	[L.creatureNames["Spirit Beast"]] = 	{3,	{90328,10},	{90361,30},	},
	[L.creatureNames["Sporebat"]] = 		{2,	},
	[L.creatureNames["Tallstrider"]] = 	{3,	{160073,45},	},
	[L.creatureNames["Turtle"]] = 		{1,	{26064,60,12},	},
	[L.creatureNames["Warp Stalker"]] = 	{1,	{35346,15},	},
	[L.creatureNames["Wasp"]] = 		{3,	},
	[L.creatureNames["Water Strider"]] = 	{2,	},
	[L.creatureNames["Wind Serpent"]] = 	{2,	},
	[L.creatureNames["Wolf"]] = 		{3,	{24604,45},	},
	[L.creatureNames["Worm"]] = 		{1,	{93433,14},	},
	[1] = 						{0,	{53478,360,20},	{61685,25},	{63900,10},	},
	[2] = 						{0,	{53490,180,12},	{61684,32,16},	{53480,60,12},	},
	[3] = 						{0,	{61684,32,16},	{55709,480},	},
	[L.creatureNames["Ghoul"]] = 		{0,	{91837,45,10},	{91802,30},	{91797,60},	},
	[L.creatureNames["Felguard"]] = 		{0,	{89751,45,6},	{89766,30},	{30151,15},	},
	[L.creatureNames["Felhunter"]] = 		{0,	{19647,24},	{19505,15},	},
	[L.creatureNames["Fel Imp"]] = 		{0,	{115276,30},	},
	[L.creatureNames["Imp"]] = 		{0,	{89808,10},	{119899,30,12},	{89792,20},	},
	[L.creatureNames["Observer"]] = 		{0,	{115781,24},	{115284,15},	},
	[L.creatureNames["Shivarra"]] = 		{0,	{115770,25},	{115268,30},	},
	[L.creatureNames["Succubus"]] = 		{0,	{6360,25},	{6358,30},	},
	[L.creatureNames["Voidlord"]] = 		{0,	{115236,10}	},
	[L.creatureNames["Voidwalker"]] = 		{0,	{17735,10},	{17767,120,20},	{115232,10},	},
	[L.creatureNames["Wrathguard"]] = 		{0,	{115831,45,6},	},
	[L.creatureNames["Water Elemental"]] = 	{0,	{135029,25,4},	{33395,25},	},
}
module.db.spell_isPetAbility = {}
do
	for petName,petData in pairs(module.db.petsAbilities) do
		for i=2,#petData do
			module.db.spell_isPetAbility[petData[i][1]] = petName
		end
	end
end

module.db.itemsToSpells = {	-- Тринкеты вида [item ID] = spellID
	[113931] = 176878,
	[113969] = 176874,
	[118876] = 177597,	--Coin
	[118878] = 177594,	--Couplend
	[118880] = 177592,	--Candle
	[118882] = 177189,	--Kyanos
	[118884] = 176460,	--Kyb
	[113905] = 176873,	--Tank BRF
	[113834] = 176876,
	[113835] = 176875,	--Shard of nothing
	[113842] = 176879,
	[110002] = 165531,
	[110003] = 165543,
	[110008] = 165535,
	[110012] = 165532,
	[110013] = 165543,
	[110017] = 165534,
	[110018] = 165535,
	[114488] = 176883,
	[114489] = 176882,
	[114490] = 176884,
	[114491] = 176881,
	[114492] = 176885,
	[109997] = 165485,
	[109998] = 165542,
	[110007] = 165532,
	[124224] = 184270,	--Mirror of the Blademaster
	[124232] = 183929,	--Intuition's Gift
	[133598] = 201414,
	[133585] = 201371,
}
do
	for itemID,spellID in pairs(module.db.itemsToSpells) do
		module.db.spell_isTalent[spellID] = true
	end
end
ExRT.F.table_add2(module.db.itemsToSpells,{
	[124634] = 187614,
	[124636] = 187615,
	[124635] = 187611,
	[124637] = 187613,
	[124638] = 187612,
})

module.db.differentIcons = {	--Другие иконки заклинаниям
	[176875]="Interface\\Icons\\Inv_misc_trinket6oOG_Isoceles1",
	[176873]="Interface\\Icons\\Inv_misc_trinket6oIH_orb4",
	[184270]="Interface\\Icons\\spell_nature_mirrorimage",
	[183929]="Interface\\Icons\\spell_mage_presenceofmind",	
	[187614]="Interface\\Icons\\inv_60legendary_ring1c",
	[187613]="Interface\\Icons\\inv_60legendary_ring1b",
	[187612]="Interface\\Icons\\inv_60legendary_ring1a",
}

local isLegendaryRingInRaid_DD = nil
local isLegendaryRingInRaid_Tank = nil
local isLegendaryRingInRaid_Heal = nil

module.db.playerName = nil

module.db.plugin = {}

module.db.notAClass = { r = 0.8, g = 0.8, b = 0.8, colorStr = "ffcccccc" }

local colorSetupFrameColorsNames = {"Default","Active","Cooldown"}
local colorSetupFrameColorsObjectsNames = {"Text","Background","TimeLine"}
local globalGUIDs = nil

module.db.maxLinesInCol = 100
module.db.maxColumns = 10

module.db.colsDefaults = {
	iconSize = 16,
	iconGray = true,
	iconPosition = 1,
	textureFile = ExRT.F.barImg,
	textureBorderSize = 0,
	fontSize = 12,
	fontName = ExRT.F.defFont,
	frameLines = 15,
	frameAlpha = 100,
	frameScale = 100,
	frameWidth = 130,
	frameColumns = 1,
	frameBetweenLines = 0,
	frameBlackBack = 0,
	methodsStyleAnimation = 1,
	methodsTimeLineAnimation = 1,
	methodsSortingRules = 1,
	methodsAlphaNotInRangeNum = 90,
	
	textureBorderColorR = 0,	textureBorderColorG = 0,	textureBorderColorB = 0,	textureBorderColorA = 1,
	
	textureColorTextDefaultR = 1,	textureColorTextDefaultG = 1,	textureColorTextDefaultB = 1,
	textureColorTextActiveR = 1,	textureColorTextActiveG = 1,	textureColorTextActiveB = 1,
	textureColorTextCooldownR = 1,	textureColorTextCooldownG = 1,	textureColorTextCooldownB = 1,

	textureColorBackgroundDefaultR = 0,	textureColorBackgroundDefaultG = 1,	textureColorBackgroundDefaultB = 0,
	textureColorBackgroundActiveR = 0,	textureColorBackgroundActiveG = 1,	textureColorBackgroundActiveB = 0,
	textureColorBackgroundCooldownR = 1,	textureColorBackgroundCooldownG = 0,	textureColorBackgroundCooldownB = 0,

	textureColorTimeLineDefaultR = 0,	textureColorTimeLineDefaultG = 1,	textureColorTimeLineDefaultB = 0,
	textureColorTimeLineActiveR = 0,	textureColorTimeLineActiveG = 1,	textureColorTimeLineActiveB = 0,
	textureColorTimeLineCooldownR = 1,	textureColorTimeLineCooldownG = 0,	textureColorTimeLineCooldownB = 0,
	
	textureAlphaBackground = 0.3,
	textureAlphaTimeLine = 0.8,
	textureAlphaCooldown = 1,
	
	textTemplateLeft = "%name%",
	textTemplateRight = "%time%",
	textTemplateCenter = "",
	
	blacklistText = "",
	whitelistText = "",
}

module.db.colsInit = {
	iconGeneral = true,
	textureGeneral = true,
	methodsGeneral = true,
	frameGeneral = true,
	fontGeneral = true,
	textGeneral = true,
	blacklistGeneral = true,
	
	iconGray = true,
	textureAnimation = true,
	
	fontOutline = true,
	fontShadow = false,
}

module.db.status_UnitsToCheck = {}
module.db.status_UnitIsDead = {}
module.db.status_UnitIsDisconnected = {}
module.db.status_UnitIsOutOfRange = {}

-- Local functions vaules; other upvaules

local UpdateAllData,SortAllData = nil
local SaveCDtoVar = nil
local CLEUstartCD = nil
local RaidResurrectSpecialCheck,RaidResurrectSpecialText,RaidResurrectSpecialStatus = nil

local L_Offline,L_Dead = L.cd2StatusOffline, L.cd2StatusDead
local _C, _db, _mainFrame = module._C, module.db

local status_UnitsToCheck,status_UnitIsDead,status_UnitIsDisconnected,status_UnitIsOutOfRange = module.db.status_UnitsToCheck,module.db.status_UnitIsDead,module.db.status_UnitIsDisconnected,module.db.status_UnitIsOutOfRange

local module_legendary_ring = nil

do
	local frame = CreateFrame("Frame",nil,UIParent)
	module.frame = frame
	frame:SetPoint("CENTER",UIParent, "CENTER", 0, 0)
	frame:EnableMouse(true)
	frame:SetMovable(true)
	frame:RegisterForDrag("LeftButton")
	frame:SetScript("OnDragStart", function(self) 
		if self:IsMovable() then 
			self:StartMoving() 
		end 
	end)
	frame:SetScript("OnDragStop", function(self)
		self:StopMovingOrSizing()
		VExRT.ExCD2.Left = self:GetLeft()
		VExRT.ExCD2.Top = self:GetTop()
	end)
	frame.texture = frame:CreateTexture(nil, "BACKGROUND")
	frame.texture:SetTexture(0,0,0,0.3)
	frame.texture:SetAllPoints()
	module:RegisterHideOnPetBattle(frame)
	
	frame.colFrame = {}
	
	--upvaule
	_mainFrame = frame
end

local function BarUpdateText(self)
	local barParent = self.parent
		
	local textLeft = barParent.textTemplateLeft
	local textRight = barParent.textTemplateRight
	local textCenter = barParent.textTemplateCenter
	
	local barData = self.data

	local time = (self.curr_end or 0) - GetTime() + 1

	if barData.specialTimer then
		local newTime = barData.specialTimer()
		time = newTime and newTime+1 or time
	end
	
	local name = barData.name
	local spellName = barData.spellName
	
	local longtime,shorttime = nil
	
	if time > 3600 then
		longtime = "1+hour"
		shorttime = "1+hour"
	elseif time < 1 then
		longtime = ""
		shorttime = ""
	else
		longtime = format("%1.1d:%2.2d",time/60,time%60)
		if time < 11 then
			shorttime = format("%.01f",time - 1)
		elseif time < 60 then
			shorttime = format("%d",time)
		else
			shorttime = longtime
		end
	end
	
	if barData.specialAddText then
		name = name .. (barData.specialAddText() or "")
	end
	
	local name_time = time > 0.999 and longtime or name
	local name_stime = time > 0.999 and shorttime or name
	local offStatus = self.disStatus or ""
	local chargesCount = self.curr_charges and "("..self.curr_charges..")" or ""
	
	textLeft = string_gsub(textLeft,"%%time%%",longtime)
	textLeft = string_gsub(textLeft,"%%stime%%",shorttime)
	textLeft = string_gsub(textLeft,"%%name%%",name)
	textLeft = string_gsub(textLeft,"%%name_time%%",name_time)
	textLeft = string_gsub(textLeft,"%%name_stime%%",name_stime)
	textLeft = string_gsub(textLeft,"%%spell%%",spellName)
	textLeft = string_gsub(textLeft,"%%status%%",offStatus)
	textLeft = string_gsub(textLeft,"%%charge%%",chargesCount)
	textRight = string_gsub(textRight,"%%time%%",longtime)
	textRight = string_gsub(textRight,"%%stime%%",shorttime)
	textRight = string_gsub(textRight,"%%name%%",name)
	textRight = string_gsub(textRight,"%%name_time%%",name_time)
	textRight = string_gsub(textRight,"%%name_stime%%",name_stime)
	textRight = string_gsub(textRight,"%%spell%%",spellName)
	textRight = string_gsub(textRight,"%%status%%",offStatus)
	textRight = string_gsub(textRight,"%%charge%%",chargesCount)
	textCenter = string_gsub(textCenter,"%%time%%",longtime)
	textCenter = string_gsub(textCenter,"%%stime%%",shorttime)
	textCenter = string_gsub(textCenter,"%%name%%",name)
	textCenter = string_gsub(textCenter,"%%name_time%%",name_time)
	textCenter = string_gsub(textCenter,"%%name_stime%%",name_stime)
	textCenter = string_gsub(textCenter,"%%spell%%",spellName)
	textCenter = string_gsub(textCenter,"%%status%%",offStatus)
	textCenter = string_gsub(textCenter,"%%charge%%",chargesCount)
	
	self.textLeft:SetText(string_trim(textLeft))
	self.textRight:SetText(string_trim(textRight))
	self.textCenter:SetText(string_trim(textCenter))
end

local function BarAnimation(self)
	local bar = self.bar
	local t = GetTime()
	
	if t > bar.curr_end then
		bar:Stop()
	else
		bar.statusbar:SetValue(t)
		bar.spark:SetPoint("CENTER",bar.statusbar,"LEFT", (t-bar.curr_start) / bar.curr_dur * bar.statusbar:GetWidth(),0)
	end
	self.c = self.c + 1
	if self.c > 3 then
		self.c = 0
		
		bar:UpdateText()
	end
end

local function BarAnimation_Reverse(self)
	local bar = self.bar
	local t = GetTime()
	
	if t > bar.curr_end then
		bar:Stop()
	else
		bar.statusbar:SetValue(bar.curr_end - t + bar.curr_start)
		bar.spark:SetPoint("CENTER",bar.statusbar,"LEFT", (bar.curr_dur - (t-bar.curr_start)) / bar.curr_dur * bar.statusbar:GetWidth(),0)
	end
	self.c = self.c + 1
	if self.c > 3 then
		self.c = 0
		
		bar:UpdateText()
	end
end

local function BarAnimation_NoAnimation(self)
	local bar = self.bar
	local t = GetTime()
	
	if t > bar.curr_end then
		bar:Stop()
	end
	self.c = self.c + 1
	if self.c > 3 then
		self.c = 0
		
		bar:UpdateText()
	end
end

local function StopBar(self)
  	self.anim:Stop()
  	self.spark:Hide()
 	self.statusbar:SetMinMaxValues(0,1)
 	self.statusbar:SetValue(1)
 	self:UpdateStatus()
 	if VExRT.ExCD2.SortByAvailability then
 		SortAllData()
 	end
 	UpdateAllData()
end

local function UpdateBar(self)
	local data = self.data
	if not data then
		self:Hide()
		return
	end
	if not self:IsVisible() then
		self:Show()
	end
	local parent = self.parent
	
	self.iconTexture:SetTexture(data.icon)
	self:UpdateText()
	if parent.optionIconName then
		self.textIcon:SetText(data.name)
	end
end

local function UpdateBarStatus(self,isTitle)
	local data = self.data
	if not data then
		return
	end
	if self.isTitle then
		self:UpdateStyle()
		self.isTitle = nil
	end
	if data.specialUpdateData then		--For templates
		data.specialUpdateData(data)
	end
	local parent = self.parent
	local currTime = GetTime()
	local lastUse = data.lastUse

	local active = lastUse + data.duration
	local cooldown = lastUse + data.cd
	
	if parent.methodsDisableActive then
		active = 0
	end
	
	local isActive = (active - currTime) > 0
	local isCooldown = (cooldown - currTime) > 0
	local t = (isActive and active) or (isCooldown and cooldown)
	
	local isDisabled = data.disabled
	if isDisabled then
		isCooldown = true
	end
	if data.specialStatus then
		local var1,var2,var3 = data.specialStatus()
		if var2 then
			if var1 then
				isCooldown = true
				lastUse = var2
				t = var2 + var3
			else
				isCooldown = false
				t = nil				
			end
		end
	end
	
	self.curr_charges = nil

	local isCharge = nil
	if data.isCharge then
		if data.charge then
			if data.charge <= currTime and (data.charge+data.cd) > currTime then
				isCharge = true
				
				isCooldown = false
				
				self.curr_charges = 1
			elseif data.charge > currTime and not isActive then
				lastUse = data.charge - data.cd
				t = data.charge
				
				isCooldown = true
				
				self.curr_charges = 0
			end
		else
			self.curr_charges = 2
		end
	end
	
	if isCharge and not isActive then
		self.curr_start = data.charge
		self.curr_end = data.charge+data.cd
		self.curr_dur = data.cd
	
		if parent.optionTimeLineAnimation == 1 then
			self.statusbar:SetMinMaxValues(currTime+50000,currTime+50001)
		else
			self.statusbar:SetMinMaxValues(0,1)
		end
		self.spark:Show()
		self.anim:Play()
	elseif t then
		self.curr_start = lastUse
		self.curr_end = t
		self.curr_dur = t - lastUse
	
		self.statusbar:SetMinMaxValues(lastUse,t)
		self.spark:Show()
		self.anim:Play()
	else
		self.curr_start = 0
		self.curr_end = 1
		self.curr_dur = 1

	  	self.spark:Hide()
	  	self.anim:Stop()
	  	
	 	self.statusbar:SetMinMaxValues(0,1)
	  	if isDisabled then
	  		self.statusbar:SetValue(0)
	  	else
	  		if parent.optionTimeLineAnimation == 1 then
	  			self.statusbar:SetValue(0)
	  		else
	 			self.statusbar:SetValue(1)
	 		end
	 	end
	end
	
	local colorTable = nil
	if parent.optionClassColorBackground then
		colorTable = data.classColor
	else
		if isActive then
			colorTable = parent.optionColorBackgroundActive
		elseif isCooldown then
			colorTable = parent.optionColorBackgroundCooldown
		else
			colorTable = parent.optionColorBackgroundDefault
		end
	end
	self.background:SetVertexColor(colorTable.r,colorTable.g,colorTable.b,parent.optionAlphaBackground)
	
	if parent.optionClassColorTimeLine then
		colorTable = data.classColor
	else
		if isActive then
			colorTable = parent.optionColorTimeLineActive
		elseif isCooldown then
			colorTable = parent.optionColorTimeLineCooldown
		else
			colorTable = parent.optionColorTimeLineDefault
		end
	end
	self.statusbar:SetStatusBarColor(colorTable.r,colorTable.g,colorTable.b,parent.optionAlphaTimeLine)
	
	if parent.optionClassColorText then
		colorTable = data.classColor
	else
		if isActive then
			colorTable = parent.optionColorTextActive
		elseif isCooldown then
			colorTable = parent.optionColorTextCooldown
		else
			colorTable = parent.optionColorTextDefault
		end
	end	
	self.textLeft:SetTextColor(colorTable.r,colorTable.g,colorTable.b)
	self.textRight:SetTextColor(colorTable.r,colorTable.g,colorTable.b)
	self.textCenter:SetTextColor(colorTable.r,colorTable.g,colorTable.b)
	self.textIcon:SetTextColor(colorTable.r,colorTable.g,colorTable.b)
	
	if parent.optionGray then
		if isCooldown and not isActive then
			self.iconTexture:SetDesaturated(true)
		else
			self.iconTexture:SetDesaturated(nil)
		end
	end
	
	if parent.optionCooldown then
		-- BIG NOTE:
		-- Cooldown widget is currently bugged
		-- You can set time ( CD_end_time - Now_time ) only for number that is bigger than UI session (ie after reloadUI UI session timer will be 0)
		-- No way for fix :(
	
		if isActive then
			self.cooldown:Show()
			self.cooldown:SetReverse(true)
			self.cooldown:SetCooldown(self.curr_start,self.curr_end-self.curr_start)
		elseif isCooldown then
			self.cooldown:Show()
			self.cooldown:SetReverse(false)
			if isDisabled then
				self.cooldown:SetCooldown(currTime,0)
			else
				self.cooldown:SetCooldown(self.curr_start,self.curr_dur)
			end
		else
			self.cooldown:Hide()
		end
	end
	
	local alpha = 1
	if parent.methodsAlphaNotInRange then
		if data.outofrange then
			alpha = parent.methodsAlphaNotInRangeNum
			self:SetAlpha(alpha)
		else
			self:SetAlpha(1)
		end
	end
	
	if (parent.optionAlphaCooldown or 1) < 1 then
		if isCooldown and not isActive then
			self:SetAlpha(parent.optionAlphaCooldown)
		else
			self:SetAlpha(alpha)
		end
	end
	
	if isDisabled == 2 then
		self.disStatus = L_Offline
	elseif isDisabled == 1 then
		self.disStatus = L_Dead
	else
		self.disStatus = nil
	end
	
	self:UpdateText()
end

local function BarCreateTitle(self)
	local parent = self.parent

	local height = parent.iconSize or 24

	self.statusbar:ClearAllPoints()	self.statusbar:SetHeight(height)
	self.icon:ClearAllPoints()	self.icon:SetSize(height,height)
	
	self.textLeft:SetText("")
	self.textRight:SetText("")
	self.textCenter:SetText("")
	self.textIcon:SetText("")
	
	if parent.optionIconPosition == 2 then
		self.icon:Show()
		self.statusbar:SetPoint("LEFT",self,0,0)
		self.statusbar:SetPoint("RIGHT",self,-height,0)
		self.icon:SetPoint("RIGHT",self,0,0)
		
		self.textRight:SetPoint("LEFT",self,0,0)

		self.textRight:SetTextColor(1,1,1)
		self.textRight:SetText(self.data.spellName)
	elseif parent.optionIconPosition == 1 then
		self.icon:Show()
		self.statusbar:SetPoint("LEFT",self,height,0)
		self.statusbar:SetPoint("RIGHT",self,0,0)
		self.icon:SetPoint("LEFT",self,0,0)
		
		self.textLeft:SetTextColor(1,1,1)
		self.textLeft:SetText(self.data.spellName)		
	end
	
	self.curr_start = 0
	self.curr_end = 1
	self.curr_dur = 1

  	self.spark:Hide()
  	self.anim:Stop()
  	
 	self.statusbar:SetMinMaxValues(0,1)
  	self.statusbar:SetValue(0)
  	
  	self.background:SetVertexColor(0,0,0,parent.optionAlphaTimeLine)
  	
  	self.iconTexture:SetTexture(self.data.icon)
  	self.cooldown:Hide()
  	
  	self:SetAlpha(1)
  	self:Show()
  	
  	self.isTitle = true
end

local function LineIconOnHover(self)
	local parent = self:GetParent()
	if not parent.data then	return end
	GameTooltip:SetOwner(self, "ANCHOR_LEFT")
	GameTooltip:SetHyperlink("spell:"..parent.data.db[1])
	GameTooltip:Show()
end
local function LineIconOnClick(self)
	local parent = self:GetParent()
	if not parent.data then	return end
	if parent.data.specialClick then
		parent.data.specialClick(parent.data)
		return
	end	
	local time = parent.data.lastUse + parent.data.cd - GetTime()
	if time < 0 then return end
	local text = parent.data.name.." - "..parent.data.spellName..": "..format("%1.1d:%2.2d",time/60,time%60)
	local chat_type = ExRT.F.chatType(true)
	SendChatMessage(text,chat_type)
end

local function UpdateBarStyle(self)
	local parent = self.parent

	local width = parent.barWidth or 100
	local height = parent.iconSize or 24
	
	self:SetSize(width,height)
	
	self.textLeft:ClearAllPoints()	self.textLeft:SetSize(0,height)	
	self.textRight:ClearAllPoints()	self.textRight:SetSize(0,height)
	self.textCenter:ClearAllPoints()self.textCenter:SetSize(0,height)
					self.textIcon:SetSize(height,height)
	self.icon:ClearAllPoints()	self.icon:SetSize(height,height)
	self.statusbar:ClearAllPoints()	self.statusbar:SetHeight(height)
					self.spark:SetSize(10,height+10)
					self.cooldown:SetSize(height,height)
	
	if parent.optionIconPosition == 3 or parent.optionIconTitles then
		self.icon:Hide()
		self.statusbar:SetPoint("LEFT",self,0,0)
		self.statusbar:SetPoint("RIGHT",self,0,0)
	elseif parent.optionIconPosition == 2 then
		self.icon:Show()
		self.statusbar:SetPoint("LEFT",self,0,0)
		self.statusbar:SetPoint("RIGHT",self,-height,0)
		self.icon:SetPoint("RIGHT",self,0,0)
	else
		self.icon:Show()
		self.statusbar:SetPoint("LEFT",self,height,0)
		self.statusbar:SetPoint("RIGHT",self,0,0)
		self.icon:SetPoint("LEFT",self,0,0)
	end
	
	if parent.optionIconHideBlizzardEdges then
		self.iconTexture:SetTexCoord(.1,.9,.1,.9)
	else
		self.iconTexture:SetTexCoord(0,1,0,1)
	end
	
	if parent.optionHideSpark then
		self.spark:SetTexture("")
	else
		self.spark:SetTexture("Interface\\CastingBar\\UI-CastingBar-Spark")
	end
	
	local fontOutlineFix = parent.fontOutline and 3 or 0
	if parent.textTemplateLeft:find("time%%") then
		self.textLeft:SetPoint("LEFT",self.statusbar,1,0)
		self.textRight:SetPoint("RIGHT",self.statusbar,-1+fontOutlineFix,0)
		self.textRight:SetPoint("LEFT",self.textLeft,"RIGHT",0,0)
	else
		self.textRight:SetPoint("RIGHT",self.statusbar,-1+fontOutlineFix,0)
		self.textLeft:SetPoint("LEFT",self.statusbar,1,0)
		self.textLeft:SetPoint("RIGHT",self.textRight,"LEFT",0,0)
	end
	
	self.textCenter:SetPoint("LEFT",self.statusbar,0,0)
	self.textCenter:SetPoint("RIGHT",self.statusbar,0,0)
	
	self.barWidth = width
	
	local textureFile = parent.textureFile or module.db.colsDefaults.textureFile
	local isValidTexture = self.background:SetTexture(textureFile)
	if not isValidTexture then
		textureFile = module.db.colsDefaults.textureFile
		self.background:SetTexture(textureFile)
	end
	self.statusbar:SetStatusBarTexture(textureFile)
	self.statusbar:GetStatusBarTexture():SetDrawLayer("BACKGROUND",0)
	
	local isValidFont = nil
	
	isValidFont = self.textLeft:SetFont(parent.fontLeftName,parent.fontLeftSize,parent.fontLeftOutline and "OUTLINE")	if not isValidFont then self.textLeft:SetFont(module.db.colsDefaults.fontName,parent.fontLeftSize,parent.fontLeftOutline and "OUTLINE") end
	isValidFont = self.textRight:SetFont(parent.fontRightName,parent.fontRightSize,parent.fontRightOutline and "OUTLINE")	if not isValidFont then self.textRight:SetFont(module.db.colsDefaults.fontName,parent.fontRightSize,parent.fontRightOutline and "OUTLINE") end
	isValidFont = self.textCenter:SetFont(parent.fontCenterName,parent.fontCenterSize,parent.fontCenterOutline and "OUTLINE")if not isValidFont then self.textCenter:SetFont(module.db.colsDefaults.fontName,parent.fontCenterSize,parent.fontCenterOutline and "OUTLINE") end
	isValidFont = self.textIcon:SetFont(parent.fontIconName,parent.fontIconSize,parent.fontIconOutline and "OUTLINE")	if not isValidFont then self.textIcon:SetFont(module.db.colsDefaults.fontName,parent.fontIconSize,parent.fontIconOutline and "OUTLINE") end
	
	local fontOffset = 0
	fontOffset = parent.fontLeftShadow and 1 or 0	self.textLeft:SetShadowOffset(1*fontOffset,-1*fontOffset)
	fontOffset = parent.fontRightShadow and 1 or 0	self.textRight:SetShadowOffset(1*fontOffset,-1*fontOffset)
	fontOffset = parent.fontCenterShadow and 1 or 0	self.textCenter:SetShadowOffset(1*fontOffset,-1*fontOffset)
	fontOffset = parent.fontIconShadow and 1 or 0	self.textIcon:SetShadowOffset(1*fontOffset,-1*fontOffset)
	
	self.iconTexture:SetDesaturated(nil)
	
	self:SetAlpha(1)
	
	self.cooldown:Hide()

	self.textIcon:SetText("")
	
	if parent.optionAnimation then
		if parent.optionStyleAnimation == 1 then
			self.anim:SetScript("OnLoop",BarAnimation_Reverse)
		else
			self.anim:SetScript("OnLoop",BarAnimation)
		end
	else
		self.anim:SetScript("OnLoop",BarAnimation_NoAnimation)
		self.spark:SetTexture("")
		self.statusbar:SetStatusBarTexture(0,0,0,0)
	end
	
	if parent.methodsIconTooltip then
		self.icon:SetScript("OnEnter",LineIconOnHover)
		self.icon:SetScript("OnLeave",GameTooltip_Hide)
	else
		self.icon:SetScript("OnEnter",nil)
		self.icon:SetScript("OnLeave",nil)	
	end
	
	if parent.methodsLineClick then
		self.clickFrame:SetScript("OnClick",LineIconOnClick)
		self.clickFrame:Show()
	else
		self.clickFrame:SetScript("OnClick",nil)
		self.clickFrame:Hide()	
	end
	
	local borderSize = parent.textureBorderSize
	if borderSize == 0 then
		self.border.top:Hide()
		self.border.bottom:Hide()
		self.border.left:Hide()
		self.border.right:Hide()
	else
		self.border.top:ClearAllPoints()
		self.border.bottom:ClearAllPoints()
		self.border.left:ClearAllPoints()
		self.border.right:ClearAllPoints()
		
		self.border.top:SetPoint("TOPLEFT",self,"TOPLEFT",-borderSize,borderSize)
		self.border.top:SetPoint("BOTTOMRIGHT",self,"TOPRIGHT",borderSize,0)
	
		self.border.bottom:SetPoint("BOTTOMLEFT",self,"BOTTOMLEFT",-borderSize,-borderSize)
		self.border.bottom:SetPoint("TOPRIGHT",self,"BOTTOMRIGHT",borderSize,0)
	
		self.border.left:SetPoint("TOPLEFT",self,"TOPLEFT",-borderSize,0)
		self.border.left:SetPoint("BOTTOMRIGHT",self,"BOTTOMLEFT",0,0)
	
		self.border.right:SetPoint("TOPLEFT",self,"TOPRIGHT",0,0)
		self.border.right:SetPoint("BOTTOMRIGHT",self,"BOTTOMRIGHT",borderSize,0)
	
		self.border.top:SetTexture(parent.textureBorderColorR,parent.textureBorderColorG,parent.textureBorderColorB,parent.textureBorderColorA)
		self.border.bottom:SetTexture(parent.textureBorderColorR,parent.textureBorderColorG,parent.textureBorderColorB,parent.textureBorderColorA)
		self.border.left:SetTexture(parent.textureBorderColorR,parent.textureBorderColorG,parent.textureBorderColorB,parent.textureBorderColorA)
		self.border.right:SetTexture(parent.textureBorderColorR,parent.textureBorderColorG,parent.textureBorderColorB,parent.textureBorderColorA)
	
		self.border.top:Show()
		self.border.bottom:Show()
		self.border.left:Show()
		self.border.right:Show()
	end
	
	if module.db.plugin and type(module.db.plugin.UpdateBarStyle)=="function" then
		module.db.plugin.UpdateBarStyle(self)
	end
end

local function CreateBar(parent)
	local self = CreateFrame("Frame",nil,parent)
	
	self.parent = parent
	
	local statusbar = CreateFrame("StatusBar", nil, self)
	statusbar:SetPoint("TOPRIGHT")
	statusbar:SetPoint("BOTTOMLEFT")
	self.statusbar = statusbar
	
	local spark = statusbar:CreateTexture(nil, "OVERLAY")
	spark:SetTexture("Interface\\CastingBar\\UI-CastingBar-Spark")
	spark:SetBlendMode("ADD")
	spark:SetPoint("CENTER",statusbar,"RIGHT", 0,0)
	spark:SetDrawLayer("BACKGROUND", 3)
	spark:SetAlpha(0.5)
	spark:Hide()
	self.spark = spark
	
	local anim = self:CreateAnimationGroup()
	anim:SetLooping("REPEAT")
	anim.c = 0
	anim.timer = anim:CreateAnimation()
	anim.timer:SetDuration(0.04)
	anim:SetScript("OnLoop",BarAnimation)
	anim.bar = self
	self.anim = anim
	
	local icon = CreateFrame("Frame",nil,self)
	icon:SetPoint("TOPLEFT", 0, 0)
	local iconTexture = icon:CreateTexture(nil, "BACKGROUND")
	iconTexture:SetAllPoints()
	self.icon = icon
	self.iconTexture = iconTexture
	
	local cooldown = CreateFrame("Cooldown", nil, icon, "CooldownFrameTemplate")
	cooldown:SetDrawEdge(false)
	--cooldown:SetAllPoints()
	cooldown:SetPoint("CENTER")
	self.cooldown = cooldown
	
	local background = self:CreateTexture(nil, "BACKGROUND",-7)
	background:SetAllPoints()
	self.background = background
	
	self.textLeft = ELib:Text(self.statusbar,nil,nil,"GameFontNormal"):Size(0,0):Point(1,0):Color()
	self.textRight = ELib:Text(self.statusbar,nil,nil,"GameFontNormal"):Size(40,0):Point("TOPRIGHT",1,0):Right():Color()
	self.textCenter = ELib:Text(self.statusbar,nil,nil,"GameFontNormal"):Size(0,0):Point(0,0):Center():Color()
	self.textIcon = ELib:Text(icon,nil,nil,"GameFontNormal"):Size(0,0):Point(0,0):Center():Bottom():Color()
	
	--[[
	self.textLeft = self.statusbar:CreateFontString(nil,"ARTWORK")
	self.textLeft:SetJustifyH("LEFT")
	self.textLeft:SetJustifyV("MIDDLE")
	self.textLeft:SetSize(0,0)
	self.textLeft:SetPoint("TOPLEFT",1,0)
	self.textLeft:SetFont(ExRT.F.defFont,12)
	self.textLeft:SetTextColor(1,1,1,1)
	
	self.textRight = self.statusbar:CreateFontString(nil,"ARTWORK")
	self.textRight:SetJustifyH("RIGHT")
	self.textRight:SetJustifyV("MIDDLE")
	self.textRight:SetSize(40,0)
	self.textRight:SetPoint("TOPRIGHT",1,0)
	self.textRight:SetFont(ExRT.F.defFont,12)
	self.textRight:SetTextColor(1,1,1,1)
	
	self.textCenter = self.statusbar:CreateFontString(nil,"ARTWORK")
	self.textCenter:SetJustifyH("CENTER")
	self.textCenter:SetJustifyV("MIDDLE")
	self.textCenter:SetSize(0,0)
	self.textCenter:SetPoint("TOPLEFT",1,0)
	self.textCenter:SetFont(ExRT.F.defFont,12)
	self.textCenter:SetTextColor(1,1,1,1)
	
	self.textIcon = icon:CreateFontString(nil,"ARTWORK")
	self.textIcon:SetJustifyH("CENTER")
	self.textIcon:SetJustifyV("BOTTOM")
	self.textIcon:SetSize(0,0)
	self.textIcon:SetPoint("TOPLEFT",1,0)
	self.textIcon:SetFont(ExRT.F.defFont,12)
	self.textIcon:SetTextColor(1,1,1,1)
	]]
	
	--6.1 multilinetext fix
	self.textLeft:SetMaxLines(1)
	self.textRight:SetMaxLines(1)
	self.textCenter:SetMaxLines(1)
	
	self.border = {}
	self.border.top = self:CreateTexture(nil, "BACKGROUND")
	self.border.bottom = self:CreateTexture(nil, "BACKGROUND")
	self.border.left = self:CreateTexture(nil, "BACKGROUND")
	self.border.right = self:CreateTexture(nil, "BACKGROUND")
	
	self.clickFrame = CreateFrame("Button",nil,self)
	self.clickFrame:SetAllPoints()
	self.clickFrame:Hide()
	
	self.Stop = StopBar
	self.Update = UpdateBar
	self.UpdateStyle = UpdateBarStyle
	self.UpdateText = BarUpdateText
	self.UpdateStatus = UpdateBarStatus
	self.CreateTitle = BarCreateTitle
	
	return self
end

for i=1,module.db.maxColumns do
	local columnFrame = CreateFrame("Frame",nil,module.frame)
	module.frame.colFrame[i] = columnFrame
	columnFrame:EnableMouse(false)
	columnFrame:SetMovable(false)
	columnFrame:RegisterForDrag("LeftButton")
	columnFrame:SetScript("OnDragStart", function(self) 
		if self:IsMovable() then 
			self:StartMoving() 
		end 
	end)
	columnFrame:SetScript("OnDragStop", function(self)
		self:StopMovingOrSizing()
		VExRT.ExCD2.colSet[i].posX = self:GetLeft()
		VExRT.ExCD2.colSet[i].posY = self:GetTop()
	end)	
	columnFrame.texture = columnFrame:CreateTexture(nil, "BACKGROUND")
	columnFrame.texture:SetTexture(0,0,0,0)
	columnFrame.texture:SetAllPoints()
	
	columnFrame.lockTexture = columnFrame:CreateTexture(nil, "BACKGROUND")
	columnFrame.lockTexture:SetTexture(0,0,0,0)
	columnFrame.lockTexture:SetAllPoints()

	columnFrame.lines = {}
	
	columnFrame.BlackList = {}
	
	module:RegisterHideOnPetBattle(columnFrame)
end

do
	local lastSaving = GetTime() - 15
	function SaveCDtoVar(overwrite)
		local currTime = GetTime()
		if ((currTime - lastSaving) < 30 and not overwrite) or module.db.testMode then 
			return 
		end
		wipe(VExRT.ExCD2.Save)
		for i=1,#_C do
			local unitSpellData = _C[i]
			if unitSpellData.lastUse + unitSpellData.cd - currTime > 0 then
				VExRT.ExCD2.Save[ (unitSpellData.fullName or "?")..(unitSpellData.db[1] or 0) ] = {unitSpellData.lastUse,unitSpellData.cd}
			else
				VExRT.ExCD2.Save[ (unitSpellData.fullName or "?")..(unitSpellData.db[1] or 0) ] = nil
			end	
		end
	end
end

local function AfterCombatResetFunction(isArena)
	for i=1,#_C do
		local unitSpellData = _C[i]
		local uSpecID = module.db.specInDBase[globalGUIDs[unitSpellData.fullName] or 0]
		if not unitSpellData.db[uSpecID] and unitSpellData.db[3] then
			uSpecID = 3
		end

		if (unitSpellData.cd > 0 and (module.db.spell_afterCombatReset[unitSpellData.db[1]] or (unitSpellData.db[uSpecID] and unitSpellData.db[uSpecID][2] >= (isArena and 0 or 180) or unitSpellData.cd >= (isArena and 0 or 180)))) and (not module.db.spell_afterCombatNotReset[unitSpellData.db[1]] or isArena) then
			unitSpellData.lastUse = 0 
			unitSpellData.charge = nil 
			
			if unitSpellData.bar and unitSpellData.bar.data == unitSpellData then
				unitSpellData.bar:UpdateStatus()
			end
		end
	end
	SaveCDtoVar(true)
end

local function TestMode(h)
	if not h then
		for i=1,#_C do
			local data = _C[i]
			local uSpecID = module.db.specInDBase[VExRT.ExCD2.gnGUIDs[data.fullName] or 0]
			if not data.db[uSpecID] then
				uSpecID = 3
			end
			if data.db[uSpecID] then
				if fastrandom(0,100) < 80 then
					data.cd = data.db[uSpecID][2]
					data.lastUse = GetTime() - fastrandom(0,data.db[uSpecID][2]) - fastrandom()
					data.duration = data.db[uSpecID][3]
				end
			end
		end
	else
		for i=1,#_C do
			local data = _C[i]
			data.lastUse = 0
			data.duration = 0
		end
	end
	UpdateAllData()
	SortAllData()
end


do
	local inColsCount = {}
	
	--Upvaules
	local maxColumns = _db.maxColumns
	local maxLinesInCol = _db.maxLinesInCol
	local specInDBase = _db.specInDBase
	local spell_isTalent = _db.spell_isTalent
	local session_gGUIDs = _db.session_gGUIDs
	local spell_isPetAbility = _db.spell_isPetAbility
	local session_Pets = _db.session_Pets
	local petsAbilities = _db.petsAbilities
	local spell_talentReplaceOther = _db.spell_talentReplaceOther
	local spell_charge_fix = _db.spell_charge_fix
	local def_col = _db.def_col
	local columnsTable = _mainFrame.colFrame
	
	local playerName = ExRT.SDB.charName
	
	local saveDataTimer = 0
	local lastBattleResChargesStatus = nil
	
	local function sort_a(a,b) return (a.sort or 0) < (b.sort or 0) end
	local function sort_b(a,b) if a.sorting == b.sorting then return (a.sort or 0) < (b.sort or 0) else return (a.sorting or 0) < (b.sorting or 0) end end
	--local function sort_b(a,b) return (a.sorting or 0) < (b.sorting or 0) end
	local function sort_ar(a,b) return (a.sort or 0) > (b.sort or 0) end
	local function sort_br(a,b) if a.sorting == b.sorting then return (a.sort or 0) > (b.sort or 0) else return (a.sorting or 0) > (b.sorting or 0) end end
	
	function SortAllData()
		local SortByAvailability = VExRT.ExCD2.SortByAvailability
		if SortByAvailability then
			local currTime = GetTime()
			local SortByAvailabilityActiveToTop = VExRT.ExCD2.SortByAvailabilityActiveToTop
		  	for i=1,#_C do
		  		local data = _C[i]
				local cd = data.lastUse + data.cd - currTime
				
				local charge = data.charge
				if data.isCharge and charge then
					if charge <= currTime and (charge+data.cd) > currTime then
						cd = -1
					elseif charge > currTime then
						cd = charge - currTime
					end
				end
				
				if data.disabled then
					cd = cd > 0 and cd or 49999
				end
				if cd > 0 then
					cd = cd + 50000
				end
				
				local dur = 0
				if SortByAvailabilityActiveToTop then
					dur = data.lastUse + data.duration - currTime
					if dur < 0 then
						dur = 0
					end
				end
				data.sorting = dur > 0 and dur or cd > 0 and cd or 0
				
				local columnFrame = columnsTable[data.column]
				if columnFrame.methodsNewSpellNewLine then
					data.sorting = (data.sort2 or data.db[1]) * 100000 + data.sorting
				end
		  	end
		  	if not VExRT.ExCD2.ReverseSorting then
		  		sort(_C,sort_b)
		  	else
		  		sort(_C,sort_br)
		  	end
		else
		  	if not VExRT.ExCD2.ReverseSorting then
		  		sort(_C,sort_a)
		  	else
		  		sort(_C,sort_ar)
		  	end
		end
	end
	
	function UpdateAllData()
		--print('UpdateAllData',GetTime())
		local isTestMode = _db.testMode
		local CDECol = VExRT.ExCD2.CDECol
		local currTime = GetTime()
		for i=1,#_C do
			local data = _C[i]
			local db = data.db
			local name = data.fullName
			local spellID = db[1]
			
			local specID = globalGUIDs[name] or 0
			local unitSpecID = specInDBase[specID] or 3
			
			if isTestMode or (VExRT_CDE[spellID] and 
			(db[unitSpecID] or (not db[unitSpecID] and db[3])) and 
			(not spell_isTalent[spellID] or session_gGUIDs[name][spellID]) and 
			(not spell_isPetAbility[spellID] or session_Pets[name] == spell_isPetAbility[spellID] or (session_Pets[name] and petsAbilities[ session_Pets[name] ] and petsAbilities[ session_Pets[name] ][1] == spell_isPetAbility[spellID])) and
			(not spell_talentReplaceOther[spellID] or not session_gGUIDs[name][ spell_talentReplaceOther[spellID] ]) and
			(not data.specialCheck or data.specialCheck())
			) then 
				data.vis = true
				
				local col = 1
				if db[unitSpecID] then
					col = VExRT.ExCD2.CDECol[db[unitSpecID][1]..";"..(unitSpecID-2)] or def_col[db[unitSpecID][1]..";"..(unitSpecID-2)] or 1
				elseif db[3] then
					col = VExRT.ExCD2.CDECol[db[3][1]..";1"] or def_col[db[3][1]..";1"] or 1
				end
				data.column = col
				
				local isCharge = spell_charge_fix[ data.db[1] ]
				if isCharge then
					if session_gGUIDs[data.fullName][isCharge] then
						data.isCharge = true
						isCharge = true
					else
						data.isCharge = nil
						isCharge = nil
					end
				end
				
				local columnFrame = columnsTable[col]
				
				if columnFrame.optionShownOnCD and not ((isCharge and data.charge and data.charge > currTime) or (not isCharge and (data.lastUse + data.cd) > currTime)) then
					data.vis = nil
				end
				if columnFrame.methodsHideOwnSpells and data.fullName == playerName then
					data.vis = nil
				end
				
				local whiteList = columnFrame.WhiteList
				if whiteList then
					if not whiteList[data.loweredName] then
						data.vis = nil
					end
				else
					local blackList = columnFrame.BlackList
					if blackList[data.loweredName] or (blackList[spellID] and blackList[spellID][data.loweredName]) then
						data.vis = nil
					end
				end
				
				local prevDisabledStatus = data.disabled
				local isDead = status_UnitIsDead[ name ]
				local isOffline = status_UnitIsDisconnected[ name ]
				if isDead or isOffline then
					data.disabled = isOffline and 2 or 1
				else
					data.disabled = nil
				end
				
				local prevOutOfRange = data.outofrange
				if status_UnitIsOutOfRange[ name ] then
					data.outofrange = true
				else
					data.outofrange = nil
				end
				
				local bar = data.bar
				if bar and bar.data == data and (data.disabled ~= prevDisabledStatus or data.outofrange ~= prevOutOfRange) then
					data.bar:UpdateStatus()
				end

			else
				data.vis = nil
			end
		end
	end
	
	local statusTimer1,statusTimer2 = 0,0
	
	function module:timer(elapsed)
		local forceUpdateAllData,forceSortAllData = false,false

		if not _db.isEncounter and IsEncounterInProgress() then
			_db.isEncounter = true
			local _,_,difficulty = GetInstanceInfo()
			if difficulty == 14 or difficulty == 15 or difficulty == 16 or difficulty == 17 or difficulty == 7 then
				_db.isResurectDisabled = true
			end
		elseif _db.isEncounter and not IsEncounterInProgress() then
			_db.isEncounter = nil
			_db.isResurectDisabled = nil
			if GetDifficultyForCooldownReset() then
				AfterCombatResetFunction()
				forceUpdateAllData = true
				forceSortAllData = true
			end
		end
		
		
		---------> Check status
		statusTimer2 = statusTimer2 + elapsed
		if statusTimer2 > 0.25 then
			statusTimer2 = 0
			statusTimer1 = statusTimer1 + 1
			local doOtherChecks = statusTimer1 > 1
			for i=1,#status_UnitsToCheck do
				local unit = status_UnitsToCheck[i]
				local inRange,isRange = UnitInRange(unit)
				local outOfRange = isRange and not inRange
				if status_UnitIsOutOfRange[ unit ] ~= outOfRange then
					forceUpdateAllData = true
				end
				status_UnitIsOutOfRange[ unit ] = outOfRange
				if doOtherChecks then
					local isDead = UnitIsDeadOrGhost(unit)
					if isDead ~= status_UnitIsDead[ unit ] then
						forceUpdateAllData = true
						forceSortAllData = true
					end
					status_UnitIsDead[ unit ] = isDead
					
					local isOffline = not UnitIsConnected(unit)
					if isOffline ~= status_UnitIsDisconnected[ unit ] then
						forceUpdateAllData = true
						forceSortAllData = true
					end
					status_UnitIsDisconnected[ unit ] = not UnitIsConnected(unit)
				end
			end
			if doOtherChecks then
				statusTimer1 = 0
				
				local charges,_,started,duration = GetSpellCharges(20484)
				if charges ~= lastBattleResChargesStatus then
					local charge = nil
					if charges then
						if charges > 0 then
							charge = started
							started = 0
						end
					else
						started = 0
						duration = 0
						charge = nil
					end
					for i=1,#_C do
						local data = _C[i]
						if module.db.spell_battleRes[ data.db[1] ] then
							data.lastUse = started
							data.cd = duration
							data.charge = charge

							local bar = data.bar
							if bar and bar.data == data then
								bar:UpdateStatus()
							end
						end
					end
					forceUpdateAllData = true
					forceSortAllData = true
					
					if charges and lastBattleResChargesStatus and charges < lastBattleResChargesStatus then		--Add resurrect to history
						module.db.historyUsage[#module.db.historyUsage + 1] = {time(),20484,"*",GetEncounterTime()}
					end
				end
				lastBattleResChargesStatus = charges
			end
		end
		if forceUpdateAllData then
			UpdateAllData()
		end
		if forceSortAllData then
			SortAllData()
		end
				
		for i=1,maxColumns do 
			inColsCount[i] = 0 
			columnsTable[i].lastSpell = nil
		end
		for i=1,#_C do
			local data = _C[i]
			if data.vis then
				local col = data.column
				local numberInCol = inColsCount[col] + 1
				local spellID = data.db[1]
				
				local barParent = columnsTable[col]
				if barParent.methodsNewSpellNewLine and barParent.lastSpell ~= spellID then
					local fix = 0
					for j=numberInCol,maxLinesInCol do
						local bar_now = barParent.lines[numberInCol + fix]
						if bar_now then
							if bar_now.IsNewLine then
								break
							else
								if bar_now.data then
									bar_now.data = nil
									bar_now:Update()
								end
								fix = fix + 1
							end
						end
					end
					numberInCol = numberInCol + fix
				end
				if barParent.optionIconTitles and barParent.lastSpell ~= spellID then
					local bar = barParent.lines[numberInCol]
					if bar and (bar.data ~= data or not bar.isTitle) then
						bar.data = data
						bar:CreateTitle()
					end
					numberInCol = numberInCol + 1
				end
				if barParent.methodsNewSpellNewLine and barParent.optionIconTitles and barParent.frameColumns > 1 and barParent.lastSpell == spellID then
					local bar_now = barParent.lines[numberInCol]
					if bar_now and bar_now.IsNewLine then
						if bar_now.data then
							bar_now.data = nil
							bar_now:Update()
						end
						numberInCol = numberInCol + 1
					end
				end

				barParent.lastSpell = spellID
				
				inColsCount[col] = numberInCol
				local bar = barParent.lines[numberInCol]
				if bar and bar.data ~= data then
					bar.data = data
					
					data.bar = bar
				
					bar:Update()
					bar:UpdateStatus()
				end
			end
		end
		for i=1,maxColumns do
			local col = columnsTable[i]
			local y = col.optionLinesMax
			if inColsCount[i] > y then
				inColsCount[i] = y
			end
			for j=(inColsCount[i]+1),maxLinesInCol do
				local bar = col.lines[j]
				if bar then
					bar.data = nil
					bar:Update()
				end
			end
		end
		
		saveDataTimer = saveDataTimer + elapsed
		if saveDataTimer > 2 then
			saveDataTimer = 0
			SaveCDtoVar()
		end
	end
end

local function GetNumGroupMembersFix() 
	local n = GetNumGroupMembers() or 0
	if module.db.testMode then
		return 20
	elseif n == 0 and VExRT.ExCD2.NoRaid then 
		return 1
	else
		return n
	end
end

local function GetRaidRosterInfoFix(j) 
	local name, rank, subgroup, level, class, classFileName, zone, online, isDead, role, isML = GetRaidRosterInfo(j)
	if j == 1 and not name and VExRT.ExCD2.NoRaid then
		name = UnitName("player")
		class,classFileName = UnitClass("player")
		local _,race = UnitRace("player")
		level = UnitLevel("player")
		isDead = UnitIsDeadOrGhost("player")
		return name,1,classFileName,level,race,true,isDead
	elseif not module.db.testMode then
		local _,race = UnitRace(name or "?")
		return name,subgroup,classFileName,level,race,online,isDead
	elseif module.db.testMode then
		if name then
			local _,race = UnitRace(name)
			return name,subgroup,classFileName,level,race,online,isDead
		end
		local i = math.random(1,11)

		local namesList = {}
		for unitName, specID in pairs(VExRT.ExCD2.gnGUIDs) do
			namesList[#namesList+1] = {unitName}
			for className, classSpecs in pairs(module.db.specByClass) do
				for spec_i=1,#classSpecs do
					if classSpecs[spec_i] == specID then
						namesList[#namesList][2] = className
					end
				end
			end
		end
		if #namesList == 0 or #namesList < 25 then
			name = L.classLocalizate[module.db.classNames[i]]..tostring(j)
			classFileName = module.db.classNames[i]
		else
			i = math.random(1,#namesList)
			name = namesList[i][1]
			classFileName = namesList[i][2]
		end

		return name,1,classFileName,100,nil,true,false
	end
end

local function UpdateLegendaryRingState()
	isLegendaryRingInRaid_DD = nil
	isLegendaryRingInRaid_Tank = nil
	isLegendaryRingInRaid_Heal = nil
	
	local session_gGUIDs = module.db.session_gGUIDs
	
	local roster = {}
	for i=1,#_C do
		roster[ _C[i].name ] = true
	end
	for name,_ in pairs(roster) do
		if session_gGUIDs[name][187614] or session_gGUIDs[name][187615] or session_gGUIDs[name][187611] then
			isLegendaryRingInRaid_DD = true
		elseif session_gGUIDs[name][187613] then
			isLegendaryRingInRaid_Tank = true
		elseif session_gGUIDs[name][187612] then
			isLegendaryRingInRaid_Heal = true
		end		
	end
end

function RaidResurrectSpecialCheck()
	local _,_,difficulty = GetInstanceInfo()
	if difficulty == 14 or difficulty == 15 or difficulty == 16 or difficulty == 7 or difficulty == 17 then
		return true
	end
end
function RaidResurrectSpecialText()
	local charges, maxCharges, started, duration = GetSpellCharges(20484)
	if (charges or 0) > 1 then
		return " ("..charges..")"
	end
end
function RaidResurrectSpecialStatus()
	local charges, maxCharges, started, duration = GetSpellCharges(20484)
	if charges then
		if charges > 0 then
			return false,started,duration
		else
			return true,started,duration
		end
	end
end

local LegendaryRingSpecialCheck_DD,LegendaryRingSpecialCheck_Tank,LegendaryRingSpecialCheck_Heal

function LegendaryRingSpecialCheck_DD() return isLegendaryRingInRaid_DD end
function LegendaryRingSpecialCheck_Tank() return isLegendaryRingInRaid_Tank end
function LegendaryRingSpecialCheck_Heal() return isLegendaryRingInRaid_Heal end

local function UpdateRoster()
	wipe(status_UnitsToCheck)
	wipe(status_UnitIsDead)
	wipe(status_UnitIsDisconnected)
	wipe(status_UnitIsOutOfRange)

	local n = GetNumGroupMembersFix()
	if n > 0 then
		local priorCounter = 0
		local priorNamesToNumber = {}
		if not module.db.testMode then
			for j=1,n do
				local name = GetRaidRosterInfoFix(j)
				if name then
					priorNamesToNumber[#priorNamesToNumber + 1] = name
				end
			end
			sort(priorNamesToNumber)
		end
		
		local classColorsTable = type(CUSTOM_CLASS_COLORS)=="table" and CUSTOM_CLASS_COLORS or RAID_CLASS_COLORS
		
		for i=1,#_C do _C[i].sort = nil end
		local gMax = GetRaidDiffMaxGroup()
		local isInRaid = IsInRaid()
		for j=1,n do
			local name,subgroup,class,level,race,online,isDead = GetRaidRosterInfoFix(j)
			if name and subgroup <= gMax then
				for i,spellData in ipairs(module.db.spellDB) do
					local SpellID = spellData[1]
					local AddThisSpell = true
					if level < 100 then
						local spellLevel = GetSpellLevelLearned(SpellID)
						if level < (spellLevel or 0) then
							AddThisSpell = false
						end
					end
					if module.db.spell_isRacial[ SpellID ] and race ~= module.db.spell_isRacial[ SpellID ] then
						AddThisSpell = false	
					end
				
					if AddThisSpell and (spellData[2] == class or spellData[2] == "ALL") then
						if not ExRT.F.table_find(status_UnitsToCheck,name) then
							status_UnitsToCheck[#status_UnitsToCheck + 1] = name
							
							status_UnitIsDead[ name ] = isDead
							status_UnitIsDisconnected[ name ] = not online
							
							local inRange,isRange = UnitInRange(name)
							status_UnitIsOutOfRange[ name ] = isRange and not inRange
						end 
						if SpellID == 1719 then
							module:AddCLEUSpellDamage()
						end
					
						local alreadyInCds = nil
						priorCounter = priorCounter + 1
						
						local spellColumn = 1
						local _specID = globalGUIDs[name] or 0
						local uSpecID = _db.specInDBase[_specID] or 3
						if spellData[uSpecID] then
							spellColumn = VExRT.ExCD2.CDECol[spellData[uSpecID][1]..";"..(uSpecID-2)] or _db.def_col[spellData[uSpecID][1]..";"..(uSpecID-2)] or 1
						elseif spellData[3] then
							spellColumn = VExRT.ExCD2.CDECol[spellData[3][1]..";1"] or _db.def_col[spellData[3][1]..";1"] or 1
						end
						local getSpellColumn = _mainFrame.colFrame[spellColumn]
						local prior = nil
						--[[
							1: 00AABBBBBBCCDDDD
							2: 00AACCBBBBBBDDDD
							3: AAEEBBBBBBCCDDDD
							4: AAEECCBBBBBBDDDD
							5: 00CCAABBBBBBDDDD
							6: EEAACCBBBBBBDDDD
							
							A - priority
							B - spell ID
							C - name
							D - priority counter
							E - classID
						]]
						if not getSpellColumn or getSpellColumn.methodsSortingRules == 1 then
							prior = (VExRT.ExCD2.Priority[SpellID] or 15) * 1000000000000 + (SpellID or 0) * 1000000 + (ExRT.F.table_find(priorNamesToNumber,name) or 0) * 10000 + priorCounter
						elseif getSpellColumn.methodsSortingRules == 2 then
							prior = (VExRT.ExCD2.Priority[SpellID] or 15) * 1000000000000 + (ExRT.F.table_find(priorNamesToNumber,name) or 0) * 10000000000 + (SpellID or 0) * 10000 + priorCounter
						elseif getSpellColumn.methodsSortingRules == 3 then
							prior = (VExRT.ExCD2.Priority[SpellID] or 15) * 100000000000000 + (ExRT.F.table_find(module.db.classNames,class) or 0) * 1000000000000 + (SpellID or 0) * 1000000 + (ExRT.F.table_find(priorNamesToNumber,name) or 0) * 10000 + priorCounter
						elseif getSpellColumn.methodsSortingRules == 4 then
							prior = (VExRT.ExCD2.Priority[SpellID] or 15) * 100000000000000 + (ExRT.F.table_find(module.db.classNames,class) or 0) * 1000000000000 + (ExRT.F.table_find(priorNamesToNumber,name) or 0) * 10000000000 + (SpellID or 0) * 10000 + priorCounter
						elseif getSpellColumn.methodsSortingRules == 5 then
							prior = (ExRT.F.table_find(priorNamesToNumber,name) or 0) * 1000000000000 + (VExRT.ExCD2.Priority[SpellID] or 15) * 10000000000 + (SpellID or 0) * 10000 + priorCounter
						elseif getSpellColumn.methodsSortingRules == 6 then
							prior = (ExRT.F.table_find(module.db.classNames,class) or 0) * 100000000000000 + (VExRT.ExCD2.Priority[SpellID] or 15) * 1000000000000 + (ExRT.F.table_find(priorNamesToNumber,name) or 0) * 10000000000 + (SpellID or 0) * 10000 + priorCounter
						end
						local secondPrior = (VExRT.ExCD2.Priority[SpellID] or 15) * 1000000 + (SpellID or 0)	--used in columns with option 'new spell - new line'
						
						local sName = format("%s%d",name or "?",SpellID or 0)
						local lastUse,nowCd = 0,0
						if VExRT.ExCD2.Save[sName] and NumberInRange(VExRT.ExCD2.Save[sName][1] + VExRT.ExCD2.Save[sName][2] - GetTime(),0,2000,false,true) then
							lastUse,nowCd = VExRT.ExCD2.Save[sName][1],VExRT.ExCD2.Save[sName][2]
						end
						
						local spellName,_,spellTexture = GetSpellInfo(SpellID)
						spellTexture = spellTexture or "Interface\\Icons\\INV_MISC_QUESTIONMARK"
						spellName = spellName or "unk"
						local shownName = DelUnitNameServer(name)
						
						if module.db.differentIcons[SpellID] then
							spellTexture = module.db.differentIcons[SpellID]
						end
						
						for l=3,7 do
							if spellData[l] then
								local h = module.db.cdsNav[name][spellData[l][1]]
								if h then
									h.db = spellData
									if lastUse ~= 0 and nowCd ~= 0 and h.lastUse == 0 and h.cd == 0 then
										h.cd = nowCd
										h.lastUse = lastUse
									end
									h.sort = prior
									h.sort2 = secondPrior
									h.spellName = spellName
									h.icon = spellTexture
									h.column = spellColumn
									
									alreadyInCds = true
								end
							end
						end

						if not alreadyInCds then
							_C [#_C + 1] = {
								name = shownName,
								fullName = name,
								loweredName = shownName:lower(),
								icon = spellTexture,
								spellName = spellName,
								db = spellData,
								lastUse = lastUse,
								cd = nowCd,
								duration = 0,
								classColor = classColorsTable[class] or module.db.notAClass,
								sort = prior,
								sort2 = secondPrior,
								column = spellColumn,
							}
						end
					end
				end
				module.db.session_gGUIDs[name] = 1
				if isInRaid then
					module.main:UNIT_PET("raid"..j)
				end
			end
		end
		
		--WOD Raid resurrect
		do
			local findResSpell = ExRT.F.table_find(module.db.spellDB,161642,1)
			if findResSpell then
				local spellData = module.db.spellDB[findResSpell]
				local h = module.db.cdsNav["*"][spellData[3][1]]
				local prior = 0
				
				priorCounter = priorCounter + 1
				
				local spellColumn = VExRT.ExCD2.CDECol["161642;1"] or _db.def_col["161642;1"] or 1
				local getSpellColumn = _mainFrame.colFrame[spellColumn]
				if not getSpellColumn or getSpellColumn.methodsSortingRules == 1 then
					prior = (VExRT.ExCD2.Priority[161642] or 15) * 1000000000000 + 161642 * 1000000 + priorCounter
				elseif getSpellColumn.methodsSortingRules == 2 then
					prior = (VExRT.ExCD2.Priority[161642] or 15) * 1000000000000 + 161642 * 10000 + priorCounter
				elseif getSpellColumn.methodsSortingRules == 3 then
					prior = (VExRT.ExCD2.Priority[161642] or 15) * 100000000000000 + 161642 * 1000000 + priorCounter
				elseif getSpellColumn.methodsSortingRules == 4 then
					prior = (VExRT.ExCD2.Priority[161642] or 15) * 100000000000000 + 161642 * 10000 + priorCounter
				elseif getSpellColumn.methodsSortingRules == 5 then
					prior = (VExRT.ExCD2.Priority[161642] or 15) * 10000000000 + 161642 * 10000 + priorCounter
				elseif getSpellColumn.methodsSortingRules == 6 then
					prior = (VExRT.ExCD2.Priority[161642] or 15) * 1000000000000 + 161642 * 10000 + priorCounter
				end
				local secondPrior = (VExRT.ExCD2.Priority[161642] or 15) * 1000000 + (161642 or 0)
				
				if not h then
					local spellName,_,spellTexture = GetSpellInfo(spellData[1])
					_C [#_C + 1] = {
						name = L.cd2Resurrect,
						fullName = "*",
						loweredName = "*",
						icon = spellTexture,
						spellName = spellName or "unk",
						db = spellData,
						lastUse = 0,
						cd = 0,
						duration = 0,
						classColor = module.db.notAClass,
						sort = prior,
						sort2 = secondPrior,
						column = spellColumn,
						specialCheck = RaidResurrectSpecialCheck,
						specialAddText = RaidResurrectSpecialText,
						specialStatus = RaidResurrectSpecialStatus,
					}
				else
					h.sort = prior
					h.sort2 = secondPrior
					h.column = spellColumn
				end
				module.db.session_gGUIDs["*"] = 1
			end
		end
		--WOD Legendary Ring
		do
			local RingSpellID = 187614
			local findRingSpell = ExRT.F.table_find(module.db.spellDB,RingSpellID,1)
			if findRingSpell then
				local spellData = module.db.spellDB[findRingSpell]
				local h = module.db.cdsNav["*"][RingSpellID]
				local prior = 0
				priorCounter = priorCounter + 1
				local spellColumn = VExRT.ExCD2.CDECol[RingSpellID..";1"] or _db.def_col[RingSpellID..";1"] or 1
				local getSpellColumn = _mainFrame.colFrame[spellColumn]
				if not getSpellColumn or getSpellColumn.methodsSortingRules == 1 then
					prior = (VExRT.ExCD2.Priority[RingSpellID] or 15) * 1000000000000 + RingSpellID * 1000000 + priorCounter
				elseif getSpellColumn.methodsSortingRules == 2 then
					prior = (VExRT.ExCD2.Priority[RingSpellID] or 15) * 1000000000000 + RingSpellID * 10000 + priorCounter
				elseif getSpellColumn.methodsSortingRules == 3 then
					prior = (VExRT.ExCD2.Priority[RingSpellID] or 15) * 100000000000000 + RingSpellID * 1000000 + priorCounter
				elseif getSpellColumn.methodsSortingRules == 4 then
					prior = (VExRT.ExCD2.Priority[RingSpellID] or 15) * 100000000000000 + RingSpellID * 10000 + priorCounter
				elseif getSpellColumn.methodsSortingRules == 5 then
					prior = (VExRT.ExCD2.Priority[RingSpellID] or 15) * 10000000000 + RingSpellID * 10000 + priorCounter
				elseif getSpellColumn.methodsSortingRules == 6 then
					prior = (VExRT.ExCD2.Priority[RingSpellID] or 15) * 1000000000000 + RingSpellID * 10000 + priorCounter
				end
				local secondPrior = (VExRT.ExCD2.Priority[RingSpellID] or 15) * 1000000 + (RingSpellID or 0)
				
				if not h then
					local spellName,_,spellTexture = GetSpellInfo(RingSpellID)
					if module.db.differentIcons[RingSpellID] then
						spellTexture = module.db.differentIcons[RingSpellID]
					end
					_C [#_C + 1] = {
						name = "Legendary DD",
						fullName = "*",
						loweredName = "*",
						icon = spellTexture,
						spellName = spellName or "unk",
						db = spellData,
						lastUse = 0,
						cd = 0,
						duration = 0,
						classColor = module.db.notAClass,
						sort = prior,
						sort2 = secondPrior,
						column = spellColumn,
						specialCheck = LegendaryRingSpecialCheck_DD,
					}
				else
					h.sort = prior
					h.sort2 = secondPrior
					h.column = spellColumn
				end
				module.db.session_gGUIDs["*"] = 1
			end
			
			local RingSpellID = 187613
			local findRingSpell = ExRT.F.table_find(module.db.spellDB,RingSpellID,1)
			if findRingSpell then
				local spellData = module.db.spellDB[findRingSpell]
				local h = module.db.cdsNav["*"][RingSpellID]
				local prior = 0
				priorCounter = priorCounter + 1
				local spellColumn = VExRT.ExCD2.CDECol[RingSpellID..";1"] or _db.def_col[RingSpellID..";1"] or 1
				local getSpellColumn = _mainFrame.colFrame[spellColumn]
				if not getSpellColumn or getSpellColumn.methodsSortingRules == 1 then
					prior = (VExRT.ExCD2.Priority[RingSpellID] or 15) * 1000000000000 + RingSpellID * 1000000 + priorCounter
				elseif getSpellColumn.methodsSortingRules == 2 then
					prior = (VExRT.ExCD2.Priority[RingSpellID] or 15) * 1000000000000 + RingSpellID * 10000 + priorCounter
				elseif getSpellColumn.methodsSortingRules == 3 then
					prior = (VExRT.ExCD2.Priority[RingSpellID] or 15) * 100000000000000 + RingSpellID * 1000000 + priorCounter
				elseif getSpellColumn.methodsSortingRules == 4 then
					prior = (VExRT.ExCD2.Priority[RingSpellID] or 15) * 100000000000000 + RingSpellID * 10000 + priorCounter
				elseif getSpellColumn.methodsSortingRules == 5 then
					prior = (VExRT.ExCD2.Priority[RingSpellID] or 15) * 10000000000 + RingSpellID * 10000 + priorCounter
				elseif getSpellColumn.methodsSortingRules == 6 then
					prior = (VExRT.ExCD2.Priority[RingSpellID] or 15) * 1000000000000 + RingSpellID * 10000 + priorCounter
				end
				local secondPrior = (VExRT.ExCD2.Priority[RingSpellID] or 15) * 1000000 + (RingSpellID or 0)
				
				if not h then
					local spellName,_,spellTexture = GetSpellInfo(RingSpellID)
					if module.db.differentIcons[RingSpellID] then
						spellTexture = module.db.differentIcons[RingSpellID]
					end
					_C [#_C + 1] = {
						name = "Legendary Tank",
						fullName = "*",
						loweredName = "*",
						icon = spellTexture,
						spellName = spellName or "unk",
						db = spellData,
						lastUse = 0,
						cd = 0,
						duration = 0,
						classColor = module.db.notAClass,
						sort = prior,
						sort2 = secondPrior,
						column = spellColumn,
						specialCheck = LegendaryRingSpecialCheck_Tank,
					}
				else
					h.sort = prior
					h.sort2 = secondPrior
					h.column = spellColumn
				end
				module.db.session_gGUIDs["*"] = 1
			end
			
			local RingSpellID = 187612
			local findRingSpell = ExRT.F.table_find(module.db.spellDB,RingSpellID,1)
			if findRingSpell then
				local spellData = module.db.spellDB[findRingSpell]
				local h = module.db.cdsNav["*"][RingSpellID]
				local prior = 0
				priorCounter = priorCounter + 1
				local spellColumn = VExRT.ExCD2.CDECol[RingSpellID..";1"] or _db.def_col[RingSpellID..";1"] or 1
				local getSpellColumn = _mainFrame.colFrame[spellColumn]
				if not getSpellColumn or getSpellColumn.methodsSortingRules == 1 then
					prior = (VExRT.ExCD2.Priority[RingSpellID] or 15) * 1000000000000 + RingSpellID * 1000000 + priorCounter
				elseif getSpellColumn.methodsSortingRules == 2 then
					prior = (VExRT.ExCD2.Priority[RingSpellID] or 15) * 1000000000000 + RingSpellID * 10000 + priorCounter
				elseif getSpellColumn.methodsSortingRules == 3 then
					prior = (VExRT.ExCD2.Priority[RingSpellID] or 15) * 100000000000000 + RingSpellID * 1000000 + priorCounter
				elseif getSpellColumn.methodsSortingRules == 4 then
					prior = (VExRT.ExCD2.Priority[RingSpellID] or 15) * 100000000000000 + RingSpellID * 10000 + priorCounter
				elseif getSpellColumn.methodsSortingRules == 5 then
					prior = (VExRT.ExCD2.Priority[RingSpellID] or 15) * 10000000000 + RingSpellID * 10000 + priorCounter
				elseif getSpellColumn.methodsSortingRules == 6 then
					prior = (VExRT.ExCD2.Priority[RingSpellID] or 15) * 1000000000000 + RingSpellID * 10000 + priorCounter
				end
				local secondPrior = (VExRT.ExCD2.Priority[RingSpellID] or 15) * 1000000 + (RingSpellID or 0)
				
				if not h then
					local spellName,_,spellTexture = GetSpellInfo(RingSpellID)
					if module.db.differentIcons[RingSpellID] then
						spellTexture = module.db.differentIcons[RingSpellID]
					end
					_C [#_C + 1] = {
						name = "Legendary Heal",
						fullName = "*",
						loweredName = "*",
						icon = spellTexture,
						spellName = spellName or "unk",
						db = spellData,
						lastUse = 0,
						cd = 0,
						duration = 0,
						classColor = module.db.notAClass,
						sort = prior,
						sort2 = secondPrior,
						column = spellColumn,
						specialCheck = LegendaryRingSpecialCheck_Heal,
					}
				else
					h.sort = prior
					h.sort2 = secondPrior
					h.column = spellColumn
				end
				module.db.session_gGUIDs["*"] = 1
			end
		end
		
		
		cdsNav_wipe()

		local pluginFunc = module.db.plugin and type(module.db.plugin.UpdateRoster)=="function" and module.db.plugin.UpdateRoster

		local j = 0
		for i=1,#_C do
			j = j + 1
			local line = _C[j]
			if not line then
				break
			elseif not line.sort then
				tremove(_C,j)
				j = j - 1
			else
				for l=3,7 do 
					if line.db[l] then
						cdsNav_set(line.fullName,line.db[l][1],line)
					end 
				end
				if pluginFunc then
					pluginFunc(line)
				end
			end
		end
	else
		wipe(_C)
		cdsNav_wipe()
	end
	if module.db.testMode then 
		TestMode() 
		
		local offline = status_UnitsToCheck[fastrandom(1,#status_UnitsToCheck)]
		local dead = status_UnitsToCheck[fastrandom(1,#status_UnitsToCheck)]
		
		status_UnitIsDead[dead] = true
		status_UnitIsDisconnected[offline] = true
		
		for j=#status_UnitsToCheck,1,-1 do
			if not UnitName(status_UnitsToCheck[j]) then
				tremove(status_UnitsToCheck, j)
			end
		end
	end
	UpdateLegendaryRingState()
	UpdateAllData()
	SortAllData()
end

do
	local function DispellSchedule(data)
		if not module.db.spell_dispellsFix[ data.fullName ] then
			data.cd = 0
		end
		module.db.spell_dispellsFix[ data.fullName ] = nil
	end
	function CLEUstartCD(i)
		local currTime = GetTime()
		local data = nil
		if type(i) == "table" then
			data = i
		else
			data = _C[i]
		end
		local fullName = data.fullName
		
		local uSpecID = module.db.specInDBase[globalGUIDs[fullName] or 0]
		if not data.db[uSpecID] and not data.db[3] then
			return
		elseif not data.db[uSpecID] then
			uSpecID = 3
		end
		local spellID = data.db[uSpecID][1]
		--WOD Battle Res
		do
			if _db.spell_battleRes[spellID] and _db.isResurectDisabled then
				return
			end
		end
		
		data.cd = data.db[uSpecID][2]
		data.duration = data.db[uSpecID][3]
		
		--Talents / Glyphs
		local durationTable = module.db.spell_durationByTalent_fix[spellID]
		if durationTable then
			for j=1,#durationTable,2 do
				if module.db.session_gGUIDs[fullName][ durationTable[j] ] then
					if tonumber(durationTable[j+1]) then
						data.duration = data.duration + durationTable[j+1]
					else
						local timeFix = tonumber( string.sub( durationTable[j+1], 2 ) )
						data.duration = data.duration * timeFix
					end
				end
			end
		end
		local cdTable = module.db.spell_cdByTalent_fix[spellID]
		if cdTable then
			for j=1,#cdTable,2 do
				if module.db.session_gGUIDs[fullName][ cdTable[j] ] then
					if tonumber(cdTable[j+1]) then
						data.cd = data.cd + cdTable[j+1]
					else
						local timeFix = tonumber( string.sub( cdTable[j+1], 2 ) )
						data.cd = data.cd * timeFix
					end
				end
			end
		end
		--Charges
		local isCharge = module.db.spell_charge_fix[ data.db[1] ]
		if isCharge and (data.lastUse+data.cd) >= currTime then
			data.charge = (data.charge or data.lastUse) + data.cd
			data.lastUse = currTime
			module.db.session_gGUIDs[fullName] = isCharge
		elseif isCharge and module.db.session_gGUIDs[fullName][isCharge] then
			data.charge = currTime
			data.lastUse = currTime
		else
			data.lastUse = currTime
		end
		--Haste/Readiness
		if module.db.spell_speed_list[spellID] then
			data.duration = data.duration / (1 + (UnitSpellHaste(fullName) or 0) /100)
		end
		if module.db.spell_reduceCdByHaste[spellID] then
			data.cd = data.cd / (1 + (UnitSpellHaste(fullName) or 0) /100) 
		end
		--Dispels
		if module.db.spell_dispellsList[spellID] then
			ScheduleTimer(DispellSchedule, 0.5, data)
		end
		-- Fixes
		if data.cd > 45000 then data.cd = 45000 end
		if data.duration > 45000 then data.duration = 45000 end
		
		if data.bar and data.bar.data == data then
			data.bar:UpdateStatus()
		end
		
		UpdateAllData()
		SortAllData()
		
		module.db.historyUsage[#module.db.historyUsage + 1] = {time(),data.db[uSpecID][1],fullName,GetEncounterTime()}
	end
end

function module:Enable()
	VExRT.ExCD2.enabled = true
	if not VExRT.ExCD2.SplitOpt then 
		module.frame:Show()
		module:ReloadAllSplits()
	else
		module:ReloadAllSplits()
	end

	module:RegisterSlash()
	module:RegisterTimer()
	module:RegisterEvents('SCENARIO_UPDATE','GROUP_ROSTER_UPDATE','COMBAT_LOG_EVENT_UNFILTERED','UNIT_PET','UNIT_SPELLCAST_SUCCEEDED','PLAYER_LOGOUT','ZONE_CHANGED_NEW_AREA')
end

function module:Disable()
	VExRT.ExCD2.enabled = nil
	if not VExRT.ExCD2.SplitOpt then 
		module.frame:Hide()
	else
		for i=1,module.db.maxColumns do 
			module.frame.colFrame[i]:Hide()
		end 
	end
	
	module:UnregisterSlash()
	module:UnregisterTimer()
	module:UnregisterEvents('SCENARIO_UPDATE','GROUP_ROSTER_UPDATE','COMBAT_LOG_EVENT_UNFILTERED','UNIT_PET','UNIT_SPELLCAST_SUCCEEDED','PLAYER_LOGOUT','ZONE_CHANGED_NEW_AREA')
end


function module.main:ADDON_LOADED()
	VExRT = _G.VExRT
	VExRT.ExCD2 = VExRT.ExCD2 or {NoRaid = true}
	
	if VExRT.Addon.Version < 2126 then
		if VExRT.ExCD2.colSet then
			for i=1,module.db.maxColumns+1 do
				if VExRT.ExCD2.colSet[i] and not VExRT.ExCD2.colSet[i].fontOutline then
					VExRT.ExCD2.colSet[i].fontShadow = true
				end
			end
		end
	end
	if VExRT.Addon.Version < 2302 then
		if VExRT.ExCD2.colSet then
			for i=1,module.db.maxColumns+1 do
				if VExRT.ExCD2.colSet[i] then
					VExRT.ExCD2.colSet[i].textGeneral = true
				end
			end
		end
	end
	if VExRT.Addon.Version < 3247 then
		if VExRT.ExCD2.colSet then
			for i=1,module.db.maxColumns+1 do
				if VExRT.ExCD2.colSet[i] then
					VExRT.ExCD2.colSet[i].blacklistGeneral = true
				end
			end
		end
	end
	
	if VExRT.ExCD2.Left and VExRT.ExCD2.Top then
		module.frame:ClearAllPoints()
		module.frame:SetPoint("TOPLEFT",UIParent,"BOTTOMLEFT",VExRT.ExCD2.Left,VExRT.ExCD2.Top)
	end
	
	VExRT.ExCD2.CDE = VExRT.ExCD2.CDE or {}
	VExRT.ExCD2.CDECol = VExRT.ExCD2.CDECol or {}
	if UnitFactionGroup("player") == "Alliance" then	--> BL Faction Fix
		for i,spellData in ipairs(module.db.spellDB) do
			if spellData[1] == 2825 then
				spellData[1] = 32182
				spellData[3][1] = 32182
				break
			end
		end
	end
	VExRT_CDE = VExRT.ExCD2.CDE
	
	if not VExRT.ExCD2.colSet then
		VExRT.ExCD2.colSet = {}
		for i=1,module.db.maxColumns+1 do
			VExRT.ExCD2.colSet[i] = {}
			for optName,optVal in pairs(module.db.colsInit) do
				VExRT.ExCD2.colSet[i][optName] = optVal
			end
			if i <= 3 then 
				VExRT.ExCD2.colSet[i].enabled = true
			end
		end
	end
	for i=1,module.db.maxColumns+1 do
		VExRT.ExCD2.colSet[i] = VExRT.ExCD2.colSet[i] or {}
	end
	
	VExRT.ExCD2.default_userCD = VExRT.ExCD2.default_userCD or {}
	VExRT.ExCD2.default_userDuration = VExRT.ExCD2.default_userDuration or {}
	do
		for spellID,spellData in pairs(VExRT.ExCD2.default_userCD) do
			for i=1,#module.db.spellDB do
				if module.db.spellDB[i][1] == spellID then
					for j=1,5 do
						if spellData[j] and module.db.spellDB[i][2+j] then
							if spellData[j] == module.db.spellDB[i][2+j][2] then
								spellData[j] = nil
							else
								module.db.spellDB[i][2+j][2] = spellData[j]
							end
						end
					end
				end
			end
		end
	
		for spellID,spellData in pairs(VExRT.ExCD2.default_userDuration) do
			for i=1,#module.db.spellDB do
				if module.db.spellDB[i][1] == spellID then
					for j=1,5 do
						if spellData[j] and module.db.spellDB[i][2+j] then
							if spellData[j] == module.db.spellDB[i][2+j][3] then
								spellData[j] = nil
							else
								module.db.spellDB[i][2+j][3] = spellData[j]
							end
						end
					end
				end
			end
		end
	end
	
	VExRT.ExCD2.userDB = VExRT.ExCD2.userDB or {}
	for i=1,#VExRT.ExCD2.userDB do
		module.db.spellDB[i+module.db.dbCountDef] = VExRT.ExCD2.userDB[i]
	end

	VExRT.ExCD2.Priority = VExRT.ExCD2.Priority or {}

	VExRT.ExCD2.gnGUIDs = VExRT.ExCD2.gnGUIDs or {}
	if VExRT.ExCD2.gnGUIDs and ExRT.F.table_len(VExRT.ExCD2.gnGUIDs) > 500 then
		wipe(VExRT.ExCD2.gnGUIDs)
	end
	globalGUIDs = VExRT.ExCD2.gnGUIDs

	if VExRT.ExCD2.lock then
		module.frame.texture:SetTexture(0, 0, 0, 0)
		module.frame:EnableMouse(false)
		ExRT.lib.AddShadowComment(module.frame,1)
	else
		module.frame.texture:SetTexture(0, 0, 0, 0.3)
		module.frame:EnableMouse(true)
		ExRT.lib.AddShadowComment(module.frame,nil,L.cd2)
	end
	
	module:SplitExCD2Window() 
	--module:ReloadAllSplits()
	
	VExRT.ExCD2.Save = VExRT.ExCD2.Save or {}

	if not VExRT.ExCD2.enabled then
		if not VExRT.ExCD2.SplitOpt then 
			module.frame:Hide() 
		else
			for i=1,module.db.maxColumns do 
				module.frame.colFrame[i]:Hide() 
			end 
		end
	else
		module:Enable()
		ScheduleTimer(UpdateRoster,10)
		ScheduleTimer(module.ReloadAllSplits,10)
		module:RegisterEvents('PLAYER_ENTERING_WORLD')
	end
	
	module.db.playerName = ExRT.SDB.charName
end

function module.main:PLAYER_ENTERING_WORLD()
	UpdateRoster()
	
	module:UnregisterEvents('PLAYER_ENTERING_WORLD')
end

function module.main:PLAYER_LOGOUT()
	SaveCDtoVar(true)
end

function module.main:SCENARIO_UPDATE()
	AfterCombatResetFunction()
	UpdateAllData()
	SortAllData()
end

do
	local scheduledUpdateRoster = nil
	local function funcScheduledUpdate()
		scheduledUpdateRoster = nil
		UpdateRoster()
	end
	function module.main:GROUP_ROSTER_UPDATE()
		if not scheduledUpdateRoster then
			scheduledUpdateRoster = ScheduleTimer(funcScheduledUpdate,2)
		end
	end
end

do
	local scheduledUpdateRoster = nil
	local function funcScheduledUpdate()
		scheduledUpdateRoster = nil
		UpdateRoster()
	end
	function module.main:ZONE_CHANGED_NEW_AREA()
		if select(2, IsInInstance()) == "arena" then
			AfterCombatResetFunction(true)
			UpdateAllData()
			SortAllData()
		end
		if not scheduledUpdateRoster then
			scheduledUpdateRoster = ScheduleTimer(funcScheduledUpdate,10)
		end
	end
end

function module.main:UNIT_PET(arg)
	local name = UnitCombatlogname(arg)
	if name then
		local forceUpdateAllData = nil
		local petNow = UnitCreatureFamily(arg.."pet")
		if petNow ~= _db.session_Pets[name] then
			_db.session_Pets[name] = UnitCreatureFamily(arg.."pet")
			forceUpdateAllData = true
		end
		if _db.session_Pets[name] then
			_db.session_PetOwner[UnitGUID(arg.."pet")] = name
		end
		if forceUpdateAllData then
			UpdateAllData()
		end
	end
end

do
	local spell_notInCLEU_fix = module.db.spell_notInCLEU_fix
	--Be care about spell with charges here. USS event can be fire more then one time: for raidX, partyX, target, focus, players unitID's
	function module.main:UNIT_SPELLCAST_SUCCEEDED(unitID,_,_,_,spellID)
		if spell_notInCLEU_fix[spellID] then
			local name = UnitCombatlogname(unitID)
			if name then
				module.main:COMBAT_LOG_EVENT_UNFILTERED(nil,"SPELL_CAST_SUCCESS",nil,nil,name,nil,nil,nil,nil,nil,nil,spellID)
			end
		end
	end
	if ExRT.F.table_len(spell_notInCLEU_fix) == 0 then
		function module.main:UNIT_SPELLCAST_SUCCEEDED()
			module:UnregisterEvents('UNIT_SPELLCAST_SUCCEEDED')
		end
	end
end

do
	local eventsView = nil
	--upvaules
	local spell_startCDbyAuraApplied = _db.spell_startCDbyAuraApplied
	local spell_reduceCdByAuraFade = _db.spell_reduceCdByAuraFade
	local spell_aura_list = _db.spell_aura_list
	local spell_startCDbyAuraFade = _db.spell_startCDbyAuraFade
	local spell_startCDbyAuraApplied_fix = _db.spell_startCDbyAuraApplied_fix
	local spell_isPetAbility = _db.spell_isPetAbility
	local spell_isTalent = _db.spell_isTalent
	local spell_resetOtherSpells = _db.spell_resetOtherSpells
	local spell_sharingCD = _db.spell_sharingCD
	local spell_reduceCdCast = _db.spell_reduceCdCast
	local spell_increaseDurationCast = _db.spell_increaseDurationCast
	local spell_runningSameSpell = _db.spell_runningSameSpell
	local spell_dispellsList = _db.spell_dispellsList
	
	local findspecspells = _db.findspecspells

	local session_gGUIDs = _db.session_gGUIDs
	local session_PetOwner = _db.session_PetOwner
	local CDList = _db.cdsNav
	
	function module.main:COMBAT_LOG_EVENT_UNFILTERED(_,_,event,_,sourceGUID,sourceName,sourceFlags,_,destGUID,destName,destFlags,_,spellID,_,_,_,_,_,_,_,_,critical,_,_,_,multistrike)
		--dtime()
		local func = eventsView[event]
		if func then
			func(self,sourceGUID,sourceName,sourceFlags,destGUID,destName,destFlags,spellID,critical,multistrike)
		end
		--dtime(ExRT.Debug,'ExCD2',event)
	end
	function module.main:SPELL_AURA_APPLIED(sourceGUID,sourceName,sourceFlags,destGUID,destName,destFlags,spellID)
		if sourceName then
			local CDspellID = spell_startCDbyAuraApplied[spellID]
			if CDspellID then
				local line = CDList[sourceName][CDspellID]
				if line then
					CLEUstartCD(line)
				end
			end
		end
	end
	function module.main:SPELL_AURA_REMOVED(sourceGUID,sourceName,sourceFlags,destGUID,destName,destFlags,spellID)
		if not sourceName then
			return
		end
		local forceSortAllData = false
	
		local modifData = spell_reduceCdByAuraFade[spellID]
		if modifData then
			local CDspellID = modifData[1]
			if type(CDspellID) ~= "table" then
				local line = CDList[sourceName][CDspellID]
				if line and (GetTime() - line.lastUse - line.duration) > -0.5 then
					line.cd = line.cd + modifData[2]
					if line.bar and line.bar.data == line then
						line.bar:UpdateStatus()
					end
					forceSortAllData = true
				end
			else
				if session_gGUIDs[sourceName][ CDspellID[2] ] then
					local line = CDList[sourceName][ CDspellID[1] ]
					if line and (GetTime() - line.lastUse - line.duration) > -0.5 then
						line.cd = line.cd + modifData[2]
						if line.bar and line.bar.data == line then
							line.bar:UpdateStatus()
						end
						forceSortAllData = true
					end
				end
			end
		end
	
		local CDspellID = spell_aura_list[spellID]
		if CDspellID then
			local line = CDList[sourceName][ CDspellID ]
			if line then
				line.duration = 0
				if line.bar and line.bar.data == line then
					line.bar:UpdateStatus()
				end
				forceSortAllData = true
			end
		end
		
		if spell_startCDbyAuraFade[spellID] then
			local line = CDList[sourceName][spellID]
			if line then
				CLEUstartCD(line)
			end
		end
		
		if forceSortAllData then
			SortAllData()
		end
	end
	function module.main:SPELL_CAST_SUCCESS(sourceGUID,sourceName,sourceFlags,destGUID,destName,destFlags,spellID)
		if not sourceName then
			return
		end
		local forceSortAllData,forceUpdateAllData = nil
	
		if spell_isPetAbility[spellID] then
			sourceName = session_PetOwner[sourceGUID] or sourceName
		end
		
		if spellID == 187614 or spellID == 187615 or spellID == 187611 or spellID == 187613 or spellID == 187612 then
			if not UnitName(sourceName) then	--Not in Raid or Party
				return
			end
			if not session_gGUIDs[sourceName][spellID] then
				session_gGUIDs[sourceName] = spellID
				UpdateLegendaryRingState()
			end
			sourceName = "*"
		end
	 
		local findSpecSpell = findspecspells[spellID]
		if findSpecSpell and (GetUnitInfoByUnitFlag(sourceFlags,4) % 8) > 0 then
			if globalGUIDs[sourceName] ~= findSpecSpell then
				forceUpdateAllData = true
			end
			globalGUIDs[sourceName] = findSpecSpell
		end
		
		if spell_startCDbyAuraFade[spellID] or spell_startCDbyAuraApplied_fix[spellID] then
			if forceUpdateAllData then UpdateAllData() end
			return
		end

		local line = CDList[sourceName][spellID]
		if line then
			CLEUstartCD(line)
		end

		if spell_isTalent[spellID] then
			if not session_gGUIDs[sourceName][spellID] then
				forceUpdateAllData = true
			end
			session_gGUIDs[sourceName] = spellID
		end
		
		local modifData = spell_resetOtherSpells[spellID]
		if modifData then
			for i=1,#modifData do
				local line = CDList[sourceName][ modifData[i] ]
				if line then
					line.cd = 0
					if line.bar and line.bar.data == line then
						line.bar:UpdateStatus()
					end
					forceUpdateAllData = true
					forceSortAllData = true
				end
			end
		end
		
		local modifData = spell_sharingCD[spellID]
		if modifData then
			local nowTime = GetTime()
			for sharingSpellID,timeCD in pairs(modifData) do
				local line = CDList[sourceName][sharingSpellID]
				if line then
					local cd_timer_now = line.lastUse + line.cd - nowTime
					if (cd_timer_now > 0 and cd_timer_now < timeCD) or (nowTime - line.lastUse) > line.cd then
						line.cd = timeCD
						line.lastUse = nowTime
						line.duration = 0
						if line.bar and line.bar.data == line then
							line.bar:UpdateStatus()
						end
						forceUpdateAllData = true
						forceSortAllData = true
					end
				end
			end
		end
		
		local modifData = spell_reduceCdCast[spellID]
		if modifData then
			for i=1,#modifData,2 do
				local reduceSpellID = modifData[i]
				if type(reduceSpellID) ~= "table" then
					local line = CDList[sourceName][reduceSpellID]
					if line then
						line.cd = line.cd + modifData[i+1]
						if line.cd < 0 then 
							line.cd = 0 
						end
						if line.bar and line.bar.data == line then
							line.bar:UpdateStatus()
						end
						forceUpdateAllData = true
						forceSortAllData = true
					end
				else
					if session_gGUIDs[sourceName][ reduceSpellID[2] ] then
						local line = CDList[sourceName][ reduceSpellID[1] ]
						if line then
							line.cd = line.cd + modifData[i+1]
							if line.cd < 0 then 
								line.cd = 0 
							end
							if line.bar and line.bar.data == line then
								line.bar:UpdateStatus()
							end
							forceUpdateAllData = true
							forceSortAllData = true
						end
					end
				end
			end
		end
		
		local modifData = spell_increaseDurationCast[spellID]
		if modifData then
			for i=1,#modifData,2 do
				local increaseSpellID = modifData[i]
				if type(increaseSpellID) ~= "table" then
					local line = CDList[sourceName][increaseSpellID]
					if line and (GetTime() - line.lastUse) < line.duration  then
						line.duration = line.duration + modifData[i+1]
						if line.duration < 0 then 
							line.duration = 0 
						end
						if line.bar and line.bar.data == line then
							line.bar:UpdateStatus()
						end
						forceUpdateAllData = true
						forceSortAllData = true
					end
				else
					if session_gGUIDs[sourceName][ increaseSpellID[2] ] then
						local line = CDList[sourceName][ increaseSpellID[1] ]
						if line and (GetTime() - line.lastUse) < line.duration  then
							line.duration = line.duration + modifData[i+1]
							if line.duration < 0 then 
								line.duration = 0 
							end
							if line.bar and line.bar.data == line then
								line.bar:UpdateStatus()
							end
							forceUpdateAllData = true
							forceSortAllData = true
						end
					end
				end
			end
		end
		
		local modifData = spell_runningSameSpell[spellID]
		if modifData then
			for i=1,#modifData do
				local line = CDList[sourceName][ modifData[i] ]
				if line then
					CLEUstartCD(line)
				end
			end
		end
		
		if forceUpdateAllData then
			UpdateAllData()
		end
		if forceSortAllData then
			SortAllData()
		end
	end
	function module.main:SPELL_DISPEL(sourceGUID,sourceName,sourceFlags,destGUID,destName,destFlags,spellID)
		if spell_dispellsList[spellID] and sourceName then
			_db.spell_dispellsFix[ sourceName ] = true
		end
	end
	
	local warriorT18durationChange = ExRT.clientVersion < 60202 and 25 or 30
	function module.main:SPELL_DAMAGE(sourceGUID,sourceName,sourceFlags,destGUID,destName,destFlags,spellID,critical,multistrike)
		if spellID == 100130 and critical and not multistrike and sourceName then
			if session_gGUIDs[sourceName][185799] then
				local line = CDList[sourceName][1719]
				if line then
					line.cd = line.cd - warriorT18durationChange
					if line.cd < 0 then 
						line.cd = 0 
					end
					if line.bar and line.bar.data == line then
						line.bar:UpdateStatus()
					end
					UpdateAllData()
					SortAllData()
				end
			end
		end
	end
	eventsView = {
		SPELL_AURA_REMOVED=module.main.SPELL_AURA_REMOVED,
		SPELL_AURA_APPLIED=module.main.SPELL_AURA_APPLIED,
		SPELL_CAST_SUCCESS=module.main.SPELL_CAST_SUCCESS,
		SPELL_DISPEL=module.main.SPELL_DISPEL,
		--SPELL_DAMAGE=module.main.SPELL_DAMAGE,
	}
	
	local isSpellDamageAdded = nil
	function module:AddCLEUSpellDamage()
		if isSpellDamageAdded then return end
		eventsView.SPELL_DAMAGE = module.main.SPELL_DAMAGE
		isSpellDamageAdded = true
	end
end

--dtime()
function module.options:Load()
	dtime()
	self:CreateTilte()

	loadstring(module.db.AllClassSpellsInText)()
	module.db.AllClassSpellsInText = nil

	module.options.spellsPerPage = 17

	self.chkEnable = ELib:Check(self,L.senable,VExRT.ExCD2.enabled):Point(560,-26):Size(18,18):OnClick(function(self) 
		if self:GetChecked() then
			module:Enable()
		else
			module:Disable()
		end
	end)
	
	self.chkLock = ELib:Check(self,L.cd2fix,VExRT.ExCD2.lock):Point(430,-26):Size(18,18):OnClick(function(self) 
		if self:GetChecked() then
			VExRT.ExCD2.lock = true
			ExRT.F.LockMove(module.frame,nil,module.frame.texture)
			ExRT.lib.AddShadowComment(module.frame,1)
			if VExRT.ExCD2.SplitOpt then 
				for i=1,module.db.maxColumns do 
					ExRT.F.LockMove(module.frame.colFrame[i],nil,module.frame.colFrame[i].lockTexture)
					ExRT.lib.AddShadowComment(module.frame.colFrame[i],1)
				end 
			end
		else
			VExRT.ExCD2.lock = nil
			ExRT.F.LockMove(module.frame,true,module.frame.texture)
			ExRT.lib.AddShadowComment(module.frame,nil,L.cd2)
			if VExRT.ExCD2.SplitOpt then 
				for i=1,module.db.maxColumns do 
					ExRT.F.LockMove(module.frame.colFrame[i],true,module.frame.colFrame[i].lockTexture)
					ExRT.lib.AddShadowComment(module.frame.colFrame[i],nil,L.cd2,i,72,"OUTLINE")
				end 
			end
		end
	end)
	
	self.decorationLine = CreateFrame("Frame",nil,self)
	self.decorationLine.texture = self.decorationLine:CreateTexture(nil, "BACKGROUND")
	self.decorationLine:SetPoint("TOPLEFT",self,-8,-25)
	self.decorationLine:SetPoint("BOTTOMRIGHT",self,"TOPRIGHT",8,-45)
	self.decorationLine.texture:SetAllPoints()
	self.decorationLine.texture:SetTexture(1,1,1,1)
	self.decorationLine.texture:SetGradientAlpha("VERTICAL",.24,.25,.30,1,.27,.28,.33,1)

	self.tab = ELib:Tabs(self,0,L.cd2Spells,L.cd2Appearance,L.cd2History):Point(0,-45):Size(660,570):SetTo(1)
	self.tab:SetBackdropBorderColor(0,0,0,0)
	self.tab:SetBackdropColor(0,0,0,0)
	
	local function fastSetupFrameListClick(self,spellsList)
		for k=1,#spellsList do
			local bool = nil
			for j=1,#module.db.spellDB do
				if module.db.spellDB[j][1] == spellsList[k] then
					bool = true
					break
				end
			end
			if not bool then
				for class,classData in pairs(module.db.allClassSpells) do
					for j=1,#classData do
						if classData[j][1] == spellsList[k] then
							module.options:addNewSpell(class,classData[j],true)
							bool = true
							break
						end
					end
					if bool then
						break
					end
				end
			end
		end
		for j=1,#spellsList do
			VExRT.ExCD2.CDE[ spellsList[j] ] = true
		end
		UpdateRoster()
		module.options:ReloadSpellsPage()
		ELib:DropDownClose()
	end
	local function fastSetupFrameListEnter(self,tooltip)
		ELib.Tooltip.Show(self,"ANCHOR_LEFT",unpack(tooltip))
	end
	local function fastSetupFrameListLeave(self)
		ELib.Tooltip:Hide()
	end
	local function fastSetupFrameListClick2(self)
		local list = {
			{L.cd2fastSetupTitle1,{31821,62618,97462,76577,51052,98008,115310,64843,740,108280,108281,15286}},					--Raid Save
			{L.cd2fastSetupTitle2,{47788,33206,6940,102342,114030,116849,1022}},								--Direct Save
			{L.cd2fastSetupTitle3,{20484,20707,61999,20608,161642}},										--Battle Res
			{L.cd2fastSetupTitle4,{6552,102060,96231,147362,1766,15487,47528,47476,57994,2139,116705,106839,19647,91802,115781,78675,}},	--Kicks
			{L.cd2fastSetupTitle5,{114192,355,62124,56222,49576,115546,6795,}},								--Taunts
			{L.cd2fastSetupTitle6,{4987,32375,527,51886,115450,2782,475,115276,89808}},							--Dispels
		}
		for i=1,#list do
			local tooltip = {list[i][1]..":"}
			for j=1,#list[i][2] do
				local spellName,_,spellTexture = GetSpellInfo(list[i][2][j])
				if spellName then
					tooltip[#tooltip + 1] = "|T"..spellTexture..":0|t |cffffffff"..spellName.."|r"
				end
			end
			self.List[i] = {
				text = list[i][1],
				arg1 = list[i][2],
				func = fastSetupFrameListClick,
				hoverFunc = fastSetupFrameListEnter,
				leaveFunc = fastSetupFrameListLeave,
				hoverArg = tooltip,
				justifyH = "CENTER",
			}
		end
		self.OnClick = nil
	end
	self.fastSetupFrame = ELib:ListButton(self.tab.tabs[1],L.cd2fastSetupTitle..":",200,6):Size(18,18):Point("TOPRIGHT",-15,-9):Left():OnClick(fastSetupFrameListClick2)
	self.fastSetupFrame.text:FontSize(11):Color(GameFontNormal:GetTextColor())
	
	self.borderList = CreateFrame("Frame",nil,self.tab.tabs[1])
	self.borderList:SetSize(650,self.spellsPerPage*31+3)
	self.borderList:SetPoint("TOP", 0, -38)
	self.borderList:SetBackdrop({bgFile = "Interface/Tooltips/UI-Tooltip-Background",edgeFile = ExRT.F.defBorder,tile = false,edgeSize = 8})
	self.borderList:SetBackdropColor(0,0,0,0.3)
	self.borderList:SetBackdropBorderColor(.24,.25,.30,1)
	
	local function SyncUserDB()
		table.wipe(VExRT.ExCD2.userDB)
		local j = 1
		for i=module.db.dbCountDef+1,#module.db.spellDB do
			VExRT.ExCD2.userDB[j] = module.db.spellDB[i]
			j = j + 1
		end
	end
	
	local function CheckToNil(self)
		self.chk:SetChecked(nil) 
		VExRT.ExCD2.CDE[self.sid] = nil
		UpdateRoster()
	end

	function module.options:ReloadSpellsPage()
		local page = module.options
		local scrollBarValue = page.ScrollBar:GetValue()
		page.spellsListScrollFrame:SetVerticalScroll(scrollBarValue % 31) 

		local event = floor(scrollBarValue / 31) + 1
		page.butSpellsAdd:Hide()
		page.butSpellsFrame:Hide()	
		for i=event,event+page.spellsPerPage do
			local j = i - event + 1
			if i <= #module.db.spellDB then
				local spellData = module.db.spellDB[i]
				local SpellID = spellData[1]
				local line = module.options.spellsList[j]
			
				line.chk:SetChecked(VExRT.ExCD2.CDE[SpellID])
				local SpellName,_,SpellTexture = GetSpellInfo(SpellID)
				if module.db.differentIcons[ SpellID ] then
					SpellTexture = module.db.differentIcons[SpellID]
				end
				if SpellID == 187614 then SpellName = "Legendary DD" end
				if SpellID == 187612 then SpellName = "Legendary Heal" end
				if SpellID == 187613 then SpellName = "Legendary Tank" end
				
				line.sid = SpellID
				line.tid = i
				line.icon:SetTexture(SpellTexture or "Interface\\Icons\\INV_MISC_QUESTIONMARK")
				line.spellName:SetFormattedText("|cffffffff|Hspell:%d|h%s|h|r",SpellID, SpellName or "?")
				line.class:SetText(L.classLocalizate[ spellData[2] ] or "?")
				local cR,cG,cB = ExRT.F.classColorNum(spellData[2])
				line.class:SetTextColor(cR,cG,cB,1)
				
				line.backClassColorR = cR
				line.backClassColorG = cG
				line.backClassColorB = cB
		
				if not SpellName and spellData.user then
					line.chk:Disable()
					line.chk:SetAlpha(0.5)
				else
					line.chk:Enable()
					line.chk:SetAlpha(1)
				end
	
				line:Show()
	
				ExRT.lib.ShowOrHide(line.tooltipFrame,not spellData.user)
				ExRT.lib.ShowOrHide(line.spellName,not spellData.user)
				ExRT.lib.ShowOrHide(line.class,not spellData.user)
				ExRT.lib.ShowOrHide(line.userSpellName,spellData.user)
				ExRT.lib.ShowOrHide(line.userClass,spellData.user)
				ExRT.lib.ShowOrHide(line.userRemove,spellData.user)
	
				line.dropDownPriority:SetText(format("%d",VExRT.ExCD2.Priority[SpellID] or 15))
	
				if spellData.user then
					line.userSpellName:SetText(SpellID or "")
	
					line.userClass:SetText("|c"..ExRT.F.classColor(spellData[2])..L.classLocalizate[ spellData[2] ])
					
					line.isUserSpell = true
				else
					line.isUserSpell = nil
				end
				
				if SpellID == 161642 then
					line.additionalTooltip = L.cd2ResurrectTooltip
				else
					line.additionalTooltip = nil
				end
			else
				page.butSpellsAdd:Show()
				page.butSpellsFrame:Show()
				page.spellsList[j]:Hide()
			end
		end
		GameTooltip_Hide()
		ELib.Tooltip:HideAdd()
		page.ScrollBar:UpdateButtons()
	end
	
	self.ScrollBar = ELib:ScrollBar(self.borderList):Size(16,self.spellsPerPage*31-5):Point("TOPRIGHT",-3,-4):ClickRange(31):Range(1,20):OnChange(module.options.ReloadSpellsPage)

	function self.ScrollBar:UpdateRange()
		self:SetMinMaxValues(1,max((#module.db.spellDB-module.options.spellsPerPage+1)*31-1,1))
	end
	
	self:SetScript("OnMouseWheel", function(self, delta)
		delta = -delta
		local current = module.options.ScrollBar:GetValue()
		local min_,max_ = module.options.ScrollBar:GetMinMaxValues()
		current = current + (delta * 31)
		if current > max_ then
			current = max_
		elseif current < min_ then
			current = min_
		end
		module.options.ScrollBar:SetValue(current)
	end)
	
	local function SpellsListChkOnClick(self)
		if self:GetChecked() then
			VExRT.ExCD2.CDE[self:GetParent().sid] = true
		else
			VExRT.ExCD2.CDE[self:GetParent().sid] = nil
		end
		UpdateRoster()
	end
	local function SpellsListOnUpdate(self)
		if MouseIsOver(self) and not ExRT.lib.ScrollDropDown.DropDownList[1]:IsShown() and not module.options.spellsModifyFrame:IsShown() then
			self.backClassColor:SetGradientAlpha("HORIZONTAL", self.backClassColorR, self.backClassColorG, self.backClassColorB, 0.8, self.backClassColorR, self.backClassColorG, self.backClassColorB, 0)
		else
			self.backClassColor:SetGradientAlpha("HORIZONTAL", self.backClassColorR, self.backClassColorG, self.backClassColorB, 0.4, self.backClassColorR, self.backClassColorG, self.backClassColorB, 0)
		end
	end
	local function SpellsListTooltipFrameOnEnter(self)
		ELib.Tooltip.Link(self,self:GetParent().spellName:GetText())
		if self:GetParent().additionalTooltip then
			ELib.Tooltip:Add(nil,{self:GetParent().additionalTooltip})
		end
	end
	local function SpellsListTooltipFrameOnLeave()
		GameTooltip_Hide()
		ELib.Tooltip:HideAdd()
	end
	local SpellsListDropDownPriorityDataList = {}
	local function SpellsListDropDownPrioritySelectFunc(self,arg)
		local list = self:GetParent().parent
		list:SetText(arg)
		VExRT.ExCD2.Priority[list:GetParent().sid] = arg
		ELib:DropDownClose()
		UpdateRoster()
	end
	for i=1,30 do
		SpellsListDropDownPriorityDataList[i] = {text=i,justifyH="CENTER",arg1=i,func=SpellsListDropDownPrioritySelectFunc}
	end
	local function SpellsListDropDownPriorityOnEnter(self)
		ELib.Tooltip.Show(self,"ANCHOR_LEFT",L.cd2Priority,{L.cd2PriorityTooltip,1,1,1,true})
	end
	local function SpellsListButtonModifyOnClick(self)
		local spellsModifyFrame = module.options.spellsModifyFrame
		spellsModifyFrame:Hide()
		local parent = self:GetParent()
		spellsModifyFrame.sid = parent.sid
		spellsModifyFrame.tid = parent.tid
		spellsModifyFrame.class = module.db.spellDB[parent.tid][2]
		spellsModifyFrame:ShowClick("TOPRIGHT")
	end
	local function SpellsListUserSpellNameOnTextChanged(self,isUser)
		if not isUser then
			return
		end
		local tmp = nil
		local spellID = tonumber(self:GetText())
		local parentLine = self:GetParent()
		if spellID then
			for j=1,#module.db.spellDB do
				if module.db.spellDB[j][1] == spellID and j ~= parentLine.tid then
					parentLine.chk:Disable()
					parentLine.chk:SetAlpha(0.5)
					return
				end
			end
		end
	
		CheckToNil(parentLine)
		if not spellID then 
			parentLine.chk:Disable()
			parentLine.chk:SetAlpha(0.5)
			return 
		end
		local spellName,_,spellTexture = GetSpellInfo(spellID)
		parentLine.sid = spellID
		parentLine.icon:SetTexture(spellTexture or "Interface\\Icons\\INV_MISC_QUESTIONMARK")
		if not spellName then
			parentLine.chk:Disable()
			parentLine.chk:SetAlpha(0.5)
		else
			parentLine.chk:Enable()
			parentLine.chk:SetAlpha(1)
		end
		module.db.spellDB[parentLine.tid][1] = spellID
		SyncUserDB()
	end
	local function SpellsListUserSpellNameOnEnter(self)
		local spellID = tonumber(self:GetText())
		if spellID then
			local spellName = GetSpellInfo(spellID)
			if spellName then
				ELib.Tooltip.Link(self,format("|Hspell:%d|hspell|h",spellID))
			else
				ELib.Tooltip.Std(self)
			end
		else
			ELib.Tooltip.Std(self)
		end
	end

	local SpellsListClassDropDownList = {}
	local function SpellsListUserClassDropDownClick(self,classNum,isAll)
		local parent = self:GetParent().parent
		local parentLine = parent:GetParent()
		local class = isAll and "ALL" or module.db.classNames[classNum]
		CheckToNil(parentLine)
		ELib:DropDownClose()
		parent:SetText("|c"..ExRT.F.classColor(class)..L.classLocalizate[ class ])
		module.db.spellDB[parentLine.tid][2] = class
		local cR,cG,cB = ExRT.F.classColorNum(class)
		parentLine.backClassColorR = cR
		parentLine.backClassColorG = cG
		parentLine.backClassColorB = cB
		SyncUserDB()
	end
	for i=1,#module.db.classNames do
		SpellsListClassDropDownList[#SpellsListClassDropDownList + 1] = {
			text = "|c"..ExRT.F.classColor(module.db.classNames[i])..L.classLocalizate[ module.db.classNames[i] ],
			justifyH = "CENTER",
			arg1 = i,
			func = SpellsListUserClassDropDownClick,
		}
	end
	SpellsListClassDropDownList[#SpellsListClassDropDownList + 1] = {
		text = "|c"..ExRT.F.classColor("ALL")..L.classLocalizate[ "ALL" ],
		justifyH = "CENTER",
		arg1 = 0,
		arg2 = true,
		func = SpellsListUserClassDropDownClick,
	}	
	
	local function SpellsListUserRemoveOnClick(self)
		local parentLine = self:GetParent()
		VExRT.ExCD2.CDE[parentLine.sid] = nil
		
		for j=3,7 do
			if type(module.db.spellDB[parentLine.tid][j])=="table" then
				VExRT.ExCD2.CDECol[module.db.spellDB[parentLine.tid][j][1]..";"..(j-2)] = nil
			end
		end
		
		for j = parentLine.tid + 1,#module.db.spellDB do
			module.db.spellDB[j-1] = module.db.spellDB[j]
		end
		module.db.spellDB[#module.db.spellDB] = nil

		local current = module.options.ScrollBar:GetValue()
		local min_,max_ = module.options.ScrollBar:GetMinMaxValues()
		module.options.ScrollBar:UpdateRange()
		
		local newVal = current == max_ and max(current-31,1) or current
		if newVal ~= current then
			module.options.ScrollBar:SetValue(newVal)
		else
			module.options.ReloadSpellsPage()
		end

		SyncUserDB()
		UpdateRoster()
		
		module.options:CleanUPVariables()
	end
	
	self.spellsListScrollFrame = CreateFrame("ScrollFrame", nil, self.borderList)
	self.spellsListScrollFrame:SetPoint("TOP",0,-3)
	self.spellsListScrollFrame:SetSize(self.borderList:GetWidth(),self.borderList:GetHeight()-8)
	
	self.spellsListScrollFrameContent = CreateFrame("Frame", nil, self.spellsListScrollFrame)
	self.spellsListScrollFrameContent:SetPoint("TOPLEFT",0,0)
	self.spellsListScrollFrameContent:SetSize(self.spellsListScrollFrame:GetSize())
	self.spellsListScrollFrame:SetScrollChild(self.spellsListScrollFrameContent)
	
	self.spellsList = {}
	for i=1,(self.spellsPerPage+1) do
		local line = CreateFrame("Frame",nil,self.spellsListScrollFrameContent)
		self.spellsList[i] = line
		line:SetPoint("TOPLEFT",5,-1-(i-1)*31)
		line:SetSize(620,31)

		line.chk = ELib:Check(line):Point("LEFT",5,0):OnClick(SpellsListChkOnClick)
		line.chk._i = i
		
		line.backClassColor = line:CreateTexture(nil, "BACKGROUND")
		line.backClassColor:SetPoint("TOPLEFT",-3,0)
		line.backClassColor:SetSize(200,31)
		line.backClassColor:SetTexture( 1, 1, 1, 1)
		line.backClassColorR = 0
		line.backClassColorG = 0
		line.backClassColorB = 0
		
		line:SetScript("OnUpdate",SpellsListOnUpdate)
	
		line.icon = line:CreateTexture(nil, "ARTWORK")
		line.icon:SetSize(30,30)
		line.icon:SetPoint("TOPLEFT", 30, -1)
	
		line.tooltipFrame = CreateFrame("Frame",nil,line)
		line.tooltipFrame:SetSize(150,30) 
		line.tooltipFrame:SetPoint("TOPLEFT", 66, 0)
		line.tooltipFrame._i = i
		line.tooltipFrame:SetScript("OnEnter", SpellsListTooltipFrameOnEnter)
		line.tooltipFrame:SetScript("OnLeave", SpellsListTooltipFrameOnLeave)

		line.spellName = ELib:Text(line):Size(155,30):Point(66,0):Font(ExRT.F.defFont,12):Shadow()
	
		line.class = ELib:Text(line):Size(180,30):Point(230,0):Font(ExRT.F.defFont,14):Shadow()
	
		line.dropDownPriority = ELib:DropDown(line,100,15):Size(80):Point("LEFT",370,0)
		line.dropDownPriority._i = i
		line.dropDownPriority.List = SpellsListDropDownPriorityDataList
		line.dropDownPriority:SetScript("OnEnter",SpellsListDropDownPriorityOnEnter)
		line.dropDownPriority:SetScript("OnLeave",ELib.Tooltip.Hide)
		
		line.buttonModify = ELib:Button(line,L.cd2ButtonModify):Size(130,20):Point("LEFT",460,0):OnClick(SpellsListButtonModifyOnClick)
		line.buttonModify._i = i

		line.userSpellName = ELib:Edit(line,6,true):Size(145,20):Point("LEFT",65,0):Tooltip(L.cd2SpellID):OnChange(SpellsListUserSpellNameOnTextChanged)
		line.userSpellName._i = i
		line.userSpellName:SetScript("OnEnter",SpellsListUserSpellNameOnEnter)
		line.userSpellName:SetScript("OnLeave",ELib.Tooltip.Hide)
		
		line.userClass = ELib:DropDown(line,130,12):Size(140):Point("LEFT",220,0):SetText(L.cd2Class)
		line.userClass._i = i
		line.userClass.List = SpellsListClassDropDownList
	
		line.userRemove = ELib:Button(line,"","UIPanelCloseButton"):Size(18,18):Point("LEFT",595,0):OnClick(SpellsListUserRemoveOnClick)
		line.userRemove.tooltipText = L.cd2RemoveButton
		line.userRemove._i = i
		line.userRemove:SetScript("OnEnter",ELib.Tooltip.Std)
		line.userRemove:SetScript("OnLeave",ELib.Tooltip.Hide)

		line.userClass:Hide()
		line.userRemove:Hide()
	end

	self.butSpellsAdd = ELib:Button(self.spellsListScrollFrameContent,L.cd2AddSpell):Size(305,20):Point(5,-3-(self.spellsPerPage)*31):OnClick(function(self) 
		module.options:addNewSpell(module.db.classNames[math.random(1,#module.db.classNames)])
		module.options:CleanUPVariables()
	end) 
	self.butSpellsAdd:Hide()
	
	self.butSpellsFrame = ELib:Button(self.spellsListScrollFrameContent,L.cd2AddSpellFromList):Size(305,20):Point(317,-3-(self.spellsPerPage)*31):OnClick(function(self) 
		module.options.addSpellFrame:Show()
	end) 
	self.butSpellsFrame:Hide()
	
	self.spellsModifyFrame = ELib:Popup():Size(560,180)
	self.spellsModifyFrame.isDefaultSpell = nil
	
	self.spellsModifyFrame.OnShow = function(self)
		if not self.class or not self.sid or not self.tid then
			self:Hide()
			return
		end
		self:SetFrameLevel(120)
		
		local titleName,_,titleTexture = GetSpellInfo(self.sid)
		self.title:SetFormattedText("%s%s",titleTexture and "|T"..titleTexture..":16|t " or "",titleName or L.cd2TextSpell.." #"..self.sid)
		
		local spellData = module.db.spellDB[self.tid]

		local specByClassTable = module.db.specByClass[self.class] or {0}
		local specsCount = #specByClassTable
		for i=1,specsCount do
			local specID = specByClassTable[i]
			local icon = ""
			if module.db.specIcons[specID] then
				icon = "|T".. module.db.specIcons[specID] ..":20|t"
			else
				icon = ExRT.F.classIconInText(self.class,20) or ""
			end
			local line = module.options.spellsModifyFrame.el[i]
		
			line.spec:SetText(icon.." |c"..ExRT.F.classColor(self.class)..L.specLocalizate[module.db.specInLocalizate[specID]])
			line:Show()
			
			if spellData[i+2] then
				line.cd:SetText(spellData[i+2][2])
				line.dur:SetText(spellData[i+2][3])
				line.spellID:SetText(spellData[i+2][1])
				
				line.col:SetText( VExRT.ExCD2.CDECol[spellData[i+2][1]..";"..i] or module.db.def_col[spellData[i+2][1]..";"..i] or 1)
				
				line.add:Hide()
				line.col:Show()
				line.dur:Show()
				line.spellID:Show()
				line.cd:Show()
				line.remove:Show()
			else
				line.add:Show()
				line.col:Hide()
				line.dur:Hide()
				line.spellID:Hide()
				line.cd:Hide()
				line.remove:Hide()
			end
			
			if not spellData.user then
				line.spellID:Disable()
				line.remove:Disable()
				line.add:Hide()
			else
				line.spellID:Enable()
				line.remove:Enable()
			end
		end
		for i=specsCount+1,5 do
			self.el[i]:Hide()
		end
		if not spellData.user then
			self.isDefaultSpell = true
		else
			self.isDefaultSpell = nil
		end
		self:SetHeight(30+32*specsCount)
	end
	
	self.spellsModifyFrame.el = {}
	for i=1,5 do
		local line = CreateFrame("Frame",nil,self.spellsModifyFrame)
		self.spellsModifyFrame.el[i] = line
		line:SetPoint("TOPLEFT",15,-20-(i-1)*32)
		line:SetSize(self.spellsModifyFrame:GetWidth(),30)
		
		line.spec = ELib:Text(line):Size(160,30):Point(0,0):Font(ExRT.F.defFont,14):Shadow()
	
		line.spellID = ELib:Edit(line,6,true):Size(140,20):Point("LEFT",180,0):Tooltip(L.cd2SpellID):OnChange(function(self,isUser)
			local spellID = tonumber(self:GetText())
			if not spellID or not isUser then
				return
			end
			local spellName = GetSpellInfo(spellID)
			local modFrame = self:GetParent():GetParent()

			local c = VExRT.ExCD2.CDECol[module.db.spellDB[modFrame.tid][i+2][1]..";"..i]
			local tmp = nil
			for N1=1,#module.db.spellDB do
				for N2=3,7 do
					if module.db.spellDB[N1][N2] and module.db.spellDB[N1][N2] and module.db.spellDB[N1][N2][1] == module.db.spellDB[modFrame.tid][i+2][1] and not (modFrame.tid == N1 and (i+2) == N2) then
						tmp = true
					end
				end
			end
			if not tmp then
				VExRT.ExCD2.CDECol[module.db.spellDB[modFrame.tid][i+2][1]..";"..i] = nil
			end
			module.db.spellDB[modFrame.tid][i+2][1] = spellID
			if not VExRT.ExCD2.CDECol[spellID..";"..i] and not module.db.def_col[spellID..";"..i] then
				VExRT.ExCD2.CDECol[spellID..";"..i] = c
			else
				modFrame.el[i].col:SetText( VExRT.ExCD2.CDECol[spellID..";"..i] or module.db.def_col[spellID..";"..i])
			end
		end)
		line.spellID:SetScript("OnEnter",function(self)
			local spellID = tonumber(self:GetText())
			if spellID then
				local spellName = GetSpellInfo(spellID)
				if spellName then
					local link = format("|Hspell:%d|hspell|h",spellID)
					ELib.Tooltip.Link(self,link)
				else
					ELib.Tooltip.Std(self)
				end
			else
				ELib.Tooltip.Std(self)
			end
		end)
		line.spellID:SetScript("OnLeave",function(self)
			ELib.Tooltip:Hide()
		end)
		
		line.col = ELib:DropDown(line,100,10):Size(70):Point("LEFT",330,0):Tooltip(L.cd2ColNum)
		local function SpellsModifyFrameColSet(self,arg)
			module.options.spellsModifyFrame.el[i].col:SetText(arg)
			ELib:DropDownClose()
			VExRT.ExCD2.CDECol[module.db.spellDB[module.options.spellsModifyFrame.tid][i+2][1]..";"..i] = tonumber(arg)
			UpdateRoster()
		end
		for j=1,10 do
			line.col.List[j] = {
				text=j,
				justifyH="CENTER",
				arg1=j,
				func=SpellsModifyFrameColSet,
			}
		end
		
		
		line.cd = ELib:Edit(line,6,true):Size(50,20):Point("LEFT",410,0):Tooltip(L.cd2EditBoxCDTooltip):OnChange(function(self,isUser)
			if not isUser then
				return
			end
			local cd_num = tonumber(self:GetText())
			if not cd_num then
				return
			end
			local modFrame = self:GetParent():GetParent()
			module.db.spellDB[modFrame.tid][i+2][2] = cd_num
			if modFrame.isDefaultSpell then
				local spellID = module.db.spellDB[modFrame.tid][1]
				VExRT.ExCD2.default_userCD[spellID] = VExRT.ExCD2.default_userCD[spellID] or {}
				VExRT.ExCD2.default_userCD[spellID][i] = cd_num
			end
		end)
		
		line.dur = ELib:Edit(line,6,true):Size(50,20):Point("LEFT",470,0):Tooltip(L.cd2EditBoxDurationTooltip):OnChange(function(self,isUser)
			if not isUser then
				return
			end
			local duration = tonumber(self:GetText())
			if not duration then
				return
			end
			local modFrame = self:GetParent():GetParent()
			module.db.spellDB[modFrame.tid][i+2][3] = duration
			if modFrame.isDefaultSpell then
				local spellID = module.db.spellDB[modFrame.tid][1]
				VExRT.ExCD2.default_userDuration[spellID] = VExRT.ExCD2.default_userDuration[spellID] or {}
				VExRT.ExCD2.default_userDuration[spellID][i] = duration
			end
		end)
		line.dur:SetTextColor(0.5,1,0.5,1)
		
		line.remove = ELib:Button(line,"","UIPanelCloseButton"):Size(18,18):Point("LEFT",520,0):OnClick(function(self) 
			local parentLine = self:GetParent()
			parentLine.add:Show()
			parentLine.col:Hide()
			parentLine.dur:Hide()
			parentLine.spellID:Hide()
			parentLine.cd:Hide()
			parentLine.remove:Hide()
			
			module.db.spellDB[parentLine:GetParent().tid][i+2] = nil
		end) 
		line.remove.tooltipText = L.cd2RemoveButton
		line.remove:SetScript("OnEnter",ELib.Tooltip.Std)
		line.remove:SetScript("OnLeave",ELib.Tooltip.Hide)
		
		line.add = ELib:Button(line,0,1):Size(400,24):Point(140,-4):OnClick(function(self) 
			local parentLine = self:GetParent()
			local modFrame = parentLine:GetParent()
			self:Hide()
			parentLine.col:Show()
			parentLine.dur:Show()
			parentLine.spellID:Show()
			parentLine.cd:Show()
			parentLine.remove:Show()
			
			parentLine.spellID:SetText(modFrame.sid)
			
			module.db.spellDB[modFrame.tid][i+2] = {modFrame.sid,0,0}
			
			parentLine.cd:SetText(0)
			parentLine.dur:SetText(0)
			parentLine.col:SetText(VExRT.ExCD2.CDECol[module.db.spellDB[modFrame.tid][i+2][1]..";"..i] or 1)
		end)
		line.add.html = ELib:Text(line.add,L.cd2TextAdd):Point(0,0):Point("BOTTOMRIGHT",0,0):Center():Color()
		ExRT.lib.CreateHoverHighlight(line.add)
		line.add.hl:SetVertexColor(1,1,1,0.5)
		line.add:SetScript("OnEnter", function(self) self.hl:Show() end)
		line.add:SetScript("OnLeave", function(self) self.hl:Hide() end)
	end
	
	self.addSpellFrame = ELib:Popup(L.cd2AddSpellFrameName):Size(550,422+10)

	self.addSpellFrame.backClassColor = self.addSpellFrame:CreateTexture(nil, "BORDER",nil,0)
	self.addSpellFrame.backClassColor:SetPoint("TOP",0,-20)
	self.addSpellFrame.backClassColor:SetSize(550,40)
	self.addSpellFrame.backClassColor:SetTexture( 1, 1, 1, 1)
	self.addSpellFrame.backClassColor:Hide()
	
	self.addSpellFrame.backClassColorBottom = self.addSpellFrame:CreateTexture(nil, "BORDER",nil,0)
	self.addSpellFrame.backClassColorBottom:SetPoint("BOTTOM",0,0)
	self.addSpellFrame.backClassColorBottom:SetSize(550,15)
	self.addSpellFrame.backClassColorBottom:SetTexture( 1, 1, 1, 1)
	self.addSpellFrame.backClassColorBottom:Hide()
	
	self.addSpellFrame.sortedClasses = {}
	
	self.addSpellFrame.dropDown = ELib:DropDown(self.addSpellFrame,200,10):Size(210):Point("TOPRIGHT",-5,-25)
	function self.addSpellFrame.dropDown:SetValue(newValue)
		local addSpellFrame = module.options.addSpellFrame
		addSpellFrame.dropDown:SetText("|c"..ExRT.F.classColor(newValue)..(L.classLocalizate[newValue] or newValue == "RACIAL" and L.cd2Racial or newValue == "ITEMS" and L.cd2Items or "Unk"))
		ELib:DropDownClose()
		if not addSpellFrame.sortedClasses[newValue] then
			for i=1,#module.db.allClassSpells[newValue] do
				local spellName = GetSpellInfo(module.db.allClassSpells[newValue][i][1])
				module.db.allClassSpells[newValue][i].spellName = spellName or tostring(module.db.allClassSpells[newValue][i][1])
			end
			sort(module.db.allClassSpells[newValue],function(a,b) return a.spellName < b.spellName end)
			addSpellFrame.sortedClasses[newValue] = true
		end
		
		for i=1,#module.db.allClassSpells[newValue] do
			if i <= addSpellFrame.buttonsMax then
				local SpellID = module.db.allClassSpells[newValue][i][1]
				local spellName, _, spellTexture = GetSpellInfo(SpellID)
				if module.db.differentIcons[ SpellID ] then
					spellTexture = module.db.differentIcons[SpellID]
				end
				local buttonFrame = module.options.addSpellFrame.buttons[i]
				
				buttonFrame.icon:SetTexture(spellTexture or "Interface\\Icons\\INV_MISC_QUESTIONMARK")
				buttonFrame.text:SetText(spellName or "?")
				buttonFrame.spellID = SpellID
				buttonFrame.spellLink = GetSpellLink(SpellID)
				buttonFrame.colNum = module.db.allClassSpells[newValue][i][2]
				
				buttonFrame.line = module.db.allClassSpells[newValue][i]
				
				if newValue == "PET" then
					buttonFrame.text:SetText("|c"..ExRT.F.classColor(module.db.allClassSpells[newValue][i][3])..L.classLocalizate[module.db.allClassSpells[newValue][i][3]].."|r "..(spellName or "?"))
				end
				
				buttonFrame.disabled = nil
				for j=1,#module.db.spellDB do
					if module.db.spellDB[j][1] == SpellID then
							buttonFrame.icon:SetDesaturated(true)
							buttonFrame.text:SetTextColor(0.5,0.5,0.5,1)
							buttonFrame.disabled = true
						break
					end
				end
				if not buttonFrame.disabled then
					buttonFrame.icon:SetDesaturated(nil)
					buttonFrame.text:SetTextColor(1,1,1,1)
				end
	
				buttonFrame:Show()
			end
		end
		for i=#module.db.allClassSpells[newValue]+1,addSpellFrame.buttonsMax do
			addSpellFrame.buttons[i]:Hide()
		end
		addSpellFrame.class = newValue
		
		local cR,cG,cB = ExRT.F.classColorNum(newValue)
		addSpellFrame.backClassColor:SetGradientAlpha("VERTICAL", cR,cG,cB, 0, cR,cG,cB, 0.5)
		addSpellFrame.backClassColor:Show()
		addSpellFrame.backClassColorBottom:SetGradientAlpha("VERTICAL", cR,cG,cB, 0.5, cR,cG,cB, 0)		
		addSpellFrame.backClassColorBottom:Show()
	end
	for i=1,#module.db.classNames do
		local class = module.db.classNames[i]
		self.addSpellFrame.dropDown.List[#self.addSpellFrame.dropDown.List + 1] = {
			text = "|c"..ExRT.F.classColor(class)..L.classLocalizate[class],
			justifyH = "CENTER",
			func = self.addSpellFrame.dropDown.SetValue,
			arg1 = class,
		}
	end
	for i,noClassData in ipairs({{"PET",L.classLocalizate["PET"]},{"RACIAL",L.cd2Racial},{"ITEMS",L.cd2Items}}) do
		self.addSpellFrame.dropDown.List[#self.addSpellFrame.dropDown.List + 1] = {
			text = "|c"..ExRT.F.classColor(noClassData[1])..noClassData[2],
			justifyH = "CENTER",
			func = self.addSpellFrame.dropDown.SetValue,
			arg1 = noClassData[1],
		}
	end
	self.addSpellFrame.dropDown.Lines = #self.addSpellFrame.dropDown.List
	
	local function AddSpellFrameButtonsOnEnter(self)
		self:SetBackdropBorderColor(1,1,1,0.5)
		GameTooltip:SetOwner(self, "ANCHOR_LEFT")
		
		local isItem = nil
		for itemID,spellID in pairs(module.db.itemsToSpells) do
			if spellID == self.line[1] then
				isItem = itemID
				break
			end
		end
		
		if not isItem then
			GameTooltip:SetHyperlink(self.spellLink)
		else
			local _,itemLink = GetItemInfo(isItem)
			GameTooltip:SetHyperlink(itemLink or self.spellLink)
		end
		GameTooltip:AddLine(" ")
		
		local className = module.options.addSpellFrame.class
		if module.db.specByClass[className] then
			for i=1,#module.db.specByClass[className] do
				if self.line[2+i] then
					local icon = ""
					if module.db.specIcons[module.db.specByClass[className][i]] then
						icon = "|T".. module.db.specIcons[module.db.specByClass[className][i]] ..":20|t"
					else
						icon = ExRT.F.classIconInText(className,20) or ""
					end
					GameTooltip:AddLine(icon.." |c"..ExRT.F.classColor(className)..L.specLocalizate[module.db.specInLocalizate[module.db.specByClass[className][i]]].. ":|r|cffffffff "..L.cd2AddSpellFrameCDText.." "..format("%d:%02d",self.line[i+2][2]/60,self.line[i+2][2]%60).. (self.line[i+2][3] > 0 and ", "..L.cd2AddSpellFrameDurationText.." "..self.line[i+2][3] or ""))
				end
			end
		elseif className == "PET" then
			for petName,petData in pairs(module.db.petsAbilities) do
				for j=2,#petData do
					if petData[j][1] == self.line[1] then
						local petNameInTooltip = petName
						if tonumber(petNameInTooltip) then
							petNameInTooltip = L.creatureNames[tonumber(petNameInTooltip)]
						end
						GameTooltip:AddLine((ExRT.F.classIconInText(self.line[3],20) or "").." |c"..ExRT.F.classColor(self.line[3])..petNameInTooltip.. ":|r|cffffffff "..L.cd2AddSpellFrameCDText.." "..format("%d:%02d",petData[j][2]/60,petData[j][2]%60).. (petData[j][3] and ", "..L.cd2AddSpellFrameDurationText.." "..petData[j][3] or ""))
						break
					end
				end
			end
		else
			GameTooltip:AddLine("|cffffffff"..L.cd2AddSpellFrameCDText.." "..self.line[3][2].. (self.line[3][3] > 0 and ", "..L.cd2AddSpellFrameDurationText.." "..self.line[3][3] or ""))
		end
		GameTooltip:AddLine("|cffffffff"..L.cd2AddSpellFrameColumnText..": ".. self.colNum .."|r")
		if module.db.spell_isTalent[self.line[1]] and not className == "ITEMS" then
			GameTooltip:AddLine("|cffffffff"..L.cd2AddSpellFrameTalent.."|r")
		end
		if module.db.spell_durationByTalent_fix[self.line[1]] then
			GameTooltip:AddLine("|cffaaffaa"..L.cd2AddSpellFrameDuration..":|r")
			for j=1,#module.db.spell_durationByTalent_fix[self.line[1]],2 do
				local sname = GetSpellInfo(module.db.spell_durationByTalent_fix[self.line[1]][j]) or "???"
				local cd = module.db.spell_durationByTalent_fix[self.line[1]][j+1]
				if not tonumber(cd) then
					cd = tonumber(string.sub(cd,2))
					if cd < 1 then
						cd = "-"..( (1-cd)*100 ).."%"
					else
						cd = "+"..( (cd-1)*100 ).."%"
					end
				end
				GameTooltip:AddLine("|cffffffff - "..sname .." (".. (tonumber(cd) and cd > 0 and "+" or "").. cd ..")|r")
				
				ELib.Tooltip:Add("spell:"..module.db.spell_durationByTalent_fix[self.line[1]][j])
			end
			
		end
		do
			local cdByTalent_fix = nil
			local readiness_lines = {}
			if module.db.spell_cdByTalent_fix[self.line[1]] then
				cdByTalent_fix = true
				for j=1,#module.db.spell_cdByTalent_fix[self.line[1]],2 do
					local sname = GetSpellInfo(module.db.spell_cdByTalent_fix[self.line[1]][j]) or "???"
					local cd = module.db.spell_cdByTalent_fix[self.line[1]][j+1]
					if not tonumber(cd) then
						cd = tonumber(string.sub(cd,2))
						if cd < 1 then
							cd = "-"..( (1-cd)*100 ).."%"
						else
							cd = "+"..( (cd-1)*100 ).."%"
						end
					end
					table.insert(readiness_lines,"|cffffffff - "..sname .." (".. (tonumber(cd) and cd > 0 and "+" or "").. cd ..")|r")
					
					ELib.Tooltip:Add("spell:"..module.db.spell_cdByTalent_fix[self.line[1]][j])
				end
			end
			if cdByTalent_fix then
				GameTooltip:AddLine("|cffffaaaa"..L.cd2AddSpellFrameCDChange..": |r")
				for j=1,#readiness_lines do
					GameTooltip:AddLine(readiness_lines[j])
				end
			end
		end
		if module.db.spell_charge_fix[self.line[1]] then
			if module.db.spell_charge_fix[self.line[1]] == 1 then
				GameTooltip:AddLine("|cffffffaa"..L.cd2AddSpellFrameCharge.."|r")
			else
				GameTooltip:AddLine("|cffffffaa"..L.cd2AddSpellFrameChargeChange..":|r")
				local sname = GetSpellInfo(module.db.spell_charge_fix[self.line[1]]) or "???"
				GameTooltip:AddLine("|cffffffff - "..sname .."|r")
			end
		end
		do
			for auraID,sID in pairs(module.db.spell_aura_list) do
				if sID == self.line[1] then
					local sname = GetSpellInfo(auraID) or "???"
					GameTooltip:AddLine("|cffaaffaa"..L.cd2AddSpellFrameDurationLost..":|r")
					GameTooltip:AddLine("|cffffffff - \""..sname.."\"|r")
				end
			end
		end
		if module.db.spell_sharingCD[self.line[1]] then
			GameTooltip:AddLine("|cffffffaa"..L.cd2AddSpellFrameSharing..": |r")
			for otherID,otherCD in pairs(module.db.spell_sharingCD[self.line[1]]) do
				local sname = GetSpellInfo(otherID) or "???"
				GameTooltip:AddLine("|cffffffff - "..sname .." (".. otherCD ..")|r")
			end
		end
		if module.db.spell_dispellsList[self.line[1]] then
			GameTooltip:AddLine("|cffffffaa"..L.cd2AddSpellFrameDispel.."|r")
		end
		if module.db.spell_talentReplaceOther[self.line[1]] then
			local sname = GetSpellInfo(module.db.spell_talentReplaceOther[self.line[1]]) or "???"
			GameTooltip:AddLine("|cffffaaaa"..L.cd2AddSpellFrameReplace .." ".. sname .."|r")
		end
		GameTooltip:Show()
	end
	local function AddSpellFrameButtonsOnLeave(self)
	  	self:SetBackdropBorderColor(1,1,1,0)
	  	GameTooltip_Hide()
	  	ELib.Tooltip:HideAdd()
	end
	local function AddSpellFrameButtonsOnClick(self)
		if not self.disabled then
			local class = module.options.addSpellFrame.class
			module.options:addNewSpell((class == "RACIAL" or class == "ITEMS") and "ALL" or class,self.line)
			module.options.addSpellFrame:Hide()
		end
	end
	
	self.addSpellFrame.buttonsMax = 0
	for classNum=1,#module.db.classNames do
		local now = #module.db.allClassSpells[ module.db.classNames[classNum] ]
		self.addSpellFrame.buttonsMax = max(self.addSpellFrame.buttonsMax,now)
	end
	self.addSpellFrame.buttonsMax = max(self.addSpellFrame.buttonsMax,#module.db.allClassSpells["PET"])
	self.addSpellFrame:SetHeight( 82 + 35 * ceil( self.addSpellFrame.buttonsMax / 4 ) )
	
	self.addSpellFrame.buttons = {}
	for i=1,self.addSpellFrame.buttonsMax do
		local buttonFrame = CreateFrame("Button",nil,self.addSpellFrame)
		self.addSpellFrame.buttons[i] = buttonFrame
		buttonFrame:SetPoint("TOPLEFT",(i-1)%4 * 130 + 15,-floor((i-1)/4) * 35 - 60)
		buttonFrame:SetSize(130,35)
		buttonFrame:SetBackdrop({edgeFile = ExRT.F.defBorder, edgeSize = 8})
		buttonFrame:SetBackdropBorderColor(1,1,1,0)
		
		buttonFrame:SetScript("OnEnter",AddSpellFrameButtonsOnEnter)
		buttonFrame:SetScript("OnLeave",AddSpellFrameButtonsOnLeave)
		
		buttonFrame:SetScript("OnClick",AddSpellFrameButtonsOnClick)
		
		buttonFrame.icon = buttonFrame:CreateTexture(nil, "BACKGROUND")
		buttonFrame.icon:SetSize(24,24)
		buttonFrame.icon:SetPoint("TOPLEFT",5,-5)
		
		buttonFrame.text = ELib:Text(buttonFrame,"",12):Size(99,31):Point(33,-2):Color():Shadow()
	end

	function module.options:addNewSpell(class,line,doNotScroll)
		local sbmin,sbmax = module.options.ScrollBar:GetMinMaxValues()
		--module.options.ScrollBar:SetMinMaxValues(sbmin,sbmax+1)
		if line then
			if class ~= "PET" then
				module.db.spellDB[#module.db.spellDB+1] = {line[1],class,line[3],line[4],line[5],line[6],line[7],user=true}
				for j=3,7 do
					if line[j] and not VExRT.ExCD2.CDECol[ line[j][1] .. ";" .. (j-2) ] then
						VExRT.ExCD2.CDECol[ line[j][1] .. ";" .. (j-2) ] = line[2]
					end
				end
			else
				local cd,dur = 0,0
				for petName,petData in pairs(module.db.petsAbilities) do
					for j=2,#petData do
						if petData[j][1] == line[1] then
							cd = petData[j][2]
							dur = petData[j][3] or 0
							break
						end
					end
				end
				module.db.spellDB[#module.db.spellDB+1] = {line[1],line[3],{line[1],cd,dur},user=true}
				if not VExRT.ExCD2.CDECol[ line[1] .. ";1" ] then
					VExRT.ExCD2.CDECol[ line[1] .. ";1" ] = line[2]
				end
			end
		else
			module.db.spellDB[#module.db.spellDB+1] = {0,class,user=true}
		end
		module.options.ScrollBar:UpdateRange()
		if not doNotScroll then
			module.options.ScrollBar:SetValue(sbmax+31)
		end
		SyncUserDB()
		UpdateRoster()
	end
	
	self.addSpellFrame.OnShow = function (self)
		self.dropDown:SetValue(self.class or "WARRIOR")
	end
	
	self.tab.tabs[1].decorationLine = CreateFrame("Frame",nil,self.tab.tabs[1])
	self.tab.tabs[1].decorationLine.texture = self.tab.tabs[1].decorationLine:CreateTexture(nil, "BACKGROUND")
	self.tab.tabs[1].decorationLine:SetPoint("TOPLEFT",self.tab.tabs[1],-6,-8)
	self.tab.tabs[1].decorationLine:SetPoint("BOTTOMRIGHT",self.tab.tabs[1],"TOPRIGHT",8,-28)
	self.tab.tabs[1].decorationLine.texture:SetAllPoints()
	self.tab.tabs[1].decorationLine.texture:SetTexture(1,1,1,1)
	self.tab.tabs[1].decorationLine.texture:SetGradientAlpha("VERTICAL",.24,.25,.30,1,.27,.28,.33,1)
	
	self.tab1tab = ELib:Tabs(self.tab.tabs[1],0,L.cd2Spells,L.cd2Columns):Size(600,100):Point(0,0)
	self.tab1tab:SetBackdrop({})
	local function SetFirstTabFrame(self)
		if self._i == 1 then
			module.options.borderList:Show()
			module.options.colsSpells:Hide()
		else
			module.options.borderList:Hide()
			module.options.colsSpells:Show()		
		end
	end
	for i=1,2 do
		local frame = self.tab1tab.tabs[i].button
		frame:ClearAllPoints()
		if i == 1 then
			frame:SetPoint("TOPLEFT",self.tab.tabs[1],"TOPLEFT",10,-4)
		else
			frame:SetPoint("LEFT", self.tab1tab.tabs[1].button, "RIGHT", 0, 0)
		end
		frame._i = i
		frame.additionalFunc = SetFirstTabFrame
	end
	
	self.colsSpells = CreateFrame("Frame",nil,self.tab.tabs[1])
	self.colsSpells:SetSize(650,self.spellsPerPage*31+3)
	self.colsSpells:SetPoint("TOP", 0, -38)
	self.colsSpells:SetBackdrop({bgFile = "Interface/Tooltips/UI-Tooltip-Background",edgeFile = ExRT.F.defBorder,tile = false,edgeSize = 8})
	self.colsSpells:SetBackdropColor(0,0,0,0.3)
	self.colsSpells:SetBackdropBorderColor(.24,.25,.30,1)
	self.colsSpells:Hide()
	
	self.colsSpells.ScrollFrame = CreateFrame("ScrollFrame", nil, self.colsSpells)
	self.colsSpells.ScrollFrame:SetPoint("TOP",0,-3)
	self.colsSpells.ScrollFrame:SetSize(self.colsSpells:GetWidth(),self.colsSpells:GetHeight()-8)
	
	self.colsSpells.C = CreateFrame("Frame", nil, self.colsSpells) 
	self.colsSpells.C:SetSize(603-16, self.spellsPerPage*31+100) 
	self.colsSpells.ScrollFrame:SetScrollChild(self.colsSpells.C)
	
	local function ColsSpellsUpdate()
		local val = self.colsSpells.ScrollBar:GetValue()
		module.options.colsSpells.ScrollFrame:SetVerticalScroll( (val * 24) % 24 )
		val = floor( val )
		local line = 0
		local count = 0
		for i=1,#module.db.spellDB do
			local spellData = module.db.spellDB[i]
			local spellID = spellData[1]
			if VExRT_CDE[ spellID ] then
				local class = spellData[2]
				local specsCount = module.db.specByClass[class] and #module.db.specByClass[class] or 1
			
				for j=3,3+specsCount do
					if spellData[j] then
						count = count + 1
						if count >= val then
							line = line + 1
							if line > #self.colsSpells.lines then
								return
							end
							local lineFrame = self.colsSpells.lines[line]
							lineFrame:Show()
							
							local spellName,_,spellTexture = GetSpellInfo(spellID)
							lineFrame.icon:SetTexture(spellTexture)
							lineFrame.spellName:SetText(spellName)
							lineFrame.link = "spell:"..(spellData[j][1] or spellID)
							
							if j == 3 then
								lineFrame.iconSpec:Hide()
							else
								lineFrame.iconSpec:Show()
								lineFrame.iconSpec:SetTexture( module.db.specIcons[ module.db.specByClass[class][j - 2] ] or "" )
							end
							
							if CLASS_ICON_TCOORDS[class] then
								lineFrame.iconClass:SetTexture("Interface\\GLUES\\CHARACTERCREATE\\UI-CHARACTERCREATE-CLASSES")
								lineFrame.iconClass:SetTexCoord(unpack(CLASS_ICON_TCOORDS[class]))
							else
								lineFrame.iconClass:SetTexture("")
							end
							
							for k=1,10 do
								lineFrame.chk[k]:SetChecked(false)
							end
							local checked = VExRT.ExCD2.CDECol[spellData[j][1]..";"..(j-2)] or module.db.def_col[spellData[j][1]..";"..(j-2)] or 1
							lineFrame.chk[checked]:SetChecked(true)
							
							lineFrame.spellID = spellData[j][1]
							lineFrame.specNum = j-2
						end
					end
				end
			end
		end
		for i=line+1,#self.colsSpells.lines do
			self.colsSpells.lines[i]:Hide()
		end
	end
	self.colsSpells:SetScript("OnShow",function(self)
		local count = 0
		for i=1,#module.db.spellDB do
			local spellData = module.db.spellDB[i]
			if VExRT_CDE[ spellData[1] ] then
				local class = spellData[2]
				local specsCount = module.db.specByClass[class] and #module.db.specByClass[class] or 1
				for j=3,3+specsCount do
					if spellData[j] then
						count =  count + 1
					end
				end
			end
		end
	
		self.ScrollBar:SetMinMaxValues(1,max(1,count+1-21))
		ColsSpellsUpdate()
	end)
	self.colsSpells:SetScript("OnMouseWheel", function(self, delta)
		delta = -delta
		local current = module.options.colsSpells.ScrollBar:GetValue()
		local min_,max_ = module.options.colsSpells.ScrollBar:GetMinMaxValues()
		current = current + delta
		if current > max_ then
			current = max_
		elseif current < min_ then
			current = min_
		end
		module.options.colsSpells.ScrollBar:SetValue(current)
	end)
	
	self.colsSpells.ScrollBar = ELib:ScrollBar(self.colsSpells):Size(16,self.spellsPerPage*31-5):Point("TOPRIGHT",-3,-4):Range(1,21):OnChange(ColsSpellsUpdate)
	self.colsSpells.ScrollBar.slider:SetObeyStepOnDrag(true)
	
	self.colsSpells.lines = {}
	local function ColsSpellsSpellTooltipOnEnter(self)
		ELib.Tooltip.Link(self,self:GetParent().link)
	end
	local function ColsSpellsSpellCheckboxClick(self)
		for j=1,10 do
			if j ~= self._i then
				self.array[j]:SetChecked(false)
			end
		end
		if not self:GetChecked() then
			self:SetChecked(true)
		end
		VExRT.ExCD2.CDECol[self.main.spellID..";"..self.main.specNum] = self._i
		
		UpdateRoster()
	end
	for i=1,23 do
		local frame = CreateFrame("Frame",nil,self.colsSpells.C)
		self.colsSpells.lines[i] = frame
		frame:SetPoint("TOPLEFT",5,-3-(i-1)*24)
		frame:SetSize(577,24)
		
		frame.icon = frame:CreateTexture(nil, "ARTWORK")
		frame.icon:SetSize(24,24)
		frame.icon:SetPoint("TOPLEFT", 2, 0)
		
		frame.tooltipFrame = CreateFrame("Frame",nil,frame)
		frame.tooltipFrame:SetSize(150,24) 
		frame.tooltipFrame:SetPoint("TOPLEFT", 30, 0)
		frame.tooltipFrame:SetScript("OnEnter", ColsSpellsSpellTooltipOnEnter)
		frame.tooltipFrame:SetScript("OnLeave", GameTooltip_Hide)
		
		frame.spellName = ELib:Text(frame):Size(156,24):Point(29,0):Font(ExRT.F.defFont,11):Shadow():Color()
	
		frame.iconClass = frame:CreateTexture(nil, "ARTWORK")
		frame.iconClass:SetSize(18,18)
		frame.iconClass:SetPoint("TOPLEFT", 180, -3)
		
		frame.iconSpec = frame:CreateTexture(nil, "ARTWORK")
		frame.iconSpec:SetSize(18,18)
		frame.iconSpec:SetPoint("TOPLEFT", 200, -3)
		
		frame.chk = {}
		for j=1,10 do
			frame.chk[j] = ELib:Check(frame):Point("LEFT",240 + (j-1) * 25,0):Tooltip(j):OnClick(ColsSpellsSpellCheckboxClick)
			frame.chk[j].array = frame.chk
			frame.chk[j]._i = j
			frame.chk[j].main = frame
		end
	end
	
	module.options.ScrollBar:UpdateRange()
	module.options:ReloadSpellsPage()
	

	--> OPTIONS TAB2: Customize
	self.optColHeader = ELib:Text(self.tab.tabs[2],L.cd2ColSet):Size(560,20):Point(15,-8)
	
	function self:selectColumnTab()
		local i = self and self.colID or module.options.optColTabs.selected
		module.options.optColTabs.selected = i
		module.options.optColTabs:UpdateTabs()
		
		local isGeneralTab = i == (module.db.maxColumns + 1)
		
		if isGeneralTab then
			VExRT.ExCD2.colSet[i].frameGeneral = nil
			VExRT.ExCD2.colSet[i].iconGeneral = nil
			VExRT.ExCD2.colSet[i].textureGeneral = nil
			VExRT.ExCD2.colSet[i].fontGeneral = nil
			VExRT.ExCD2.colSet[i].textGeneral = nil
			VExRT.ExCD2.colSet[i].methodsGeneral = nil
		end

		module.options.optColSet.chkEnable:SetChecked(VExRT.ExCD2.colSet[i].enabled)
		module.options.optColSet.chkGeneral:SetChecked(VExRT.ExCD2.colSet[i].frameGeneral)
		
		module.options.optColSet.sliderLinesNum:SetValue(VExRT.ExCD2.colSet[i].frameLines or module.db.colsDefaults.frameLines)
		module.options.optColSet.sliderAlpha:SetValue(VExRT.ExCD2.colSet[i].frameAlpha or module.db.colsDefaults.frameAlpha)
		module.options.optColSet.sliderScale:SetValue(VExRT.ExCD2.colSet[i].frameScale or module.db.colsDefaults.frameScale)
		module.options.optColSet.sliderWidth:SetValue(VExRT.ExCD2.colSet[i].frameWidth or module.db.colsDefaults.frameWidth)
		module.options.optColSet.sliderColsInCol:SetValue(VExRT.ExCD2.colSet[i].frameColumns or module.db.colsDefaults.frameColumns)
		module.options.optColSet.sliderBetweenLines:SetValue(VExRT.ExCD2.colSet[i].frameBetweenLines or module.db.colsDefaults.frameBetweenLines)
		module.options.optColSet.sliderBlackBack:SetValue(VExRT.ExCD2.colSet[i].frameBlackBack or module.db.colsDefaults.frameBlackBack)
		
		module.options.optColSet.chkGeneral:doAlphas()
		
		module.options.optColSet.sliderHeight:SetValue(VExRT.ExCD2.colSet[i].iconSize or module.db.colsDefaults.iconSize)
		module.options.optColSet.chkGray:SetChecked(VExRT.ExCD2.colSet[i].iconGray)
		module.options.optColSet.chkCooldown:SetChecked(VExRT.ExCD2.colSet[i].methodsCooldown)	
		module.options.optColSet.chkShowTitles:SetChecked(VExRT.ExCD2.colSet[i].iconTitles)	
		module.options.optColSet.chkHideBlizzardEdges:SetChecked(VExRT.ExCD2.colSet[i].iconHideBlizzardEdges)	
		module.options.optColSet.chkGeneralIcons:SetChecked(VExRT.ExCD2.colSet[i].iconGeneral)
		do
			local defIconPos = VExRT.ExCD2.colSet[i].iconPosition or module.db.colsDefaults.iconPosition
			module.options.optColSet.dropDownIconPos:SetText( module.options.optColSet.dropDownIconPos.PosNames[defIconPos])	
		end
		
		module.options.optColSet.chkGeneralIcons:doAlphas()
		
		do
			local texturePos = nil
			for j=1,#ExRT.F.textureList do
				if ExRT.F.textureList[j] == (VExRT.ExCD2.colSet[i].textureFile or ExRT.F.barImg) then
					texturePos = j
					break
				end
			end
			if not texturePos and VExRT.ExCD2.colSet[i].textureFile then
				texturePos = select(3,string.find(VExRT.ExCD2.colSet[i].textureFile,"\\([^\\]*)$"))
			end
			texturePos = texturePos or "Standart"
			module.options.optColSet.dropDownTexture:SetText(L.cd2OtherSetTexture.." ["..texturePos.."]")
		end
		module.options.optColSet.colorPickerBorder.color:SetTexture(VExRT.ExCD2.colSet[i].textureBorderColorR or module.db.colsDefaults.textureBorderColorR,VExRT.ExCD2.colSet[i].textureBorderColorG or module.db.colsDefaults.textureBorderColorG,VExRT.ExCD2.colSet[i].textureBorderColorB or module.db.colsDefaults.textureBorderColorB, VExRT.ExCD2.colSet[i].textureBorderColorA or module.db.colsDefaults.textureBorderColorA)
		module.options.optColSet.sliderBorderSize:SetValue(VExRT.ExCD2.colSet[i].textureBorderSize or module.db.colsDefaults.textureBorderSize)
		module.options.optColSet.chkAnimation:SetChecked(VExRT.ExCD2.colSet[i].textureAnimation)
		module.options.optColSet.chkHideSpark:SetChecked(VExRT.ExCD2.colSet[i].textureHideSpark)
		module.options.optColSet.chkGeneralColorize:SetChecked(VExRT.ExCD2.colSet[i].textureGeneral)
		
		module.options.optColSet.chkGeneralColorize:doAlphas()
			
		do
			local FontNameForDropDown = select(3,string.find(VExRT.ExCD2.colSet[i].fontName or module.db.colsDefaults.fontName,"\\([^\\]*)$"))
			module.options.optColSet.dropDownFont:SetText( (FontNameForDropDown or VExRT.ExCD2.colSet[i].fontName or module.db.colsDefaults.fontName or "?") )
		end
		module.options.optColSet.sliderFont:SetValue(VExRT.ExCD2.colSet[i].fontSize or module.db.colsDefaults.fontSize)
		module.options.optColSet.chkFontOutline:SetChecked(VExRT.ExCD2.colSet[i].fontOutline)
		module.options.optColSet.chkFontShadow:SetChecked(VExRT.ExCD2.colSet[i].fontShadow)
		do
			module.options.optColSet.chkFontOtherAvailable:SetChecked(VExRT.ExCD2.colSet[i].fontOtherAvailable)
			module.options.fontOtherAvailable(VExRT.ExCD2.colSet[i].fontOtherAvailable)
			if VExRT.ExCD2.colSet[i].fontOtherAvailable then
				module.options.optColSet.nowFont = "fontLeft"
			else
				module.options.optColSet.nowFont = "font"
			end
			module.options.optColSet.fontsTab.selectFunc(module.options.optColSet.fontsTab.tabs[1].button)
		end
		module.options.optColSet.chkGeneralFont:SetChecked(VExRT.ExCD2.colSet[i].fontGeneral)
		
		module.options.optColSet.chkGeneralFont:doAlphas()
		
		module.options.optColSet.textLeftTemEdit:SetText(VExRT.ExCD2.colSet[i].textTemplateLeft or module.db.colsDefaults.textTemplateLeft)
		module.options.optColSet.textRightTemEdit:SetText(VExRT.ExCD2.colSet[i].textTemplateRight or module.db.colsDefaults.textTemplateRight)
		module.options.optColSet.textCenterTemEdit:SetText(VExRT.ExCD2.colSet[i].textTemplateCenter or module.db.colsDefaults.textTemplateCenter)
		module.options.optColSet.chkIconName:SetChecked(VExRT.ExCD2.colSet[i].textIconName)
		module.options.optColSet.chkGeneralText:SetChecked(VExRT.ExCD2.colSet[i].textGeneral)
		
		module.options.optColSet.chkGeneralText:doAlphas()

		module.options.optColSet.chkShowOnlyOnCD:SetChecked(VExRT.ExCD2.colSet[i].methodsShownOnCD)
		module.options.optColSet.chkBotToTop:SetChecked(VExRT.ExCD2.colSet[i].frameAnchorBottom)
		module.options.optColSet.chkGeneralMethods:SetChecked(VExRT.ExCD2.colSet[i].methodsGeneral)
		do
			local defStyleAnimation = VExRT.ExCD2.colSet[i].methodsStyleAnimation or module.db.colsDefaults.methodsStyleAnimation
			module.options.optColSet.dropDownStyleAnimation:SetText( module.options.optColSet.dropDownStyleAnimation.Styles[defStyleAnimation])
			local defTimeLineAnimation = VExRT.ExCD2.colSet[i].methodsTimeLineAnimation or module.db.colsDefaults.methodsTimeLineAnimation
			module.options.optColSet.dropDownTimeLineAnimation:SetText(module.options.optColSet.dropDownTimeLineAnimation.Styles[defTimeLineAnimation])
			
			local defSortingRules = VExRT.ExCD2.colSet[i].methodsSortingRules or module.db.colsDefaults.methodsSortingRules
			module.options.optColSet.dropDownSortingRules:SetText(module.options.optColSet.dropDownSortingRules.Rules[defSortingRules])			
		end
		module.options.optColSet.chkIconTooltip:SetChecked(VExRT.ExCD2.colSet[i].methodsIconTooltip)
		module.options.optColSet.chkLineClick:SetChecked(VExRT.ExCD2.colSet[i].methodsLineClick)
		module.options.optColSet.chkNewSpellNewLine:SetChecked(VExRT.ExCD2.colSet[i].methodsNewSpellNewLine)
		module.options.optColSet.chkHideOwnSpells:SetChecked(VExRT.ExCD2.colSet[i].methodsHideOwnSpells)
		module.options.optColSet.chkAlphaNotInRange:SetChecked(VExRT.ExCD2.colSet[i].methodsAlphaNotInRange)
		module.options.optColSet.sliderAlphaNotInRange:SetValue(VExRT.ExCD2.colSet[i].methodsAlphaNotInRangeNum or module.db.colsDefaults.methodsAlphaNotInRangeNum)
		module.options.optColSet.chkDisableActive:SetChecked(VExRT.ExCD2.colSet[i].methodsDisableActive)

		module.options.optColSet.chkGeneralMethods:doAlphas()
		
		module.options.optColSet.blacklistEditBox.EditBox:SetText(VExRT.ExCD2.colSet[i].blacklistText or module.db.colsDefaults.blacklistText)
		module.options.optColSet.whitelistEditBox.EditBox:SetText(VExRT.ExCD2.colSet[i].whitelistText or module.db.colsDefaults.whitelistText)
		module.options.optColSet.chkGeneralBlackList:SetChecked(VExRT.ExCD2.colSet[i].blacklistGeneral)		
		
		module.options.optColSet.chkGeneralBlackList:doAlphas()

		ExRT.lib.ShowOrHide(module.options.optColSet.chkEnable,not isGeneralTab)
		ExRT.lib.ShowOrHide(module.options.optColSet.chkGeneral,not isGeneralTab)

		ExRT.lib.ShowOrHide(module.options.optColSet.chkGeneralIcons,not isGeneralTab)
		ExRT.lib.ShowOrHide(module.options.optColSet.chkGeneralColorize,not isGeneralTab)
		ExRT.lib.ShowOrHide(module.options.optColSet.chkGeneralFont,not isGeneralTab)
		ExRT.lib.ShowOrHide(module.options.optColSet.chkGeneralText,not isGeneralTab)
		ExRT.lib.ShowOrHide(module.options.optColSet.chkGeneralMethods,not isGeneralTab)
		ExRT.lib.ShowOrHide(module.options.optColSet.chkGeneralBlackList,not isGeneralTab)
		
		ExRT.lib.ShowOrHide(module.options.optColSet.chkSortByAvailability,isGeneralTab)
		ExRT.lib.ShowOrHide(module.options.optColSet.chkSortByAvailability_activeToTop,isGeneralTab)
		ExRT.lib.ShowOrHide(module.options.optColSet.chkReverseSorting,isGeneralTab)
		
		module.options.showColorFrame(module.options.colorSetupFrame)
		
		if self then
			module.options.optColSet.templateRestore:Hide()
		end
	end

	self.optColSet = {}
	do
		local tmpArr = {}
		for i=1,module.db.maxColumns do
			tmpArr[i] = tostring(i)
		end
		tmpArr[module.db.maxColumns+1] = L.cd2GeneralSet
		self.optColTabs = ELib:Tabs(self.tab.tabs[2],0,unpack(tmpArr)):Size(660,417):Point(0,-48):SetTo(module.db.maxColumns+1)
	end
	for i=1,module.db.maxColumns+1 do
		self.optColTabs.tabs[i].button.colID = i
		self.optColTabs.tabs[i].button:SetScript("OnClick", self.selectColumnTab)
	end
	
	self.optColTabs:SetBackdropBorderColor(0,0,0,0)
	self.optColTabs:SetBackdropColor(0,0,0,0)
	
	self.tab.tabs[2].decorationLine = CreateFrame("Frame",nil,self.tab.tabs[2])
	self.tab.tabs[2].decorationLine.texture = self.tab.tabs[2].decorationLine:CreateTexture(nil, "BACKGROUND")
	self.tab.tabs[2].decorationLine:SetPoint("TOPLEFT",self.tab.tabs[2],-6,-28)
	self.tab.tabs[2].decorationLine:SetPoint("BOTTOMRIGHT",self.tab.tabs[2],"TOPRIGHT",8,-48)
	self.tab.tabs[2].decorationLine.texture:SetAllPoints()
	self.tab.tabs[2].decorationLine.texture:SetTexture(1,1,1,1)
	self.tab.tabs[2].decorationLine.texture:SetGradientAlpha("VERTICAL",.24,.25,.30,1,.27,.28,.33,1)

	 
	self.optColSet.superTabFrame = ExRT.lib:ScrollTabsFrame(self.optColTabs,L.cd2OtherSetTabNameGeneral,L.cd2OtherSetTabNameIcons,L.cd2OtherSetTabNameColors,L.cd2OtherSetTabNameFont,L.cd2OtherSetTabNameText,L.cd2OtherSetTabNameOther,L.cd2OtherSetTabNameBlackList,L.cd2OtherSetTabNameTemplate):Size(660,450):Point("TOP",0,-10)	
	
	self.optColSet.chkEnable = ELib:Check(self.optColSet.superTabFrame.tab[1],"|cff00ff00 >>>"..L.senable.."<<<"):Point(10,-10):OnClick(function(self) 
		if self:GetChecked() then
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].enabled = true
		else
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].enabled = nil
		end
		module:ReloadAllSplits()
	end)
	
	self.optColSet.chkGeneral = ELib:Check(self.optColSet.superTabFrame.tab[1],L.cd2ColSetGeneral):Point("TOPRIGHT",-10,-10):Left():OnClick(function(self) 
		if self:GetChecked() then
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].frameGeneral = true
		else
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].frameGeneral = nil
		end
		module:ReloadAllSplits()
		self:doAlphas()
	end)
	function self.optColSet.chkGeneral:doAlphas()
		ExRT.lib.SetAlphas(VExRT.ExCD2.colSet[module.options.optColTabs.selected].frameGeneral and module.options.optColTabs.selected ~= (module.db.maxColumns + 1) and 0.5 or 1,module.options.optColSet.sliderLinesNum,module.options.optColSet.sliderAlpha,module.options.optColSet.sliderScale,module.options.optColSet.sliderWidth,module.options.optColSet.sliderColsInCol,module.options.optColSet.sliderBetweenLines,module.options.optColSet.sliderBlackBack,module.options.optColSet.butToCenter)	
	end
	
	self.optColSet.sliderLinesNum = ELib:Slider(self.optColSet.superTabFrame.tab[1],L.cd2lines):Size(400):Point("TOP",0,-50):Range(1,module.db.maxLinesInCol):OnChange(function(self,event) 
		event = event - event%1
		VExRT.ExCD2.colSet[module.options.optColTabs.selected].frameLines = event
		self.tooltipText = event
		self:tooltipReload(self)
		module:ReloadAllSplits()		
	end)
	
	self.optColSet.sliderWidth = ELib:Slider(self.optColSet.superTabFrame.tab[1],L.cd2width):Size(400):Point("TOP",0,-85):Range(1,400):OnChange(function(self,event) 
		event = event - event%1
		VExRT.ExCD2.colSet[module.options.optColTabs.selected].frameWidth = event
		self.tooltipText = event
		self:tooltipReload(self)
		module:ReloadAllSplits()
	end)
	
	self.optColSet.sliderAlpha = ELib:Slider(self.optColSet.superTabFrame.tab[1],L.cd2alpha):Size(400):Point("TOP",0,-120):Range(0,100):OnChange(function(self,event) 
		event = event - event%1
		VExRT.ExCD2.colSet[module.options.optColTabs.selected].frameAlpha = event
		self.tooltipText = event
		self:tooltipReload(self)
		module:ReloadAllSplits()
	end)
	
	self.optColSet.sliderScale = ELib:Slider(self.optColSet.superTabFrame.tab[1],L.cd2scale):Size(400):Point("TOP",0,-155):Range(5,200):OnChange(function(self,event) 
		event = event - event%1
		VExRT.ExCD2.colSet[module.options.optColTabs.selected].frameScale = event
		self.tooltipText = event
		self:tooltipReload(self)
		module:ReloadAllSplits("ScaleFix")
	end)
	
	self.optColSet.sliderColsInCol = ELib:Slider(self.optColSet.superTabFrame.tab[1],L.cd2ColSetColsInCol):Size(400):Point("TOP",0,-190):Range(1,module.db.maxLinesInCol):OnChange(function(self,event) 
		event = event - event%1
		VExRT.ExCD2.colSet[module.options.optColTabs.selected].frameColumns = event
		self.tooltipText = event
		self:tooltipReload(self)
		module:ReloadAllSplits()
	end)
	
	self.optColSet.sliderBetweenLines = ELib:Slider(self.optColSet.superTabFrame.tab[1],L.cd2ColSetBetweenLines):Size(400):Point("TOP",0,-225):Range(0,20):OnChange(function(self,event) 
		event = event - event%1
		VExRT.ExCD2.colSet[module.options.optColTabs.selected].frameBetweenLines = event
		self.tooltipText = event
		self:tooltipReload(self)
		module:ReloadAllSplits()
	end)
	
	self.optColSet.sliderBlackBack = ELib:Slider(self.optColSet.superTabFrame.tab[1],L.cd2BlackBack):Size(400):Point("TOP",0,-260):Range(0,100):OnChange(function(self,event) 
		event = event - event%1
		VExRT.ExCD2.colSet[module.options.optColTabs.selected].frameBlackBack = event
		self.tooltipText = event
		self:tooltipReload(self)
		module:ReloadAllSplits()
	end)

	self.optColSet.butToCenter = ELib:Button(self.optColSet.superTabFrame.tab[1],L.cd2ColSetResetPos):Size(200,20):Point("TOP",0,-295):OnClick(function(self) 
		if (module.db.maxColumns + 1) == module.options.optColTabs.selected then
			module.frame:ClearAllPoints()
			module.frame:SetPoint("CENTER",UIParent,"CENTER",0,0)
		else
			module.frame.colFrame[module.options.optColTabs.selected]:ClearAllPoints()
			module.frame.colFrame[module.options.optColTabs.selected]:SetPoint("CENTER",UIParent,"CENTER",0,0)
		end
	end) 

	--> Icon and height options
	
	self.optColSet.sliderHeight = ELib:Slider(self.optColSet.superTabFrame.tab[2],L.cd2OtherSetIconSize):Size(400):Point("TOP",0,-50):Range(6,128):OnChange(function(self,event) 
		event = event - event%1
		VExRT.ExCD2.colSet[module.options.optColTabs.selected].iconSize = event
		module:ReloadAllSplits()
		self.tooltipText = event
		self:tooltipReload(self)
	end)
	
	self.optColSet.chkGray = ELib:Check(self.optColSet.superTabFrame.tab[2],L.cd2graytooltip):Point(10,-110):OnClick(function(self) 
		if self:GetChecked() then
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].iconGray = true
		else
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].iconGray = nil
		end
		module:ReloadAllSplits()
	end)
	
	self.optColSet.textIconPos = ELib:Text(self.optColSet.superTabFrame.tab[2],L.cd2OtherSetIconPosition..":"):Size(200,20):Point(10,-85)
	self.optColSet.dropDownIconPos = ELib:DropDown(self.optColSet.superTabFrame.tab[2],190,3):Size(200):Point(180,-85)
	self.optColSet.dropDownIconPos.PosNames = {L.cd2OtherSetIconPositionLeft,L.cd2OtherSetIconPositionRight,L.cd2OtherSetIconPositionNo}
	for i=1,#self.optColSet.dropDownIconPos.PosNames do
		self.optColSet.dropDownIconPos.List[i] = {
			text = self.optColSet.dropDownIconPos.PosNames[i],
			arg1 = i,
			func = function (self,arg)
				ELib:DropDownClose()
				VExRT.ExCD2.colSet[module.options.optColTabs.selected].iconPosition = arg
				module:ReloadAllSplits()
				module.options.optColSet.dropDownIconPos:SetText(module.options.optColSet.dropDownIconPos.PosNames[arg])
			end,
		}
	end
	
	self.optColSet.chkCooldown = ELib:Check(self.optColSet.superTabFrame.tab[2],L.cd2ColSetMethodCooldown):Point(10,-135):OnClick(function(self) 
		if self:GetChecked() then
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].methodsCooldown = true
		else
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].methodsCooldown = nil
		end
		module:ReloadAllSplits()
	end)
	
	self.optColSet.chkShowTitles = ELib:Check(self.optColSet.superTabFrame.tab[2],L.cd2ColSetShowTitles):Point(10,-160):OnClick(function(self) 
		if self:GetChecked() then
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].iconTitles = true
		else
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].iconTitles = nil
		end
		module:ReloadAllSplits()
	end)
	
	self.optColSet.chkHideBlizzardEdges = ELib:Check(self.optColSet.superTabFrame.tab[2],L.cd2ColSetIconHideBlizzardEdges):Point(10,-185):OnClick(function(self) 
		if self:GetChecked() then
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].iconHideBlizzardEdges = true
		else
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].iconHideBlizzardEdges = nil
		end
		module:ReloadAllSplits()
	end)
	
	self.optColSet.chkGeneralIcons = ELib:Check(self.optColSet.superTabFrame.tab[2],L.cd2ColSetGeneral):Point("TOPRIGHT",-10,-10):Left():OnClick(function(self) 
		if self:GetChecked() then
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].iconGeneral = true
		else
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].iconGeneral = nil
		end
		module:ReloadAllSplits()
		self:doAlphas()
	end)
	function self.optColSet.chkGeneralIcons:doAlphas()
		ExRT.lib.SetAlphas(VExRT.ExCD2.colSet[module.options.optColTabs.selected].iconGeneral and module.options.optColTabs.selected ~= (module.db.maxColumns + 1) and 0.5 or 1,module.options.optColSet.chkGray,module.options.optColSet.sliderHeight,module.options.optColSet.dropDownIconPos,module.options.optColSet.chkCooldown,module.options.optColSet.chkShowTitles,module.options.optColSet.chkHideBlizzardEdges)
	end
	
	--> Texture and colors Options
	
	local function dropDownTextureButtonClick(self,arg,name)
		ELib:DropDownClose()
		VExRT.ExCD2.colSet[module.options.optColTabs.selected].textureFile = arg
		module:ReloadAllSplits()
		module.options.optColSet.dropDownTexture:SetText(L.cd2OtherSetTexture.." ["..name.."]")
	end

	self.optColSet.textDDTexture = ELib:Text(self.optColSet.superTabFrame.tab[3],L.cd2OtherSetTexture..":"):Size(200,20):Point(10,-35)
	self.optColSet.dropDownTexture = ELib:DropDown(self.optColSet.superTabFrame.tab[3],200,15):Size(200):Point(180,-35)
	for i=1,#ExRT.F.textureList do
		self.optColSet.dropDownTexture.List[i] = {}
		local info = self.optColSet.dropDownTexture.List[i]
		info.text = i
		info.arg1 = ExRT.F.textureList[i]
		info.arg2 = i
		info.func = dropDownTextureButtonClick
		info.texture = ExRT.F.textureList[i]
		info.justifyH = "CENTER" 
	end
	if LibStub then
		local loaded,media = pcall(LibStub,"LibSharedMedia-3.0")
		if loaded and media then
			local barsList = media:HashTable("statusbar")
			if barsList then
				local count = #self.optColSet.dropDownTexture.List
				for key,texture in pairs(barsList) do
					count = count + 1
					self.optColSet.dropDownTexture.List[count] = {}
					local info = self.optColSet.dropDownTexture.List[count]
					
					info.text = key
					info.arg1 = texture
					info.arg2 = key
					info.func = dropDownTextureButtonClick
					info.texture = texture
					info.justifyH = "CENTER" 
				end
			end
		end
	end
	
	self.optColSet.textDDBorder = ELib:Text(self.optColSet.superTabFrame.tab[3],L.cd2OtherSetBorder..":"):Size(200,20):Point(10,-65)
	self.optColSet.sliderBorderSize = ELib:Slider(self.optColSet.superTabFrame.tab[3],""):Size(170):Point(180,-68):Range(0,20):OnChange(function(self,event) 
		event = event - event%1
		VExRT.ExCD2.colSet[module.options.optColTabs.selected].textureBorderSize = event
		self.tooltipText = event
		self:tooltipReload(self)
		module:ReloadAllSplits()
	end)
	self.optColSet.colorPickerBorder = ExRT.lib.CreateColorPickButton(self.optColSet.superTabFrame.tab[3],20,20,nil,361,-65)
	self.optColSet.colorPickerBorder:SetScript("OnClick",function (self)
		ColorPickerFrame.previousValues = {VExRT.ExCD2.colSet[module.options.optColTabs.selected].textureBorderColorR or module.db.colsDefaults.textureBorderColorR,VExRT.ExCD2.colSet[module.options.optColTabs.selected].textureBorderColorG or module.db.colsDefaults.textureBorderColorG,VExRT.ExCD2.colSet[module.options.optColTabs.selected].textureBorderColorB or module.db.colsDefaults.textureBorderColorB, VExRT.ExCD2.colSet[module.options.optColTabs.selected].textureBorderColorA or module.db.colsDefaults.textureBorderColorA}
		ColorPickerFrame.hasOpacity = true
		local nilFunc = ExRT.NULLfunc
		local function changedCallback(restore)
			local newR, newG, newB, newA
			if restore then
				newR, newG, newB, newA = unpack(restore)
			else
				newA, newR, newG, newB = OpacitySliderFrame:GetValue(), ColorPickerFrame:GetColorRGB()
			end
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].textureBorderColorR = newR
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].textureBorderColorG = newG
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].textureBorderColorB = newB
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].textureBorderColorA = newA
			module:ReloadAllSplits()
			
			self.color:SetTexture(newR,newG,newB,newA)
		end
		ColorPickerFrame.func, ColorPickerFrame.opacityFunc, ColorPickerFrame.cancelFunc = nilFunc, nilFunc, nilFunc
		ColorPickerFrame.opacity = VExRT.ExCD2.colSet[module.options.optColTabs.selected].textureBorderColorA or module.db.colsDefaults.textureBorderColorA
		ColorPickerFrame:SetColorRGB(VExRT.ExCD2.colSet[module.options.optColTabs.selected].textureBorderColorR or module.db.colsDefaults.textureBorderColorR,VExRT.ExCD2.colSet[module.options.optColTabs.selected].textureBorderColorG or module.db.colsDefaults.textureBorderColorG,VExRT.ExCD2.colSet[module.options.optColTabs.selected].textureBorderColorB or module.db.colsDefaults.textureBorderColorB)
		ColorPickerFrame.func, ColorPickerFrame.opacityFunc, ColorPickerFrame.cancelFunc = changedCallback, changedCallback, changedCallback
		ColorPickerFrame:Show()
	end)
		
	self.optColSet.chkAnimation = ELib:Check(self.optColSet.superTabFrame.tab[3],L.cd2OtherSetAnimation):Point(10,-97):OnClick(function(self) 
		if self:GetChecked() then
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].textureAnimation = true
		else
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].textureAnimation = nil
		end
		module:ReloadAllSplits()
	end)
	
	self.optColSet.chkHideSpark = ELib:Check(self.optColSet.superTabFrame.tab[3],L.cd2OtherSetHideSpark):Point(200,-97):OnClick(function(self) 
		if self:GetChecked() then
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].textureHideSpark = true
		else
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].textureHideSpark = nil
		end
		module:ReloadAllSplits()
	end)

	
	self.colorSetupFrame = CreateFrame("Frame",nil,self.optColSet.superTabFrame.tab[3])
	self.colorSetupFrame:SetSize(420,290)
	self.colorSetupFrame:SetPoint("TOP",0,-110)
		
	self.colorSetupFrame.backAlpha = ELib:Slider(self.colorSetupFrame,L.cd2OtherSetColorFrameAlpha):Size(400):Point("TOP",0,-163):Range(0,100)
	self.colorSetupFrame.backCDAlpha = ELib:Slider(self.colorSetupFrame,L.cd2OtherSetColorFrameAlphaCD):Size(400):Point("TOP",0,-198):Range(0,100)
	self.colorSetupFrame.backCooldownAlpha = ELib:Slider(self.colorSetupFrame,L.cd2OtherSetColorFrameAlphaCooldown):Size(400):Point("TOP",0,-233):Range(0,100)
	self.colorSetupFrame.backAlpha.inOptName = "textureAlphaBackground"
	self.colorSetupFrame.backCDAlpha.inOptName = "textureAlphaTimeLine"
	self.colorSetupFrame.backCooldownAlpha.inOptName = "textureAlphaCooldown"
	
	local function colorPickerButtonClick(self)
		ColorPickerFrame.previousValues = {VExRT.ExCD2.colSet[module.options.optColTabs.selected][self.inOptName.."R"] or module.db.colsDefaults[self.inOptName.."R"],VExRT.ExCD2.colSet[module.options.optColTabs.selected][self.inOptName.."G"] or module.db.colsDefaults[self.inOptName.."G"],VExRT.ExCD2.colSet[module.options.optColTabs.selected][self.inOptName.."B"] or module.db.colsDefaults[self.inOptName.."B"], 1}
		local nilFunc = ExRT.NULLfunc
		local function changedCallback(restore)
			local newR, newG, newB, newA
			if restore then
				newR, newG, newB, newA = unpack(restore)
			else
				newA, newR, newG, newB = OpacitySliderFrame:GetValue(), ColorPickerFrame:GetColorRGB()
			end
			VExRT.ExCD2.colSet[module.options.optColTabs.selected][self.inOptName.."R"] = newR
			VExRT.ExCD2.colSet[module.options.optColTabs.selected][self.inOptName.."G"] = newG
			VExRT.ExCD2.colSet[module.options.optColTabs.selected][self.inOptName.."B"] = newB
			module:ReloadAllSplits()
			
			self.color:SetTexture(newR,newG,newB,1)
		end
		ColorPickerFrame.func, ColorPickerFrame.opacityFunc, ColorPickerFrame.cancelFunc = nilFunc, nilFunc, nilFunc
		ColorPickerFrame:SetColorRGB(VExRT.ExCD2.colSet[module.options.optColTabs.selected][self.inOptName.."R"] or module.db.colsDefaults[self.inOptName.."R"],VExRT.ExCD2.colSet[module.options.optColTabs.selected][self.inOptName.."G"] or module.db.colsDefaults[self.inOptName.."G"],VExRT.ExCD2.colSet[module.options.optColTabs.selected][self.inOptName.."B"] or module.db.colsDefaults[self.inOptName.."B"])
		ColorPickerFrame.func, ColorPickerFrame.cancelFunc = changedCallback, changedCallback
		ColorPickerFrame:Show()
	end

	local function colorPickerSliderValue(self,newval)
		VExRT.ExCD2.colSet[module.options.optColTabs.selected][self.inOptName] = newval / 100
		module:ReloadAllSplits()
		self.tooltipText = ExRT.F.Round(newval)
		self:tooltipReload(self)
	end

	local function colorPickerCheckBoxClick(self)
		if self:GetChecked() then
			VExRT.ExCD2.colSet[module.options.optColTabs.selected][self.inOptName] = true
		else
			VExRT.ExCD2.colSet[module.options.optColTabs.selected][self.inOptName] = nil
		end
		module:ReloadAllSplits()
	end
	
	local colorSetupFrameColorsNames_TopText = {L.cd2OtherSetColorFrameTopText,L.cd2OtherSetColorFrameTopBack,L.cd2OtherSetColorFrameTopTimeLine}
	for i=1,3 do
		self.colorSetupFrame["topText"..i] = ELib:Text(self.colorSetupFrame,colorSetupFrameColorsNames_TopText[i],12):Size(50,20):Point(225+(i-1)*40,-15):Center():Color():Shadow()
	end
	
	local colorSetupFrameColorsNames_Text = {L.cd2OtherSetColorFrameText..":",L.cd2OtherSetColorFrameActive..":",L.cd2OtherSetColorFrameCooldown..":"}
	for j=1,3 do
		for i=1,3 do
			self.colorSetupFrame["color"..colorSetupFrameColorsObjectsNames[i]..colorSetupFrameColorsNames[j]] = ExRT.lib.CreateColorPickButton(self.colorSetupFrame,20,20,nil,240+(i-1)*40,-35-(j-1)*20)
			self.colorSetupFrame["color"..colorSetupFrameColorsObjectsNames[i]..colorSetupFrameColorsNames[j]].inOptName = "textureColor"..colorSetupFrameColorsObjectsNames[i]..colorSetupFrameColorsNames[j]
			self.colorSetupFrame["color"..colorSetupFrameColorsObjectsNames[i]..colorSetupFrameColorsNames[j]]:SetScript("OnClick",colorPickerButtonClick)
		end
		self.colorSetupFrame["text"..colorSetupFrameColorsNames[j]] = ELib:Text(self.colorSetupFrame,colorSetupFrameColorsNames_Text[j],12):Size(210,20):Point(10,-35-(j-1)*20):Right():Color():Shadow()
	end
	
	local checksInOptNames = {"textureClassText","textureClassBackground","textureClassTimeLine"}
	for i=1,3 do
		self.colorSetupFrame["colorClass"..colorSetupFrameColorsObjectsNames[i]] = ELib:Check(self.colorSetupFrame,""):Point(241+(i-1)*40,-117):Size(18,18):OnClick(colorPickerCheckBoxClick)	
		self.colorSetupFrame["colorClass"..colorSetupFrameColorsObjectsNames[i]].inOptName = checksInOptNames[i]
	end
	self.colorSetupFrame["textClass"] = ELib:Text(self.colorSetupFrame,L.cd2OtherSetColorFrameClass..":",12):Size(210,20):Point(10,-115):Right():Color():Shadow()
	
	self.colorSetupFrame.backAlpha:SetScript("OnValueChanged",colorPickerSliderValue)
	self.colorSetupFrame.backCDAlpha:SetScript("OnValueChanged",colorPickerSliderValue)
	self.colorSetupFrame.backCooldownAlpha:SetScript("OnValueChanged",colorPickerSliderValue)
	
	self.colorSetupFrame.resetButton = ELib:Button(self.colorSetupFrame,L.cd2OtherSetColorFrameReset):Size(160,20):Point("TOP",-81,-265)
	self.colorSetupFrame.softenButton = ELib:Button(self.colorSetupFrame,L.cd2OtherSetColorFrameSoften):Size(160,20):Point("TOP",81,-265)
	
	self.colorSetupFrame.softenButton:SetScript("OnClick",function()
		local tmpColors = {"R","G","B"}
		for j=1,3 do
			for i=1,3 do
				local maxColor = 0
				for n=1,3 do
					local color = VExRT.ExCD2.colSet[module.options.optColTabs.selected]["textureColor"..colorSetupFrameColorsObjectsNames[i]..colorSetupFrameColorsNames[j]..tmpColors[n]] or module.db.colsDefaults["textureColor"..colorSetupFrameColorsObjectsNames[i]..colorSetupFrameColorsNames[j]..tmpColors[n]]
					maxColor = max(maxColor,color)
				end
				for n=1,3 do
					local color = VExRT.ExCD2.colSet[module.options.optColTabs.selected]["textureColor"..colorSetupFrameColorsObjectsNames[i]..colorSetupFrameColorsNames[j]..tmpColors[n]] or module.db.colsDefaults["textureColor"..colorSetupFrameColorsObjectsNames[i]..colorSetupFrameColorsNames[j]..tmpColors[n]]
					if color < maxColor then
						VExRT.ExCD2.colSet[module.options.optColTabs.selected]["textureColor"..colorSetupFrameColorsObjectsNames[i]..colorSetupFrameColorsNames[j]..tmpColors[n]] = color + (maxColor - color) / 2
					end
				end
			end
		end
		module.options.showColorFrame(module.options.colorSetupFrame)
		module:ReloadAllSplits()
	end)
	
	self.colorSetupFrame.resetButton:SetScript("OnClick",function()
		local tmpColors = {"R","G","B"}
		for j=1,4 do
			for i=1,3 do
				for n=1,3 do
					VExRT.ExCD2.colSet[module.options.optColTabs.selected]["textureColor"..colorSetupFrameColorsObjectsNames[i]..colorSetupFrameColorsNames[j]..tmpColors[n]] = nil
				end
			end
		end
		VExRT.ExCD2.colSet[module.options.optColTabs.selected].textureAlphaBackground = nil
		VExRT.ExCD2.colSet[module.options.optColTabs.selected].textureAlphaTimeLine = nil
		VExRT.ExCD2.colSet[module.options.optColTabs.selected].textureAlphaCooldown = nil
		for i=1,3 do
			VExRT.ExCD2.colSet[module.options.optColTabs.selected][ checksInOptNames[i] ] = nil
		end
		module.options.showColorFrame(module.options.colorSetupFrame)
		module:ReloadAllSplits()
	end)
	
	function self:showColorFrame()
		for j=1,3 do
			for i=1,3 do
				local this = module.options.colorSetupFrame["color"..colorSetupFrameColorsObjectsNames[i]..colorSetupFrameColorsNames[j]]
				this.color:SetTexture(VExRT.ExCD2.colSet[module.options.optColTabs.selected][this.inOptName.."R"] or module.db.colsDefaults[this.inOptName.."R"],VExRT.ExCD2.colSet[module.options.optColTabs.selected][this.inOptName.."G"] or module.db.colsDefaults[this.inOptName.."G"],VExRT.ExCD2.colSet[module.options.optColTabs.selected][this.inOptName.."B"] or module.db.colsDefaults[this.inOptName.."B"],1)
			end
		end
		for i=1,3 do
			module.options.colorSetupFrame["colorClass"..colorSetupFrameColorsObjectsNames[i]]:SetChecked( VExRT.ExCD2.colSet[module.options.optColTabs.selected][ checksInOptNames[i] ] )
		end

		self.backAlpha:SetValue((VExRT.ExCD2.colSet[module.options.optColTabs.selected][self.backAlpha.inOptName] or module.db.colsDefaults[self.backAlpha.inOptName])*100)
		self.backCDAlpha:SetValue((VExRT.ExCD2.colSet[module.options.optColTabs.selected][self.backCDAlpha.inOptName] or module.db.colsDefaults[self.backCDAlpha.inOptName])*100)
		self.backCooldownAlpha:SetValue((VExRT.ExCD2.colSet[module.options.optColTabs.selected][self.backCooldownAlpha.inOptName] or module.db.colsDefaults[self.backCooldownAlpha.inOptName])*100)
	end

	self.colorSetupFrame:SetScript("OnShow",self.showColorFrame)

	
	self.optColSet.chkGeneralColorize = ELib:Check(self.optColSet.superTabFrame.tab[3],L.cd2ColSetGeneral):Point("TOPRIGHT",-10,-10):Left():OnClick(function(self) 
		if self:GetChecked() then
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].textureGeneral = true
		else
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].textureGeneral = nil
		end
		module:ReloadAllSplits()
		self:doAlphas()
	end)
	function self.optColSet.chkGeneralColorize:doAlphas()
		ExRT.lib.SetAlphas(VExRT.ExCD2.colSet[module.options.optColTabs.selected].textureGeneral and module.options.optColTabs.selected ~= (module.db.maxColumns + 1) and 0.5 or 1,module.options.optColSet.dropDownTexture,module.options.optColSet.chkAnimation,module.options.colorSetupFrame,module.options.optColSet.colorPickerBorder,module.options.optColSet.sliderBorderSize,module.options.optColSet.chkHideSpark)
	end	

	--> Font Options
	self.optColSet.nowFont = "font"
	
	self.optColSet.superTabFrame.tab[4].decorationLine = CreateFrame("Frame",nil,self.optColSet.superTabFrame.tab[4])
	self.optColSet.superTabFrame.tab[4].decorationLine.texture = self.optColSet.superTabFrame.tab[4].decorationLine:CreateTexture(nil, "BACKGROUND")
	self.optColSet.superTabFrame.tab[4].decorationLine:SetPoint("TOPLEFT",self.optColSet.superTabFrame.tab[4],0,-35)
	self.optColSet.superTabFrame.tab[4].decorationLine:SetPoint("BOTTOMRIGHT",self.optColSet.superTabFrame.tab[4],"TOPRIGHT",0,-55)
	self.optColSet.superTabFrame.tab[4].decorationLine.texture:SetAllPoints()
	self.optColSet.superTabFrame.tab[4].decorationLine.texture:SetTexture(1,1,1,1)
	self.optColSet.superTabFrame.tab[4].decorationLine.texture:SetGradientAlpha("VERTICAL",.24,.25,.30,1,.27,.28,.33,1)
	
	self.optColSet.fontsTab = ELib:Tabs(self.optColSet.superTabFrame.tab[4],0,L.cd2ColSetFontPosGeneral,L.cd2ColSetFontPosRight,L.cd2ColSetFontPosCenter,L.cd2ColSetFontPosIcon):Size(455,160):Point(0,-55)
	self.optColSet.fontsTab:SetBackdropBorderColor(0,0,0,0)
	self.optColSet.fontsTab:SetBackdropColor(0,0,0,0)
	local function fontsTabButtonClick(self)
		local tabFrame = self.mainFrame
		tabFrame.selected = self.id
		tabFrame.UpdateTabs(tabFrame)
		
		module.options.optColSet.nowFont = self.fontMark
		
		local i = module.options.optColTabs.selected
		do
			local FontNameForDropDown = select(3,string.find(VExRT.ExCD2.colSet[i][self.fontMark.."Name"] or module.db.colsDefaults.fontName,"\\([^\\]*)$"))
			module.options.optColSet.dropDownFont:SetText(  (FontNameForDropDown or VExRT.ExCD2.colSet[i][self.fontMark.."Name"] or module.db.colsDefaults.fontName or "?") )
		end
		module.options.optColSet.sliderFont:SetValue(VExRT.ExCD2.colSet[i][self.fontMark.."Size"] or module.db.colsDefaults.fontSize)
		module.options.optColSet.chkFontOutline:SetChecked(VExRT.ExCD2.colSet[i][self.fontMark.."Outline"])
		module.options.optColSet.chkFontShadow:SetChecked(VExRT.ExCD2.colSet[i][self.fontMark.."Shadow"])
	end
	for i=1,4 do
		self.optColSet.fontsTab.tabs[i].button:SetScript("OnClick",fontsTabButtonClick)
	end
	local fontOtherAvailableTable = {"Left","Right","Center","Icon"}
	function self.fontOtherAvailable(isAvailable)
		if isAvailable then
			for i=2,4 do
				self.optColSet.fontsTab.tabs[i].button:Show()
			end
			self.optColSet.fontsTab.tabs[1].button:SetText(L.cd2ColSetFontPosLeft)
			for i=1,4 do
				self.optColSet.fontsTab.tabs[i].button.fontMark = "font"..fontOtherAvailableTable[i]
			end
		else
			for i=2,4 do
				self.optColSet.fontsTab.tabs[i].button:Hide()
			end
			self.optColSet.fontsTab.tabs[1].button:SetText(L.cd2ColSetFontPosGeneral)
			self.optColSet.fontsTab.tabs[1].button.fontMark = "font"
		end
		self.optColSet.fontsTab.resizeFunc(self.optColSet.fontsTab.tabs[1].button, 0, nil, nil, self.optColSet.fontsTab.tabs[1].button:GetFontString():GetStringWidth(), self.optColSet.fontsTab.tabs[1].button:GetFontString():GetStringWidth())
		fontsTabButtonClick(module.options.optColSet.fontsTab.tabs[1].button)
	end
	
	self.optColSet.chkFontOtherAvailable = ELib:Check(self.optColSet.superTabFrame.tab[4],L.cd2ColSetFontOtherAvailable):Point(10,-220):OnClick(function(self) 
		if self:GetChecked() then
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].fontOtherAvailable = true --fontOtherAvailable
		else
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].fontOtherAvailable = nil
		end
		module:ReloadAllSplits()
		module.options.fontOtherAvailable( self:GetChecked() )
	end)

	self.optColSet.sliderFont = ELib:Slider(self.optColSet.fontsTab,L.cd2OtherSetFontSize):Size(400):Point("TOP",0,-60):Range(8,72):OnChange(function(self,event) 
		event = event - event%1
		VExRT.ExCD2.colSet[module.options.optColTabs.selected][module.options.optColSet.nowFont.."Size"] = event --fontSize
		module:ReloadAllSplits()
		self.tooltipText = event
		self:tooltipReload(self)
	end)

	self.optColSet.textDDFont = ELib:Text(self.optColSet.fontsTab,L.cd2OtherSetFont..":"):Size(200,20):Point(10,-15)

	local function dropDownFontButtonClick(self,arg1,arg2)
		ELib:DropDownClose()
		VExRT.ExCD2.colSet[module.options.optColTabs.selected][module.options.optColSet.nowFont.."Name"] = arg1 --fontName
		module:ReloadAllSplits()
		local FontNameForDropDown = select(3,string.find(arg1,"\\([^\\]*)$"))
		if arg2 <= #ExRT.F.fontList then
			module.options.optColSet.dropDownFont:SetText(FontNameForDropDown or ExRT.F.fontList[arg2])
		else
			module.options.optColSet.dropDownFont:SetText(FontNameForDropDown or arg2)
		end
	end
	
	self.optColSet.dropDownFont = ELib:DropDown(self.optColSet.fontsTab,350,10):Size(200):Point(180,-15)
	for i=1,#ExRT.F.fontList do
		self.optColSet.dropDownFont.List[i] = {}
		local info = self.optColSet.dropDownFont.List[i]
		info.text = ExRT.F.fontList[i]
		info.arg1 = ExRT.F.fontList[i]
		info.arg2 = i
		info.func = dropDownFontButtonClick
		info.font = ExRT.F.fontList[i]
		info.justifyH = "CENTER" 
	end
	if LibStub then
		local loaded,media = pcall(LibStub,"LibSharedMedia-3.0")
		if loaded and media then
			local fontList = media:HashTable("font")
			if fontList then
				local count = #self.optColSet.dropDownFont.List
				for key,font in pairs(fontList) do
					count = count + 1
					self.optColSet.dropDownFont.List[count] = {}
					local info = self.optColSet.dropDownFont.List[count]
					
					info.text = font
					info.arg1 = font
					info.arg2 = count
					info.func = dropDownFontButtonClick
					info.font = font
					info.justifyH = "CENTER" 
				end
			end
		end
	end
	
	self.optColSet.chkFontOutline = ELib:Check(self.optColSet.fontsTab,L.cd2OtherSetOutline):Point(10,-95):OnClick(function(self) 
		if self:GetChecked() then
			VExRT.ExCD2.colSet[module.options.optColTabs.selected][module.options.optColSet.nowFont.."Outline"] = true --fontOutline
		else
			VExRT.ExCD2.colSet[module.options.optColTabs.selected][module.options.optColSet.nowFont.."Outline"] = nil
		end
		module:ReloadAllSplits()
	end)
	
	self.optColSet.chkFontShadow = ELib:Check(self.optColSet.fontsTab,L.cd2OtherSetFontShadow):Point(10,-120):OnClick(function(self) 
		if self:GetChecked() then
			VExRT.ExCD2.colSet[module.options.optColTabs.selected][module.options.optColSet.nowFont.."Shadow"] = true -- fontShadow
		else
			VExRT.ExCD2.colSet[module.options.optColTabs.selected][module.options.optColSet.nowFont.."Shadow"] = nil
		end
		module:ReloadAllSplits()
	end)

	self.optColSet.chkGeneralFont = ELib:Check(self.optColSet.superTabFrame.tab[4],L.cd2ColSetGeneral):Point("TOPRIGHT",-10,-10):Left():OnClick(function(self) 
		if self:GetChecked() then
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].fontGeneral = true
		else
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].fontGeneral = nil
		end
		module:ReloadAllSplits()
		self:doAlphas()
	end)	
	function self.optColSet.chkGeneralFont:doAlphas()
		ExRT.lib.SetAlphas(VExRT.ExCD2.colSet[module.options.optColTabs.selected].fontGeneral and module.options.optColTabs.selected ~= (module.db.maxColumns + 1) and 0.5 or 1,module.options.optColSet.dropDownFont,module.options.optColSet.sliderFont,module.options.optColSet.chkFontOutline,module.options.optColSet.chkFontShadow)
	end
	
	--> Text options
	
	self.optColSet.textLeftTemText = ELib:Text(self.optColSet.superTabFrame.tab[5],L.cd2ColSetTextLeft..":"):Size(200,20):Point(10,-40)
	self.optColSet.textLeftTemEdit = ELib:Edit(self.optColSet.superTabFrame.tab[5]):Size(220,20):Point(180,-40):OnChange(function(self,isUser)
		if isUser then
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].textTemplateLeft = self:GetText()
			module:ReloadAllSplits()
		end
	end)
	
	self.optColSet.textRightTemText = ELib:Text(self.optColSet.superTabFrame.tab[5],L.cd2ColSetTextRight..":"):Size(200,20):Point(10,-65)
	self.optColSet.textRightTemEdit = ELib:Edit(self.optColSet.superTabFrame.tab[5]):Size(220,20):Point(180,-65):OnChange(function(self,isUser)
		if isUser then
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].textTemplateRight = self:GetText()
			module:ReloadAllSplits()
		end
	end)
	
	self.optColSet.textCenterTemText = ELib:Text(self.optColSet.superTabFrame.tab[5],L.cd2ColSetTextCenter..":"):Size(200,20):Point(10,-90)
	self.optColSet.textCenterTemEdit = ELib:Edit(self.optColSet.superTabFrame.tab[5]):Size(220,20):Point(180,-90):OnChange(function(self,isUser)
		if isUser then
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].textTemplateCenter = self:GetText()
			module:ReloadAllSplits()
		end
	end)
	
	self.optColSet.textAllTemplates = ELib:Text(self.optColSet.superTabFrame.tab[5],L.cd2ColSetTextTooltip,11):Size(450,200):Point(10,-115):Top():Color()

	self.optColSet.textResetButton = ELib:Button(self.optColSet.superTabFrame.tab[5],L.cd2ColSetTextReset):Size(340,20):Point("TOP",0,-225):OnClick(function(self)
		VExRT.ExCD2.colSet[module.options.optColTabs.selected].textTemplateLeft = nil
		VExRT.ExCD2.colSet[module.options.optColTabs.selected].textTemplateRight = nil
		VExRT.ExCD2.colSet[module.options.optColTabs.selected].textTemplateCenter = nil
		module:ReloadAllSplits()
		module.options.optColSet.textLeftTemEdit:SetText(module.db.colsDefaults.textTemplateLeft)
		module.options.optColSet.textRightTemEdit:SetText(module.db.colsDefaults.textTemplateRight)
		module.options.optColSet.textCenterTemEdit:SetText(module.db.colsDefaults.textTemplateCenter)
	end)
	
	self.optColSet.chkIconName = ELib:Check(self.optColSet.superTabFrame.tab[5],L.cd2ColSetTextIconName):Point(10,-250):OnClick(function(self) 
		if self:GetChecked() then
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].textIconName = true
		else
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].textIconName = nil
		end
		module:ReloadAllSplits()
	end)
	
	self.optColSet.chkGeneralText = ELib:Check(self.optColSet.superTabFrame.tab[5],L.cd2ColSetGeneral):Point("TOPRIGHT",-10,-10):Left():OnClick(function(self) 
		if self:GetChecked() then
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].textGeneral = true
		else
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].textGeneral = nil
		end
		module:ReloadAllSplits()
		self:doAlphas()
	end)
	function self.optColSet.chkGeneralText:doAlphas()
		ExRT.lib.SetAlphas(VExRT.ExCD2.colSet[module.options.optColTabs.selected].textGeneral and module.options.optColTabs.selected ~= (module.db.maxColumns + 1) and 0.5 or 1,module.options.optColSet.textLeftTemEdit,module.options.optColSet.textRightTemEdit,module.options.optColSet.textCenterTemEdit,module.options.optColSet.chkIconName,module.options.optColSet.textAllTemplates,module.options.optColSet.textLeftTemText,module.options.optColSet.textRightTemText,module.options.optColSet.textCenterTemText,module.options.optColSet.textResetButton)
	end

	--> Method options
	
	self.optColSet.chkShowOnlyOnCD = ELib:Check(self.optColSet.superTabFrame.tab[6],L.cd2OtherSetOnlyOnCD):Point(10,-30):OnClick(function(self) 
		if self:GetChecked() then
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].methodsShownOnCD = true
		else
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].methodsShownOnCD = nil
		end
		module:ReloadAllSplits()
	end)
	
	self.optColSet.chkBotToTop = ELib:Check(self.optColSet.superTabFrame.tab[6],L.cd2ColSetBotToTop):Point(10,-55):OnClick(function(self) 
		if self:GetChecked() then
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].frameAnchorBottom = true
		else
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].frameAnchorBottom = nil
		end
		module:ReloadAllSplits()
	end)
	
	self.optColSet.textStyleAnimation = ELib:Text(self.optColSet.superTabFrame.tab[6],L.cd2OtherSetStyleAnimation..":",11):Size(200,20):Point(10,-80)
	self.optColSet.dropDownStyleAnimation = ELib:DropDown(self.optColSet.superTabFrame.tab[6],205,2):Size(220):Point(180,-80)
	self.optColSet.dropDownStyleAnimation.Styles = {L.cd2OtherSetStyleAnimation1,L.cd2OtherSetStyleAnimation2}
	for i=1,#self.optColSet.dropDownStyleAnimation.Styles do
		self.optColSet.dropDownStyleAnimation.List[i] = {
			text = self.optColSet.dropDownStyleAnimation.Styles[i],
			arg1 = i,
			func = function (self,arg)
				ELib:DropDownClose()
				VExRT.ExCD2.colSet[module.options.optColTabs.selected].methodsStyleAnimation = arg
				module:ReloadAllSplits()
				self:GetParent().parent:SetText(module.options.optColSet.dropDownStyleAnimation.Styles[arg])
			end
		}
	end

	self.optColSet.textTimeLineAnimation = ELib:Text(self.optColSet.superTabFrame.tab[6],L.cd2OtherSetTimeLineAnimation..":",11):Size(200,20):Point(10,-105)
	self.optColSet.dropDownTimeLineAnimation = ELib:DropDown(self.optColSet.superTabFrame.tab[6],205,2):Size(220):Point(180,-105)
	self.optColSet.dropDownTimeLineAnimation.Styles = {L.cd2OtherSetTimeLineAnimation1,L.cd2OtherSetTimeLineAnimation2}
	for i=1,#self.optColSet.dropDownTimeLineAnimation.Styles do
		self.optColSet.dropDownTimeLineAnimation.List[i] = {
			text = self.optColSet.dropDownTimeLineAnimation.Styles[i],
			arg1 = i,
			func = function (self,arg)
				ELib:DropDownClose()
				VExRT.ExCD2.colSet[module.options.optColTabs.selected].methodsTimeLineAnimation = arg
				module:ReloadAllSplits()
				self:GetParent().parent:SetText(module.options.optColSet.dropDownTimeLineAnimation.Styles[arg])
			end
		}
	end
	
	self.optColSet.chkIconTooltip = ELib:Check(self.optColSet.superTabFrame.tab[6],L.cd2OtherSetIconToolip):Point(10,-130):OnClick(function(self) 
		if self:GetChecked() then
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].methodsIconTooltip = true
		else
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].methodsIconTooltip = nil
		end
		module:ReloadAllSplits()
	end)
		
	self.optColSet.chkLineClick = ELib:Check(self.optColSet.superTabFrame.tab[6],L.cd2OtherSetLineClick):Point(10,-155):OnClick(function(self) 
		if self:GetChecked() then
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].methodsLineClick = true
		else
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].methodsLineClick = nil
		end
		module:ReloadAllSplits()
	end)
	
	
	self.optColSet.chkNewSpellNewLine = ELib:Check(self.optColSet.superTabFrame.tab[6],L.cd2NewSpellNewLine):Point(10,-180):Tooltip(L.cd2NewSpellNewLineTooltip):OnClick(function(self) 
		if self:GetChecked() then
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].methodsNewSpellNewLine = true
		else
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].methodsNewSpellNewLine = nil
		end
		module:ReloadAllSplits()
	end)
	
	self.optColSet.textSortingRules= ELib:Text(self.optColSet.superTabFrame.tab[6],L.cd2MethodsSortingRules..":",11):Size(200,20):Point(10,-205)
	self.optColSet.dropDownSortingRules = ELib:DropDown(self.optColSet.superTabFrame.tab[6],405,6):Size(220):Point(180,-205)
	self.optColSet.dropDownSortingRules.Rules = {L.cd2MethodsSortingRules1,L.cd2MethodsSortingRules2,L.cd2MethodsSortingRules3,L.cd2MethodsSortingRules4,L.cd2MethodsSortingRules5,L.cd2MethodsSortingRules6}
	for i=1,#self.optColSet.dropDownSortingRules.Rules do
		self.optColSet.dropDownSortingRules.List[i] = {
			text = self.optColSet.dropDownSortingRules.Rules[i],
			arg1 = i,
			func = function (self,arg)
				ELib:DropDownClose()
				VExRT.ExCD2.colSet[module.options.optColTabs.selected].methodsSortingRules = arg
				module:ReloadAllSplits()
				module.main:GROUP_ROSTER_UPDATE()
				self:GetParent().parent:SetText(module.options.optColSet.dropDownSortingRules.Rules[arg])
			end
		}
	end
	
	self.optColSet.chkHideOwnSpells = ELib:Check(self.optColSet.superTabFrame.tab[6],L.cd2MethodsDisableOwn):Point(10,-230):OnClick(function(self) 
		if self:GetChecked() then
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].methodsHideOwnSpells = true
		else
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].methodsHideOwnSpells = nil
		end
		module:ReloadAllSplits()
	end)
	
	self.optColSet.chkAlphaNotInRange = ELib:Check(self.optColSet.superTabFrame.tab[6],L.cd2MethodsAlphaNotInRange):Point(10,-255):OnClick(function(self) 
		if self:GetChecked() then
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].methodsAlphaNotInRange = true
		else
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].methodsAlphaNotInRange = nil
		end
		module:ReloadAllSplits()
	end)
	
	self.optColSet.sliderAlphaNotInRange = ELib:Slider(self.optColSet.superTabFrame.tab[6],""):Size(140):Point("TOPLEFT",self.optColSet.chkAlphaNotInRange,270,-3):Range(0,100):OnChange(function(self,event) 
		event = event - event%1
		VExRT.ExCD2.colSet[module.options.optColTabs.selected].methodsAlphaNotInRangeNum = event
		module:ReloadAllSplits()
		self.tooltipText = event
		self:tooltipReload(self)
	end)
	
	self.optColSet.chkDisableActive = ELib:Check(self.optColSet.superTabFrame.tab[6],L.cd2ColSetDisableActive):Point(10,-280):OnClick(function(self) 
		if self:GetChecked() then
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].methodsDisableActive = true
		else
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].methodsDisableActive = nil
		end
		module:ReloadAllSplits()
	end)

	self.optColSet.chkGeneralMethods = ELib:Check(self.optColSet.superTabFrame.tab[6],L.cd2ColSetGeneral):Point("TOPRIGHT",-10,-10):Left():OnClick(function(self) 
		if self:GetChecked() then
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].methodsGeneral = true
		else
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].methodsGeneral = nil
		end
		module:ReloadAllSplits()
		self:doAlphas()
	end)
	function self.optColSet.chkGeneralMethods:doAlphas()
		ExRT.lib.SetAlphas(VExRT.ExCD2.colSet[module.options.optColTabs.selected].methodsGeneral and module.options.optColTabs.selected ~= (module.db.maxColumns + 1) and 0.5 or 1,module.options.optColSet.chkShowOnlyOnCD,module.options.optColSet.chkBotToTop,module.options.optColSet.dropDownStyleAnimation,module.options.optColSet.dropDownTimeLineAnimation,module.options.optColSet.chkIconTooltip,module.options.optColSet.chkLineClick,module.options.optColSet.chkNewSpellNewLine,module.options.optColSet.dropDownSortingRules,module.options.optColSet.textSortingRules,module.options.optColSet.textStyleAnimation,module.options.optColSet.textTimeLineAnimation,module.options.optColSet.chkHideOwnSpells,module.options.optColSet.chkAlphaNotInRange,module.options.optColSet.sliderAlphaNotInRange,module.options.optColSet.chkDisableActive)
	end
	
	self.optColSet.chkSortByAvailability = ELib:Check(self.optColSet.superTabFrame.tab[6],L.cd2SortByAvailability,VExRT.ExCD2.SortByAvailability):Point(10,-305):OnClick(function(self) 
		if self:GetChecked() then
			VExRT.ExCD2.SortByAvailability = true
		else
			VExRT.ExCD2.SortByAvailability = nil
			module.main:GROUP_ROSTER_UPDATE()
		end
	end)
	
	self.optColSet.chkSortByAvailability_activeToTop = ELib:Check(self.optColSet.superTabFrame.tab[6],L.cd2SortByAvailabilityActiveToTop,VExRT.ExCD2.SortByAvailabilityActiveToTop):Point("TOPLEFT",self.optColSet.chkSortByAvailability,0,-25):Tooltip(L.cd2SortByAvailabilityActiveToTopTooltip):OnClick(function(self) 
		if self:GetChecked() then
			VExRT.ExCD2.SortByAvailabilityActiveToTop = true
		else
			VExRT.ExCD2.SortByAvailabilityActiveToTop = nil
		end
		module:ReloadAllSplits()
	end)
	
	self.optColSet.chkReverseSorting = ELib:Check(self.optColSet.superTabFrame.tab[6],L.cd2ReverseSorting,VExRT.ExCD2.ReverseSorting):Point("TOPLEFT",self.optColSet.chkSortByAvailability_activeToTop,0,-25):OnClick(function(self) 
		if self:GetChecked() then
			VExRT.ExCD2.ReverseSorting = true
		else
			VExRT.ExCD2.ReverseSorting = nil
		end
		module:ReloadAllSplits()
	end)
	
	--> Black List
	
	self.optColSet.blacklistText = ELib:Text(self.optColSet.superTabFrame.tab[7],L.cd2ColSetBlacklistTooltip,11):Size(430,200):Point(10,-30):Top():Color()
	
	self.optColSet.blacklistEditBox = ELib:MultiEdit(self.optColSet.superTabFrame.tab[7]):Size(430,140):Point("TOP",0,-85)
	do
		local scheluded = nil
		local function ScheludeFunc(self)
			scheluded = nil
			module:ReloadAllSplits()
		end
		function self.optColSet.blacklistEditBox:OnTextChanged(isUser)
			if not isUser then
				return
			end
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].blacklistText = strtrim( self:GetText() )
			if not scheluded then
				scheluded = ExRT.F.ScheduleTimer(ScheludeFunc, 1)
			end
		end
	end

	self.optColSet.whitelistText = ELib:Text(self.optColSet.superTabFrame.tab[7],L.cd2ColSetWhitelistTooltip,11):Size(430,200):Point(10,-235):Top():Color()
	
	self.optColSet.whitelistEditBox = ELib:MultiEdit(self.optColSet.superTabFrame.tab[7]):Size(430,140):Point("TOP",0,-290)
	do
		local scheluded = nil
		local function ScheludeFunc(self)
			scheluded = nil
			module:ReloadAllSplits()
		end
		function self.optColSet.whitelistEditBox:OnTextChanged(isUser)
			if not isUser then
				return
			end
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].whitelistText = strtrim( self:GetText() )
			if not scheluded then
				scheluded = ExRT.F.ScheduleTimer(ScheludeFunc, 1)
			end
		end
	end
		
	self.optColSet.chkGeneralBlackList = ELib:Check(self.optColSet.superTabFrame.tab[7],L.cd2ColSetGeneral):Point("TOPRIGHT",-10,-10):Left():OnClick(function(self) 
		if self:GetChecked() then
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].blacklistGeneral = true
		else
			VExRT.ExCD2.colSet[module.options.optColTabs.selected].blacklistGeneral = nil
		end
		module:ReloadAllSplits()
		self:doAlphas()
	end)
	function self.optColSet.chkGeneralBlackList:doAlphas()
		ExRT.lib.SetAlphas(VExRT.ExCD2.colSet[module.options.optColTabs.selected].blacklistGeneral and module.options.optColTabs.selected ~= (module.db.maxColumns + 1) and 0.5 or 1,module.options.optColSet.blacklistEditBox,module.options.optColSet.whitelistEditBox,module.options.optColSet.whitelistText,module.options.optColSet.blacklistText)
	end
	
	--> Templates Tab
	self.optColSet.templates = {}
	self.optColSet.templateData = {
		spells = {31821,62618,97462,20484,98008},
		spellsCD = {90,0,0,20,0},
		spellsDuration = {0,10,0,0,0},
		spellsDead = {nil,nil,true,nil,nil},
		spellsCharge = {nil,nil,nil,true,nil},
		spellsClass = {"PALADIN","PRIEST","WARRIOR","DRUID","SHAMAN"},
		[1] = {
			iconSize = 16,
			optionAnimation = true,
			optionStyleAnimation = 1,
			optionTimeLineAnimation = 1,
			optionIconPosition = 1,
			optionGray = true,
			fontSize = 12,
			fontName = ExRT.F.defFont,
			fontOutline = true,
			fontShadow = false,
			textureFile = ExRT.F.barImg,
			colorsText = {1,1,1, 1,1,1, 1,1,1, 1,1,1},
			colorsBack = {0,1,0, 0,1,0, 1,0,0, 1,1,0},
			colorsTL = {0,1,0, 0,1,0, 1,0,0, 1,1,0},
			textureAlphaBackground = 0.3,
			textureAlphaTimeLine = 0.8,
			textureAlphaCooldown = 1,
			optionClassColorBackground = false,
			optionClassColorTimeLine = false,
			optionClassColorText = false,
			textTemplateLeft = "%name%",
			textTemplateRight = "%time%",
			textTemplateCenter = "",
		},
		[2] = {
			iconSize = 14,
			optionAnimation = false,
			optionStyleAnimation = 1,
			optionTimeLineAnimation = 1,
			optionIconPosition = 1,
			optionGray = false,
			fontSize = 12,
			fontName = ExRT.F.defFont,
			fontOutline = true,
			fontShadow = false,
			textureFile = ExRT.F.barImg,
			colorsText = {1,1,1, 0.5,1,0.5, 1,0.5,0.5, 1,1,0.5,},
			colorsBack = {1,1,1, 1,1,1, 1,1,1, 1,1,1},
			colorsTL = {1,1,1, 1,1,1, 1,1,1, 1,1,1},
			textureAlphaBackground = 0.3,
			textureAlphaTimeLine = 0.8,
			textureAlphaCooldown = 1,
			optionClassColorBackground = false,
			optionClassColorTimeLine = false,
			optionClassColorText = false,
			textTemplateLeft = "%time% %name%",
			textTemplateRight = "",
			textTemplateCenter = "",
		},
		[3] = {
			iconSize = 14,
			optionAnimation = true,
			optionStyleAnimation = 1,
			optionTimeLineAnimation = 2,
			optionIconPosition = 1,
			optionGray = false,
			fontSize = 12,
			fontName = ExRT.F.defFont,
			fontOutline = false,
			fontShadow = true,
			textureFile = "Interface\\AddOns\\ExRT\\media\\bar26.tga",
			colorsText = {1,1,1, 1,1,1, 1,1,1, 1,1,1},
			colorsBack = {1,1,1, 1,1,1, 1,1,1, 1,1,1},
			colorsTL = {1,1,1, 1,1,1, 1,1,1, 1,1,1},
			textureAlphaBackground = 0.15,
			textureAlphaTimeLine = 0.8,
			textureAlphaCooldown = 1,
			optionClassColorBackground = false,
			optionClassColorTimeLine = true,
			optionClassColorText = false,
			textTemplateLeft = "",
			textTemplateRight = "%time%",
			textTemplateCenter = "%name%: %spell%",
		},
		[4] = {
			iconSize = 16,
			optionAnimation = true,
			optionStyleAnimation = 2,
			optionTimeLineAnimation = 2,
			optionIconPosition = 1,
			optionGray = false,
			fontSize = 12,
			fontName = ExRT.F.defFont,
			fontOutline = false,
			fontShadow = true,
			textureFile = "Interface\\AddOns\\ExRT\\media\\bar19.tga",
			colorsText = {1,1,1, 0.5,1,0.5, 1,1,1, 1,1,0.5},
			colorsBack = {1,1,1, 1,1,1, 1,1,1, 1,1,1},
			colorsTL = {1,1,1, 1,1,1, 1,1,1, 1,1,1},
			textureAlphaBackground = 0.15,
			textureAlphaTimeLine = 1,
			textureAlphaCooldown = 0.85,
			optionClassColorBackground = true,
			optionClassColorTimeLine = true,
			optionClassColorText = false,
			textTemplateLeft = "%name%",
			textTemplateRight = "%time%",
			textTemplateCenter = "",
			
			frameBetweenLines = 1,
		},
		[5] = {
			iconSize = 40,
			optionAnimation = false,
			optionStyleAnimation = 1,
			optionTimeLineAnimation = 1,
			optionIconPosition = 1,
			optionGray = false,
			fontSize = 10,
			fontName = ExRT.F.defFont,
			fontOutline = true,
			fontShadow = false,
			textureFile = ExRT.F.barImg,
			colorsText = {1,1,1, 0.5,1,0.5, 1,0.5,0.5, 1,1,0.5,},
			colorsBack = {1,1,1, 1,1,1, 1,1,1, 1,1,1},
			colorsTL = {1,1,1, 1,1,1, 1,1,1, 1,1,1},
			textureAlphaBackground = 0,
			textureAlphaTimeLine = 0,
			textureAlphaCooldown = 0.7,
			optionClassColorBackground = false,
			optionClassColorTimeLine = false,
			optionClassColorText = false,
			textTemplateLeft = "",
			textTemplateRight = "",
			textTemplateCenter = "",
			textIconName = true,
			methodsCooldown = true,
			
			frameWidth = 40,
			frameColumns = 4,
		},
		[6] = {
			iconSize = 12,
			optionAnimation = false,
			optionStyleAnimation = 1,
			optionTimeLineAnimation = 1,
			optionIconPosition = 1,
			optionGray = false,
			fontSize = 12,
			fontName = ExRT.F.defFont,
			fontOutline = false,
			fontShadow = false,
			textureFile = ExRT.F.barImg,
			colorsText = {1,1,1, 0.5,1,0.5, 1,0.5,0.5, 1,1,0.5,},
			colorsBack = {1,1,1, 1,1,1, 1,1,1, 1,1,1},
			colorsTL = {1,1,1, 1,1,1, 1,1,1, 1,1,1},
			textureAlphaBackground = 0,
			textureAlphaTimeLine = 0,
			textureAlphaCooldown = 1,
			optionClassColorBackground = false,
			optionClassColorTimeLine = false,
			optionClassColorText = false,
			textTemplateLeft = "%time% %name%",
			textTemplateRight = "",
			textTemplateCenter = "",
		},
		[7] = {
			iconSize = 14,
			optionAnimation = true,
			optionStyleAnimation = 1,
			optionTimeLineAnimation = 1,
			optionIconPosition = 1,
			optionGray = false,
			fontSize = 12,
			fontName = ExRT.F.defFont,
			fontOutline = false,
			fontShadow = true,
			textureFile = "Interface\\AddOns\\ExRT\\media\\bar29.tga",
			colorsText = {1,1,1, 1,1,1, 1,1,1, 1,1,1},
			colorsBack = {0,1,0, 0,1,0, 0.8,0,0, 1,1,0},
			colorsTL = {0,1,0, 0,1,0, 0.8,0,0, 1,1,0},
			textureAlphaBackground = 0.3,
			textureAlphaTimeLine = 0.8,
			textureAlphaCooldown = 0.5,
			optionClassColorBackground = false,
			optionClassColorTimeLine = false,
			optionClassColorText = false,
			textTemplateLeft = "%name%",
			textTemplateRight = "%stime%",
			textTemplateCenter = "",
		},
		[8] = {
			iconSize = 16,
			optionAnimation = true,
			optionStyleAnimation = 2,
			optionTimeLineAnimation = 2,
			optionIconPosition = 2,
			optionGray = true,
			fontSize = 13,
			fontName = ExRT.F.defFont,
			fontOutline = true,
			fontShadow = true,
			textureFile = "Interface\\AddOns\\ExRT\\media\\bar6.tga",
			colorsText = {1,1,1, 0.5,1,0.5, 1,0.5,0.5, 1,1,0.5,},
			colorsBack = {1,1,1, 1,1,1, 1,1,1, 1,1,1},
			colorsTL = {1,1,1, 1,1,1, 1,1,1, 1,1,1},
			textureAlphaBackground = 0.3,
			textureAlphaTimeLine = 0.8,
			textureAlphaCooldown = 0.5,
			optionClassColorBackground = false,
			optionClassColorTimeLine = false,
			optionClassColorText = true,
			textTemplateLeft = "%name%",
			textTemplateRight = "",
			textTemplateCenter = "",
		},
		[9] = {
			iconSize = 18,
			optionAnimation = true,
			optionStyleAnimation = 1,
			optionTimeLineAnimation = 2,
			optionIconPosition = 1,
			optionGray = false,
			fontSize = 12,
			fontName = ExRT.F.defFont,
			fontOutline = false,
			fontShadow = true,
			textureFile = "Interface\\AddOns\\ExRT\\media\\bar16.tga",
			colorsText = {1,1,1, 1,1,1, 1,1,1, 1,1,1},
			colorsBack = {0,0,0, 0,0,0, 0,0,0, 0,0,0},
			colorsTL = {0.24,0.44,1, 1,0.37,1, 0.24,0.44,1, 1,0.46,0.10},
			textureAlphaBackground = 0.3,
			textureAlphaTimeLine = 0.9,
			textureAlphaCooldown = 1,
			optionClassColorBackground = false,
			optionClassColorTimeLine = false,
			optionClassColorText = false,
			textTemplateLeft = "%name%",
			textTemplateRight = "%stime%",
			textTemplateCenter = "",
			textureBorderSize = 1,
			frameBetweenLines = 3,
			textureBorderColorA = 1,
		},
		[10] = {
			iconSize = 18,
			optionAnimation = true,
			optionStyleAnimation = 1,
			optionTimeLineAnimation = 2,
			optionIconPosition = 1,
			optionGray = false,
			fontSize = 12,
			fontName = ExRT.F.defFont,
			fontOutline = false,
			fontShadow = true,
			textureFile = "Interface\\AddOns\\ExRT\\media\\bar16.tga",
			colorsText = {1,1,1, 1,1,1, 1,1,1, 1,1,1},
			colorsBack = {0,0,0, 0,0,0, 0,0,0, 0,0,0},
			colorsTL = {0.24,0.44,1, 1,0.37,1, 0.24,0.44,1, 1,0.46,0.10},
			textureAlphaBackground = 0.3,
			textureAlphaTimeLine = 0.9,
			textureAlphaCooldown = 1,
			optionClassColorBackground = false,
			optionClassColorTimeLine = true,
			optionClassColorText = false,
			textTemplateLeft = "%name%",
			textTemplateRight = "%stime%",
			textTemplateCenter = "",
			textureBorderSize = 1,
			frameBetweenLines = 3,
			textureBorderColorA = 1,
		},
		[11] = {
			_twoSized = true,
			_Scaled = .8,
			
			iconSize = 40,
			optionAnimation = true,
			optionStyleAnimation = 1,
			optionTimeLineAnimation = 2,
			optionIconPosition = 1,
			optionGray = true,
			fontSize = 14,
			fontName = ExRT.F.defFont,
			fontOutline = true,
			fontShadow = false,
			textureFile = "Interface\\AddOns\\ExRT\\media\\bar17.tga",
			colorsText = {1,1,1, 1,1,1, 1,.6,.6, 1,1,.5},
			colorsBack = {0,0,0, 0,0,0, 0,0,0, 0,0,0},
			colorsTL = {0,0,0, 0,0,0, 0,0,0, 0,0,0},
			textureAlphaBackground = 0.8,
			textureAlphaTimeLine = 1,
			textureAlphaCooldown = .5,
			optionClassColorBackground = false,
			optionClassColorTimeLine = true,
			optionClassColorText = false,
			textTemplateLeft = "%name%",
			textTemplateRight = "",
			textTemplateCenter = "",
			methodsCooldown = true,
			methodsNewSpellNewLine = true,
			frameColumns = 5,
			iconHideBlizzardEdges = true,
			
			frameLines = 60,
			
			DiffSpellData = {
				spells = 	{31821,	31821,	0,	0,	0,	97462,	0,	0,	0,	0,	20484,	20484},
				spellsCD = 	{90,	0,	0,	0,	0,	0,	0,	0,	0,	0,	20,	0},
				spellsDuration = {0,	10,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0},
				spellsDead = 	{nil,	nil,	nil,	nil,	nil,	true,	nil,	nil,	nil,	nil,	nil,	nil},
				spellsCharge = 	{nil,	nil,	nil,	nil,	nil,	nil,	nil,	nil,	nil,	nil,	true,	nil},
				spellsClass = 	{"PALADIN","PALADIN",nil,nil,nil,	"WARRIOR",nil,nil,nil,nil,		"DRUID","DRUID"},			
			},
		},
		[12] = {},
		[13] = {
			iconSize = 13,
			optionAnimation = true,
			optionStyleAnimation = 2,
			optionTimeLineAnimation = 2,
			optionIconPosition = 2,
			optionGray = false,
			fontSize = 12,
			fontName = ExRT.F.defFont,
			fontOutline = false,
			fontShadow = true,
			textureFile = "Interface\\AddOns\\ExRT\\media\\bar19.tga",
			colorsText = {1,1,1, 0.5,1,0.5, 1,1,1, 1,1,0.5},
			colorsBack = {1,1,1, 1,1,1, 1,1,1, 1,1,1},
			colorsTL = {1,1,1, 1,1,1, 1,1,1, 1,1,1},
			textureAlphaBackground = 0.15,
			textureAlphaTimeLine = 1,
			textureAlphaCooldown = 0.85,
			optionClassColorBackground = true,
			optionClassColorTimeLine = true,
			optionClassColorText = false,
			textTemplateLeft = "%name%",
			textTemplateRight = "%time%",
			textTemplateCenter = "",
			iconTitles = true,
			
			frameBetweenLines = 0,	
			
			DiffSpellData = {
				spells = 	{31821,	31821,	31821,	97462,	97462,	51052,	51052,	51052,	},
				spellsCD = 	{0,	90,	0,	0,	0,	0,	0,	20,	},
				spellsDuration ={0,	0,	10,	0,	0,	0,	0,	0,	},
				spellsDead = 	{nil,	nil,	nil,	nil,	true,	nil,	nil,	nil,	},
				spellsCharge = 	{nil,	nil,	nil,	nil,	nil,	nil,	nil,	true,	},
				spellsClass = 	{"title","PALADIN","PALADIN","title","WARRIOR","title","DEATHKNIGHT","DEATHKNIGHT"},			
			},		
		},
		[14] = {
			iconSize = 14,
			optionAnimation = true,
			optionStyleAnimation = 2,
			optionTimeLineAnimation = 2,
			optionIconPosition = 1,
			optionGray = false,
			fontSize = 12,
			fontName = ExRT.F.defFont,
			fontOutline = false,
			fontShadow = true,
			textureFile = "Interface\\AddOns\\ExRT\\media\\bar19.tga",
			colorsText = {1,1,1, 0.5,1,0.5, 1,1,1, 1,1,0.5},
			colorsBack = {1,1,1, 1,1,1, 1,1,1, 1,1,1},
			colorsTL = {1,1,1, 1,1,1, 1,1,1, 1,1,1},
			textureAlphaBackground = 0.15,
			textureAlphaTimeLine = 1,
			textureAlphaCooldown = 0.85,
			optionClassColorBackground = true,
			optionClassColorTimeLine = true,
			optionClassColorText = false,
			textTemplateLeft = "%name%",
			textTemplateRight = "%time%",
			textTemplateCenter = "",
			
			frameBetweenLines = 0,
		},
		[15] = {
			_twoSized = true,
			_Scaled = .75,
			
			iconSize = 13,
			optionAnimation = true,
			optionStyleAnimation = 2,
			optionTimeLineAnimation = 2,
			optionIconPosition = 1,
			optionGray = false,
			fontSize = 12,
			fontName = ExRT.F.defFont,
			fontOutline = false,
			fontShadow = true,
			textureFile = "Interface\\AddOns\\ExRT\\media\\bar19.tga",
			colorsText = {1,1,1, 0.5,1,0.5, 1,1,1, 1,1,0.5},
			colorsBack = {1,1,1, 1,1,1, 1,1,1, 1,1,1},
			colorsTL = {1,1,1, 1,1,1, 1,1,1, 1,1,1},
			textureAlphaBackground = 0.15,
			textureAlphaTimeLine = 1,
			textureAlphaCooldown = 0.85,
			optionClassColorBackground = true,
			optionClassColorTimeLine = true,
			optionClassColorText = false,
			textTemplateLeft = "%name%",
			textTemplateRight = "%time%",
			textTemplateCenter = "",
			iconTitles = true,
			methodsNewSpellNewLine = true,
			frameColumns = 5,
			frameLines = 60,
			frameBetweenLines = 0,	
			
			DiffSpellData = {
				spells = 	{31821,	31821,	31821,	0,	0,	97462,	97462,	0,	0,	0,	740,	740,	740,	0,	0,	51052,	51052,	51052,	0,	0,	64843,	64843,	64843,},
				spellsCD = 	{0,	90,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	20,	0,	0,	0,	0,	70,},
				spellsDuration ={0,	0,	10,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,},
				spellsDead = 	{nil,	nil,	nil,	nil,	nil,	nil,	true,	nil,	nil,	nil,	nil,	nil,	nil,	nil,	nil,	nil,	nil,	nil,	nil,	nil,	nil,	nil,	nil,},
				spellsCharge = 	{nil,	nil,	nil,	nil,	nil,	nil,	nil,	nil,	nil,	nil,	nil,	nil,	nil,	nil,	nil,	nil,	nil,	true,	nil,	nil,	nil,	nil,	nil,},
				spellsClass = 	{"title","PALADIN","PALADIN",nil,nil,"title","WARRIOR",nil,nil,nil,"title","DRUID","DRUID",nil,nil,"title","DEATHKNIGHT","DEATHKNIGHT",nil,nil,"title","PRIEST","PRIEST"},			
			},
		},
		[16] = {},
		toOptions = {
			iconSize = "iconSize",
			optionAnimation = "textureAnimation",
			optionStyleAnimation = "methodsStyleAnimation",
			optionTimeLineAnimation = "methodsTimeLineAnimation",
			optionIconPosition = "iconPosition",
			optionGray = "iconGray",
			fontSize = "fontSize",
			fontName = "fontName",
			fontOutline = "fontOutline",
			fontShadow = "fontShadow",
			textureFile = "textureFile",
			colorsText = {"textureColorTextDefaultR","textureColorTextDefaultG","textureColorTextDefaultB","textureColorTextActiveR","textureColorTextActiveG","textureColorTextActiveB","textureColorTextCooldownR","textureColorTextCooldownG","textureColorTextCooldownB","textureColorTextCastR","textureColorTextCastG","textureColorTextCastB",},
			colorsBack = {"textureColorBackgroundDefaultR","textureColorBackgroundDefaultG","textureColorBackgroundDefaultB","textureColorBackgroundActiveR","textureColorBackgroundActiveG","textureColorBackgroundActiveB","textureColorBackgroundCooldownR","textureColorBackgroundCooldownG","textureColorBackgroundCooldownB","textureColorBackgroundCastR","textureColorBackgroundCastG","textureColorBackgroundCastB",},
			colorsTL = {"textureColorTimeLineDefaultR","textureColorTimeLineDefaultG","textureColorTimeLineDefaultB","textureColorTimeLineActiveR","textureColorTimeLineActiveG","textureColorTimeLineActiveB","textureColorTimeLineCooldownR","textureColorTimeLineCooldownG","textureColorTimeLineCooldownB","textureColorTimeLineCastR","textureColorTimeLineCastG","textureColorTimeLineCastB",},
			textureAlphaBackground = "textureAlphaBackground",
			textureAlphaTimeLine = "textureAlphaTimeLine",
			textureAlphaCooldown = "textureAlphaCooldown",
			optionClassColorBackground = "textureClassBackground",
			optionClassColorTimeLine = "textureClassTimeLine",
			optionClassColorText = "textureClassText",	
			textTemplateLeft = "textTemplateLeft",
			textTemplateRight = "textTemplateRight",
			textTemplateCenter = "textTemplateCenter",
			methodsCooldown = "methodsCooldown",
			textIconName = "textIconName",
			fontOtherAvailable = "fontOtherAvailable",
			frameBetweenLines = "frameBetweenLines",
			textureBorderSize = "textureBorderSize",
			textureBorderColorR = "textureBorderColorR",
			textureBorderColorG = "textureBorderColorG",
			textureBorderColorB = "textureBorderColorB",
			textureBorderColorA = "textureBorderColorA",
			methodsNewSpellNewLine = "methodsNewSpellNewLine",
			methodsSortingRules = "methodsSortingRules",
			iconTitles = "iconTitles",
			iconHideBlizzardEdges = "iconHideBlizzardEdges",
			
			iconGeneral = "iconGeneral",
			textureGeneral = "textureGeneral",
			methodsGeneral = "methodsGeneral",
			fontGeneral = "fontGeneral",
			textGeneral = "textGeneral",
			frameGeneral = "frameGeneral",

			frameColumns = "frameColumns",
			
			_frameAlpha = "frameAlpha",
			_frameWidth = "frameWidth",
			_frameBlackBack = "frameBlackBack",
			_frameLines = "frameLines",
		},
	}
	self.optColSet.templateSaveData = nil
	
	self.optColSet.templatesScrollFrame = ELib:ScrollFrame(self.optColSet.superTabFrame.tab[8]):Size(430,380):Point("TOP",0,-50):Height( ceil(#self.optColSet.templateData/2) * 125 + 10 )
	for i=1,#self.optColSet.templateData do if i==1 or not self.optColSet.templateData[i-1]._twoSized then
		local templateFrame = CreateFrame("Button",nil,self.optColSet.templatesScrollFrame.C)
		self.optColSet.templates[i] = templateFrame
		templateFrame:SetPoint(self.optColSet.templateData[i]._twoSized and "TOP" or (i-1)%2 == 0 and "TOPRIGHT" or "TOPLEFT",self.optColSet.templatesScrollFrame.C,"TOP",0,-floor((i-1)/2) * 125 - 5)
		templateFrame:SetSize(185,120)
		if self.optColSet.templateData[i]._twoSized then
			templateFrame:SetSize(370,120)
		end
		templateFrame:SetBackdrop({edgeFile = ExRT.F.defBorder, edgeSize = 8})
		templateFrame:SetBackdropBorderColor(1,1,1,0)
		templateFrame.backgTexture = templateFrame:CreateTexture(nil, "BACKGROUND")
		templateFrame.backgTexture:SetAllPoints()
		
		templateFrame:SetScript("OnEnter",function (self)
			self:SetBackdropBorderColor(1,1,1,0.5)
			self.backgTexture:SetTexture(1,1,1,0.3)
		end)
		
		templateFrame:SetScript("OnLeave",function (self)
		  	self:SetBackdropBorderColor(1,1,1,0)
			self.backgTexture:SetTexture(0,0,0,0)
		end)
		
		templateFrame:SetScript("OnClick",function (self)
		  	module.options.optColSet.templateRestore:Show()
		  	module.options.optColSet.templateSaveData = {}
		  	ExRT.F.table_copy(VExRT.ExCD2.colSet[module.options.optColTabs.selected],module.options.optColSet.templateSaveData)
		  	for key,val in pairs(module.options.optColSet.templateData.toOptions) do
		  		if type(val) ~= "table" then
		  			if string.find(key,"^_") then
		  				local key2 = string.sub(key,2)
		  				if module.options.optColSet.templateData[i][key2] then
		  					VExRT.ExCD2.colSet[module.options.optColTabs.selected][val] = module.options.optColSet.templateData[i][key2]
		  				elseif key2 == "frameWidth" then
		  					VExRT.ExCD2.colSet[module.options.optColTabs.selected][val] = max(110,VExRT.ExCD2.colSet[module.options.optColTabs.selected][val] or 110)
		  				end
		  			elseif val:find("General") then
		  				VExRT.ExCD2.colSet[module.options.optColTabs.selected][val] = nil
		  			else
		  				VExRT.ExCD2.colSet[module.options.optColTabs.selected][val] = module.options.optColSet.templateData[i][key]
		  			end
		  		else
		  			for k=1,#val do
		  				VExRT.ExCD2.colSet[module.options.optColTabs.selected][val[k]] = module.options.optColSet.templateData[i][key][k]
		  			end
		  		end
		  	end
		  	module:ReloadAllSplits()
		  	module.options.selectColumnTab()
		end)
		
		local width,height = self.optColSet.templateData[i].frameWidth or 160, self.optColSet.templateData[i].iconSize
		local betweenLines = self.optColSet.templateData[i].frameBetweenLines or 0
		
		templateFrame.barWidth = width
		templateFrame.iconSize = height
		
		templateFrame.fontName = self.optColSet.templateData[i].fontName
		templateFrame.fontSize = self.optColSet.templateData[i].fontSize
		templateFrame.fontOutline = self.optColSet.templateData[i].fontOutline
		templateFrame.fontShadow = self.optColSet.templateData[i].fontShadow
		for _,pos in pairs({"Left","Right","Center","Icon"}) do
			templateFrame["font"..pos.."Name"] = self.optColSet.templateData[i]["font"..pos.."Name"] or templateFrame.fontName
			templateFrame["font"..pos.."Size"] = self.optColSet.templateData[i]["font"..pos.."Size"] or templateFrame.fontSize
			templateFrame["font"..pos.."Outline"] = self.optColSet.templateData[i]["font"..pos.."Outline"] or templateFrame.fontOutline
			templateFrame["font"..pos.."Shadow"] = self.optColSet.templateData[i]["font"..pos.."Shadow"] or templateFrame.fontShadow
		end
	
		templateFrame.textTemplateLeft = self.optColSet.templateData[i].textTemplateLeft
		templateFrame.textTemplateRight = self.optColSet.templateData[i].textTemplateRight
		templateFrame.textTemplateCenter = self.optColSet.templateData[i].textTemplateCenter
		templateFrame.optionIconName = self.optColSet.templateData[i].textIconName
		templateFrame.optionCooldown = self.optColSet.templateData[i].methodsCooldown
		templateFrame.optionIconPosition = self.optColSet.templateData[i].optionIconPosition
		templateFrame.optionAnimation = self.optColSet.templateData[i].optionAnimation
		templateFrame.optionGray = self.optColSet.templateData[i].optionGray
		
		templateFrame.textureFile = self.optColSet.templateData[i].textureFile
		templateFrame.optionAlphaBackground = self.optColSet.templateData[i].textureAlphaBackground
		templateFrame.optionAlphaTimeLine = self.optColSet.templateData[i].textureAlphaTimeLine
		templateFrame.optionAlphaCooldown = self.optColSet.templateData[i].textureAlphaCooldown
		
		templateFrame.optionTimeLineAnimation = self.optColSet.templateData[i].optionTimeLineAnimation
		templateFrame.optionStyleAnimation = self.optColSet.templateData[i].optionStyleAnimation
		
		templateFrame.optionClassColorBackground = self.optColSet.templateData[i].optionClassColorBackground
		templateFrame.optionClassColorTimeLine = self.optColSet.templateData[i].optionClassColorTimeLine
		templateFrame.optionClassColorText = self.optColSet.templateData[i].optionClassColorText

		templateFrame.optionIconHideBlizzardEdges = self.optColSet.templateData[i].iconHideBlizzardEdges
		
		templateFrame.textureBorderColorR = self.optColSet.templateData[i].textureBorderColorR or 0
		templateFrame.textureBorderColorG = self.optColSet.templateData[i].textureBorderColorG or 0
		templateFrame.textureBorderColorB = self.optColSet.templateData[i].textureBorderColorB or 0
		templateFrame.textureBorderColorA = self.optColSet.templateData[i].textureBorderColorA or 0
		
		templateFrame.optionIconTitles = self.optColSet.templateData[i].iconTitles
		
		local templateDataColorsTablesNames = {"colorsText","colorsBack","colorsTL"}
		for object_c=1,3 do
			for state_c=1,3 do
				templateFrame["optionColor".. colorSetupFrameColorsObjectsNames[object_c] .. colorSetupFrameColorsNames[state_c] ] = {
					r = self.optColSet.templateData[i][ templateDataColorsTablesNames[object_c] ][ (state_c-1)*3+1 ],
					g = self.optColSet.templateData[i][ templateDataColorsTablesNames[object_c] ][ (state_c-1)*3+2 ],
					b = self.optColSet.templateData[i][ templateDataColorsTablesNames[object_c] ][ (state_c-1)*3+3 ],
				}
			end
		end
		
		templateFrame.textureBorderSize = self.optColSet.templateData[i].textureBorderSize or 0
		
		local DiffSpellData = self.optColSet.templateData[i].DiffSpellData
		
		local classColorsTable = type(CUSTOM_CLASS_COLORS)=="table" and CUSTOM_CLASS_COLORS or RAID_CLASS_COLORS
		
		templateFrame.lines = {}
		for j=1,DiffSpellData and #DiffSpellData.spells or 5 do if not DiffSpellData or DiffSpellData.spells[j] ~= 0 then
			local bar = CreateBar(templateFrame)
			templateFrame.lines[j] = bar
	
			if not self.optColSet.templateData[i].frameColumns then
				bar:SetPoint("TOP",0,-height*(j-1)-10 -betweenLines*(j-1))
			else
				local inLine = (j-1) % self.optColSet.templateData[i].frameColumns
				local line = ExRT.F.Round( ((j-1) - inLine) / self.optColSet.templateData[i].frameColumns )
				if self.optColSet.templateData[i]._twoSized then
					bar:SetPoint("TOPLEFT", inLine*width + 10, -line*height -10 -betweenLines*line) 
				else
					local pos = inLine * width
					local totalWidth = self.optColSet.templateData[i].frameColumns * width
					pos = pos - totalWidth / 2
					bar:SetPoint("TOPLEFT", templateFrame,"TOP",pos, -line*height -10 -betweenLines*line) 	
				end
			end
			
			if self.optColSet.templateData[i]._Scaled then
				bar:SetScale(self.optColSet.templateData[i]._Scaled)
			end
			
			local spellID = DiffSpellData and DiffSpellData.spells[j] or self.optColSet.templateData.spells[j]
			local spellName,_,spellTexture = GetSpellInfo(spellID or 0)
			
			local spellClass = DiffSpellData and DiffSpellData.spellsClass[j] or self.optColSet.templateData.spellsClass[j]
		
			bar.data = {
				name = ExRT.SDB.charName,
				fullName = ExRT.SDB.charName,
				icon = spellTexture,
				spellName = i == 3 and spellName:sub(1,spellName:find(' ')) or spellName,
				db = {spellID,spellClass},
				lastUse = GetTime(),
				charge = GetTime(),
				cd = DiffSpellData and DiffSpellData.spellsCD[j] or self.optColSet.templateData.spellsCD[j],
				duration = DiffSpellData and DiffSpellData.spellsDuration[j] or self.optColSet.templateData.spellsDuration[j],
				classColor = classColorsTable[spellClass] or module.db.notAClass,
				
				disabled = ((DiffSpellData and DiffSpellData.spellsDead[j]) or (not DiffSpellData and self.optColSet.templateData.spellsDead[j])) and 1,
				isCharge = DiffSpellData and DiffSpellData.spellsCharge[j] or not DiffSpellData and self.optColSet.templateData.spellsCharge[j],
				
				specialUpdateData = function(data)
					local currTime = GetTime()
					if data.isCharge then
						if (data.charge + data.cd) < currTime then
							data.charge = currTime
							data.lastUse = currTime
						end
						return
					end
					if data.cd ~= 0 then
						if (data.lastUse + data.cd) < currTime then
							data.lastUse = currTime
						end
					elseif data.duration ~= 0 then
						if (data.lastUse + data.duration) < currTime then
							data.lastUse = currTime
						end
					end
				end,
			}
			
			bar:UpdateStyle()
			bar:Update()
			bar:UpdateStatus()
			if spellClass == "title" then
				bar:CreateTitle()
			end
		end end
	end end
	
	self.optColSet.templateRestore = CreateFrame("Button",nil,self.optColSet.superTabFrame.tab[8])
	self.optColSet.templateRestore:SetPoint("TOP",0,-10)
	self.optColSet.templateRestore:SetSize(430,30)
	self.optColSet.templateRestore:SetBackdrop({edgeFile = ExRT.F.defBorder, edgeSize = 8})
	self.optColSet.templateRestore:SetBackdropBorderColor(1,0.5,0.5,1)
	self.optColSet.templateRestore.text = ELib:Text(self.optColSet.templateRestore,L.cd2OtherSetTemplateRestore,12):Point('x'):Center():Color():Shadow()
	self.optColSet.templateRestore:SetScript("OnEnter",function (self)
	  	self.text:SetTextColor(1,1,0,1)
	end)
	self.optColSet.templateRestore:SetScript("OnLeave",function (self)
	  	self.text:SetTextColor(1,1,1,1)	  
	end)
	self.optColSet.templateRestore:SetScript("OnClick",function (self)
		VExRT.ExCD2.colSet[module.options.optColTabs.selected] = {}
		ExRT.F.table_copy(module.options.optColSet.templateSaveData,VExRT.ExCD2.colSet[module.options.optColTabs.selected])
		module:ReloadAllSplits()
		module.options.selectColumnTab()
		self:Hide()
	end)
	self.optColSet.templateRestore:Hide()
	
	do
		module.options.optColTabs.selected = module.db.maxColumns+1
		module.options.tab.tabs[2]:SetScript("OnShow",function ()
			module.options.selectColumnTab(self.optColTabs.tabs[module.db.maxColumns+1].button)
			module.options.tab.tabs[2]:SetScript("OnShow",nil)
		end)
	end	
	
	--> Other setts
	self.optSetTab = ELib:OneTab(self.tab.tabs[2],L.cd2OtherSet):Size(660,40):Point("TOP",0,-530)
	
	self.chkSplit = ELib:Check(self.optSetTab,L.cd2split,VExRT.ExCD2.SplitOpt):Point(10,-10):Tooltip(L.cd2splittooltip):OnClick(function(self,event)
		if self:GetChecked() then
			VExRT.ExCD2.SplitOpt = true
		else
			VExRT.ExCD2.SplitOpt = nil
		end
		module:SplitExCD2Window()
		module:ReloadAllSplits()
	end)
	
	self.chkNoRaid = ELib:Check(self.optSetTab,L.cd2noraid,VExRT.ExCD2.NoRaid):Point(165,-10):OnClick(function(self,event)
		if self:GetChecked() then
			VExRT.ExCD2.NoRaid = true
		else
			VExRT.ExCD2.NoRaid = nil
		end
		UpdateRoster()
	end)
	
	self.testMode = ELib:Check(self.optSetTab,L.cd2GeneralSetTestMode,module.db.testMode):Point(325,-10):Tooltip(L.cd2HelpTestButton):OnClick(function(self,event)
		if self:GetChecked() then
			module.db.testMode = true
		else
			module.db.testMode = nil
			TestMode(1)
		end
		UpdateRoster()
	end)

	self.butResetToDef = ELib:Button(self.optSetTab,L.cd2OtherSetReset):Size(160,20):Point(490,-10):Tooltip(L.cd2HelpButtonDefault):OnClick(function()
		StaticPopupDialogs["EXRT_EXCD_DEFAULT"] = {
			text = L.cd2OtherSetReset,
			button1 = L.YesText,
			button2 = L.NoText,
			OnAccept = function()
				table_wipe2(VExRT.ExCD2.colSet[module.options.optColTabs.selected])
				for optName,optVal in pairs(module.db.colsInit) do
					VExRT.ExCD2.colSet[module.options.optColTabs.selected][optName] = optVal
				end
				VExRT.ExCD2.SortByAvailability = nil
				
				module.options.selectColumnTab(self.optColTabs.tabs[module.options.optColTabs.selected].button)
				module:ReloadAllSplits()
			end,
			timeout = 0,
			whileDead = true,
			hideOnEscape = true,
			preferredIndex = 3,
		}
		StaticPopup_Show("EXRT_EXCD_DEFAULT")
	end) 
	
	
	
	--> OPTIONS TAB3: History
	self.butHistoryClear = ELib:Button(self.tab.tabs[3],L.cd2HistoryClear):Size(180,20):Point("TOPRIGHT",-3,-6):OnClick(function()
		table_wipe2(module.db.historyUsage)
		module.options.historyBox.EditBox:SetText("")
	end)
	
	local historyBoxUpdateTable = {}
	local function historyBoxUpdate(v)
		table_wipe2(historyBoxUpdateTable)
		local count = 0
		for i=1,#module.db.historyUsage do
			if VExRT.ExCD2.CDE[module.db.historyUsage[i][2]] then
				count = count + 1
			end
			if count >= v and VExRT.ExCD2.CDE[module.db.historyUsage[i][2]] then
				local tm = date("%X",module.db.historyUsage[i][1])
				local bosshpstr = module.db.historyUsage[i][4] and format(" (%d:%.2d)",module.db.historyUsage[i][4]/60,module.db.historyUsage[i][4]%60) or ""
				local spellName,_,spellIcon = GetSpellInfo(module.db.historyUsage[i][2])
				historyBoxUpdateTable [#historyBoxUpdateTable + 1] = format("|cffffff00[%s]%s|r %s |Hspell:%d|h|T%s:0|t%s|h",tm,bosshpstr,module.db.historyUsage[i][3] or "?",module.db.historyUsage[i][2] or 0,spellIcon or "Interface\\Icons\\Trade_Engineering",spellName or "?")
			end
			if #historyBoxUpdateTable > 44 then
				break
			end
		end
		module.options.historyBox.EditBox:SetText(strjoin("\n",unpack(historyBoxUpdateTable)))
	end
	
	self.historyBox = ELib:MultiEdit2(self.tab.tabs[3]):Size(650,528):Point("TOP",0,-36):Hyperlinks()
	self.historyBox.EditBox:SetScript("OnShow",function(self)
		historyBoxUpdate(1)
		local count = 0
		for i=1,#module.db.historyUsage do
			if VExRT.ExCD2.CDE[module.db.historyUsage[i][2]] then
				count = count + 1
			end
		end
		module.options.historyBox.ScrollBar:SetMinMaxValues(1,max(count,1))
		module.options.historyBox.ScrollBar:UpdateButtons()
	end)
	self.historyBox.ScrollBar:SetScript("OnValueChanged",function (self,val)
		val = ExRT.F.Round(val)
		historyBoxUpdate(val)
		self:UpdateButtons()
	end)
	
	self.HelpPlate = {
		[1] = {
			FramePos = { x = 0, y = 0 },FrameSize = { width = 660, height = 615 },
			[1] = { ButtonPos = { x = 500,	y = -40 },  	HighLightBox = { x = 485, y = -50, width = 170, height = 25 },		ToolTipDir = "LEFT",	ToolTipText = L.cd2HelpFastSetup },
			[2] = { ButtonPos = { x = 0,  y = -135 }, 	HighLightBox = { x = 7, y = -85, width = 34, height = 495 },		ToolTipDir = "RIGHT",	ToolTipText = L.cd2HelpOnOff },
			[3] = { ButtonPos = { x = 250,  y = -135 }, 	HighLightBox = { x = 225, y = -85, width = 150, height = 495 },		ToolTipDir = "DOWN",	ToolTipText = L.cd2HelpCol },
			[4] = { ButtonPos = { x = 375,  y = -135},  	HighLightBox = { x = 380, y = -85, width = 85, height = 495 },		ToolTipDir = "DOWN",	ToolTipText = L.cd2HelpPriority },
			[5] = { ButtonPos = { x = 470,  y = -135 },  	HighLightBox = { x = 465, y = -85, width = 165, height = 495 },		ToolTipDir = "LEFT",	ToolTipText = L.cd2HelpTime },
			[6] = { ButtonPos = { x = 370,  y = -570 },  	HighLightBox = { x = 7, y = -580, width = 625, height = 30 },		ToolTipDir = "UP",	ToolTipText = L.cd2HelpAddButton },
		},
		[2] = {
			FramePos = { x = 0, y = 0 },FrameSize = { width = 660, height = 615 },
			[1] = { ButtonPos = { x = 50,	y = -130 },  	HighLightBox = { x = 0, y = -70, width = 660, height = 480 },		ToolTipDir = "RIGHT",	ToolTipText = L.cd2HelpColSetup },
			[2] = { ButtonPos = { x = 320,	y = -570 },  	HighLightBox = { x = 315, y = -580, width = 140, height = 30 },		ToolTipDir = "LEFT",	ToolTipText = L.cd2HelpTestButton },
			[3] = { ButtonPos = { x = 500,	y = -570 },  	HighLightBox = { x = 490, y = -580, width = 160, height = 30 },		ToolTipDir = "LEFT",	ToolTipText = L.cd2HelpButtonDefault },
		},
		[3] = {
			FramePos = { x = 0, y = 0 },FrameSize = { width = 660, height = 615 },
			[1] = { ButtonPos = { x = 310,	y = -50 },  	HighLightBox = { x = 0, y = -50, width = 660, height = 565 },		ToolTipDir = "DOWN",	ToolTipText = L.cd2HelpHistory },		
		}
	}
	self.HELPButton = ExRT.lib.CreateHelpButton(self,self.HelpPlate,self.tab)
	self.HELPButton:SetPoint("CENTER",self,"TOPLEFT",0,15)
	
	function self.HELPButton:Click2()
		local min,max=module.options.ScrollBar:GetMinMaxValues()
		module.options.ScrollBar:SetValue(max)
	end
	dtime(ExRT.Debug,'ExCD2','OPTIONS LOADED')
end
--dtime(ExRT.Debug,'ExCD2','OPTIONS CREATED')

function module.options:CleanUPVariables()
	local cleanUP = {}
	for sett,col in pairs(VExRT.ExCD2.CDECol) do
		local bool = nil
		for i=1,#module.db.spellDB do
			for j=3,7 do
				if module.db.spellDB[i][j] then
					if tonumber( string.gsub(sett,";%d",""),nil ) == module.db.spellDB[i][j][1] then
						bool = true
					end
				end
			end
		end
		if not bool then
			cleanUP [#cleanUP + 1] = sett
		end
	end
	for i=1,#cleanUP do
		VExRT.ExCD2.CDECol[cleanUP[i]] = nil
	end
	table_wipe2(cleanUP)
	for sid,val in pairs(VExRT.ExCD2.CDE) do
		local bool = nil
		for i=1,#module.db.spellDB do
			if sid == module.db.spellDB[i][1] then
				bool = true
			end
		end
		if not bool then
			cleanUP [#cleanUP + 1] = sid
		end
	end
	for i=1,#cleanUP do
		VExRT.ExCD2.CDE[cleanUP[i]] = nil
	end
	table_wipe2(cleanUP)
	for sid,val in pairs(VExRT.ExCD2.Priority) do
		local bool = nil
		for i=1,#module.db.spellDB do
			if sid == module.db.spellDB[i][1] then
				bool = true
			end
		end
		if not bool then
			cleanUP [#cleanUP + 1] = sid
		end
	end
	for i=1,#cleanUP do
		VExRT.ExCD2.Priority[cleanUP[i]] = nil
	end
end

local function CreateBlackList(text)
	local blacklist = {}
	local tmpList = {strsplit("\n", text)}
	for i=1,#tmpList do
		if tmpList[i]~="" then
			if tmpList[i]:find(":(%d+)") then
				local name,spellID = tmpList[i]:match("([^:]+):(%d+)")
				if name and spellID then
					spellID = tonumber(spellID)
					blacklist[ spellID ] = blacklist[ spellID ] or {}
					name = name:lower()
					blacklist[ spellID ][name] = true
				end
			else
				tmpList[i] = tmpList[i]:lower()
				blacklist[ tmpList[i] ] = true
			end
		end
	end
	return blacklist
end
local function CreateWhiteList(text)
	if text == "" then
		return
	end
	local whitelist = {}
	local tmpList = {strsplit("\n", text)}
	for i=1,#tmpList do
		if tmpList[i]~="" then
			tmpList[i] = tmpList[i]:lower()
			whitelist[ tmpList[i] ] = true
		end
	end
	return whitelist
end

local lastSplitsReload = 0
function module:ReloadAllSplits(argScaleFix)
	local _ctime = GetTime()
	if lastSplitsReload > _ctime then
		return
	end
	lastSplitsReload = _ctime + 0.05
	local VExRT_ColumnOptions = VExRT.ExCD2.colSet
	local Width = 0
	local maxHeight = 0
	local maxLine = VExRT_ColumnOptions[module.db.maxColumns+1].frameLines or module.db.colsDefaults.frameLines
	local maxBetweenLines = 0
	if VExRT_ColumnOptions[module.db.maxColumns+1].frameColumns then
		maxLine = ceil(maxLine / VExRT_ColumnOptions[module.db.maxColumns+1].frameColumns)
	end	

	for i=1,module.db.maxColumns do 
		local columnFrame = module.frame.colFrame[i]
		if not columnFrame.LOADEDs then
			columnFrame.LOADEDs = {}
		end
	
		columnFrame.iconSize = (not VExRT_ColumnOptions[i].iconGeneral and VExRT_ColumnOptions[i].iconSize) or (VExRT_ColumnOptions[i].iconGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].iconSize) or module.db.colsDefaults.iconSize
		if VExRT_ColumnOptions[i].enabled and columnFrame.iconSize > maxHeight then
			maxHeight = columnFrame.iconSize
		end
		
		local frameBetweenLines = (not VExRT_ColumnOptions[i].frameGeneral and VExRT_ColumnOptions[i].frameBetweenLines) or (VExRT_ColumnOptions[i].frameGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].frameBetweenLines) or module.db.colsDefaults.frameBetweenLines

		local frameColumns = (not VExRT_ColumnOptions[i].frameGeneral and VExRT_ColumnOptions[i].frameColumns) or (VExRT_ColumnOptions[i].frameGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].frameColumns) or module.db.colsDefaults.frameColumns
		columnFrame.frameColumns = frameColumns
		local linesShown = (not VExRT_ColumnOptions[i].frameGeneral and VExRT_ColumnOptions[i].frameLines) or (VExRT_ColumnOptions[i].frameGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].frameLines) or module.db.colsDefaults.frameLines	
		linesShown = ceil(linesShown / frameColumns)
		local linesTotal = linesShown * frameColumns
		if VExRT.ExCD2.SplitOpt then 
			columnFrame:SetHeight(columnFrame.iconSize*linesShown+frameBetweenLines*(linesShown-1)) 
		else
			columnFrame:SetHeight(columnFrame.iconSize*linesShown)
			if VExRT_ColumnOptions[i].enabled then
				if linesShown > maxLine then
					maxLine = linesShown
				end
				local nowBetweenLines = frameBetweenLines*(linesShown-1)
				if nowBetweenLines > maxBetweenLines then
					maxBetweenLines = nowBetweenLines
				end
			end
		end
		
		if VExRT_ColumnOptions[i].enabled then
			for j=1,linesTotal do
				if not columnFrame.LOADEDs[j] then
					columnFrame.lines[j] = CreateBar(columnFrame)
					columnFrame.lines[j]:Hide()
					columnFrame.LOADEDs[j] = true
				end
			end
		end

		local frameAlpha = (not VExRT_ColumnOptions[i].frameGeneral and VExRT_ColumnOptions[i].frameAlpha) or (VExRT_ColumnOptions[i].frameGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].frameAlpha) or module.db.colsDefaults.frameAlpha
		columnFrame:SetAlpha(frameAlpha/100) 

		local frameScale = (not VExRT_ColumnOptions[i].frameGeneral and VExRT_ColumnOptions[i].frameScale) or (VExRT_ColumnOptions[i].frameGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].frameScale) or module.db.colsDefaults.frameScale
		if VExRT.ExCD2.SplitOpt then 
			if argScaleFix == "ScaleFix" then
				ExRT.F.SetScaleFix(columnFrame,frameScale/100)
			else
				columnFrame:SetScale(frameScale/100) 
			end
		else
			columnFrame:SetScale(1)
		end
		
		local blackBack = (not VExRT_ColumnOptions[i].frameGeneral and VExRT_ColumnOptions[i].frameBlackBack) or (VExRT_ColumnOptions[i].frameGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].frameBlackBack) or module.db.colsDefaults.frameBlackBack
		columnFrame.texture:SetTexture(0,0,0,blackBack / 100)
		
		--> View options
		columnFrame.optionClassColorBackground = (not VExRT_ColumnOptions[i].textureGeneral and VExRT_ColumnOptions[i].textureClassBackground) or (VExRT_ColumnOptions[i].textureGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].textureClassBackground)
		columnFrame.optionClassColorTimeLine = (not VExRT_ColumnOptions[i].textureGeneral and VExRT_ColumnOptions[i].textureClassTimeLine) or (VExRT_ColumnOptions[i].textureGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].textureClassTimeLine)
		columnFrame.optionClassColorText = (not VExRT_ColumnOptions[i].textureGeneral and VExRT_ColumnOptions[i].textureClassText) or (VExRT_ColumnOptions[i].textureGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].textureClassText)

		columnFrame.optionAnimation = (not VExRT_ColumnOptions[i].textureGeneral and VExRT_ColumnOptions[i].textureAnimation) or (VExRT_ColumnOptions[i].textureGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].textureAnimation)
		columnFrame.optionLinesMax = min(linesShown*frameColumns,module.db.maxLinesInCol)
		columnFrame.optionShownOnCD = (not VExRT_ColumnOptions[i].methodsGeneral and VExRT_ColumnOptions[i].methodsShownOnCD) or (VExRT_ColumnOptions[i].methodsGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].methodsShownOnCD)
		columnFrame.optionIconPosition = (not VExRT_ColumnOptions[i].iconGeneral and VExRT_ColumnOptions[i].iconPosition) or (VExRT_ColumnOptions[i].iconGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].iconPosition) or module.db.colsDefaults.iconPosition
		columnFrame.optionStyleAnimation = (not VExRT_ColumnOptions[i].methodsGeneral and VExRT_ColumnOptions[i].methodsStyleAnimation) or (VExRT_ColumnOptions[i].methodsGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].methodsStyleAnimation) or module.db.colsDefaults.methodsStyleAnimation
		columnFrame.optionTimeLineAnimation = (not VExRT_ColumnOptions[i].methodsGeneral and VExRT_ColumnOptions[i].methodsTimeLineAnimation) or (VExRT_ColumnOptions[i].methodsGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].methodsTimeLineAnimation) or module.db.colsDefaults.methodsTimeLineAnimation
		columnFrame.optionCooldown = (not VExRT_ColumnOptions[i].iconGeneral and VExRT_ColumnOptions[i].methodsCooldown) or (VExRT_ColumnOptions[i].iconGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].methodsCooldown)
		columnFrame.optionIconName = (not VExRT_ColumnOptions[i].textGeneral and VExRT_ColumnOptions[i].textIconName) or (VExRT_ColumnOptions[i].textGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].textIconName)
		columnFrame.optionHideSpark = (not VExRT_ColumnOptions[i].textureGeneral and VExRT_ColumnOptions[i].textureHideSpark) or (VExRT_ColumnOptions[i].textureGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].textureHideSpark)
		columnFrame.optionIconTitles = (not VExRT_ColumnOptions[i].iconGeneral and VExRT_ColumnOptions[i].iconTitles) or (VExRT_ColumnOptions[i].iconGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].iconTitles)
			columnFrame.optionIconTitles = columnFrame.optionIconTitles and not (columnFrame.optionIconPosition == 3)
		columnFrame.optionIconHideBlizzardEdges = (not VExRT_ColumnOptions[i].iconGeneral and VExRT_ColumnOptions[i].iconHideBlizzardEdges) or (VExRT_ColumnOptions[i].iconGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].iconHideBlizzardEdges)
		
		columnFrame.methodsIconTooltip = (not VExRT_ColumnOptions[i].methodsGeneral and VExRT_ColumnOptions[i].methodsIconTooltip) or (VExRT_ColumnOptions[i].methodsGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].methodsIconTooltip) 
		columnFrame.methodsLineClick = (not VExRT_ColumnOptions[i].methodsGeneral and VExRT_ColumnOptions[i].methodsLineClick) or (VExRT_ColumnOptions[i].methodsGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].methodsLineClick)
		columnFrame.methodsNewSpellNewLine = (not VExRT_ColumnOptions[i].methodsGeneral and VExRT_ColumnOptions[i].methodsNewSpellNewLine) or (VExRT_ColumnOptions[i].methodsGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].methodsNewSpellNewLine)
		columnFrame.methodsSortingRules = (not VExRT_ColumnOptions[i].methodsGeneral and VExRT_ColumnOptions[i].methodsSortingRules) or (VExRT_ColumnOptions[i].methodsGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].methodsSortingRules) or module.db.colsDefaults.methodsSortingRules
		columnFrame.methodsHideOwnSpells = (not VExRT_ColumnOptions[i].methodsGeneral and VExRT_ColumnOptions[i].methodsHideOwnSpells) or (VExRT_ColumnOptions[i].methodsGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].methodsHideOwnSpells)
		columnFrame.methodsAlphaNotInRange = (not VExRT_ColumnOptions[i].methodsGeneral and VExRT_ColumnOptions[i].methodsAlphaNotInRange) or (VExRT_ColumnOptions[i].methodsGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].methodsAlphaNotInRange)
		columnFrame.methodsAlphaNotInRangeNum = (not VExRT_ColumnOptions[i].methodsGeneral and VExRT_ColumnOptions[i].methodsAlphaNotInRangeNum) or (VExRT_ColumnOptions[i].methodsGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].methodsAlphaNotInRangeNum) or module.db.colsDefaults.methodsAlphaNotInRangeNum
			columnFrame.methodsAlphaNotInRangeNum = columnFrame.methodsAlphaNotInRangeNum / 100
		columnFrame.methodsDisableActive = (not VExRT_ColumnOptions[i].methodsGeneral and VExRT_ColumnOptions[i].methodsDisableActive) or (VExRT_ColumnOptions[i].methodsGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].methodsDisableActive)

		columnFrame.textTemplateLeft = (not VExRT_ColumnOptions[i].textGeneral and VExRT_ColumnOptions[i].textTemplateLeft) or (VExRT_ColumnOptions[i].textGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].textTemplateLeft) or module.db.colsDefaults.textTemplateLeft
		columnFrame.textTemplateRight = (not VExRT_ColumnOptions[i].textGeneral and VExRT_ColumnOptions[i].textTemplateRight) or (VExRT_ColumnOptions[i].textGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].textTemplateRight) or module.db.colsDefaults.textTemplateRight
		columnFrame.textTemplateCenter = (not VExRT_ColumnOptions[i].textGeneral and VExRT_ColumnOptions[i].textTemplateCenter) or (VExRT_ColumnOptions[i].textGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].textTemplateCenter) or module.db.colsDefaults.textTemplateCenter
		
		local blacklistText = (not VExRT_ColumnOptions[i].blacklistGeneral and VExRT_ColumnOptions[i].blacklistText) or (VExRT_ColumnOptions[i].blacklistGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].blacklistText) or module.db.colsDefaults.blacklistText
		columnFrame.BlackList = CreateBlackList(blacklistText)
		local whitelistText = (not VExRT_ColumnOptions[i].blacklistGeneral and VExRT_ColumnOptions[i].whitelistText) or (VExRT_ColumnOptions[i].blacklistGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].whitelistText) or module.db.colsDefaults.whitelistText
		columnFrame.WhiteList = CreateWhiteList(whitelistText)
		
		local frameWidth = (not VExRT_ColumnOptions[i].frameGeneral and VExRT_ColumnOptions[i].frameWidth) or (VExRT_ColumnOptions[i].frameGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].frameWidth) or module.db.colsDefaults.frameWidth
		columnFrame:SetWidth(frameWidth*frameColumns)
		columnFrame.barWidth = frameWidth
		
		columnFrame.optionGray = (not VExRT_ColumnOptions[i].iconGeneral and VExRT_ColumnOptions[i].iconGray) or (VExRT_ColumnOptions[i].iconGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].iconGray)
		columnFrame.fontSize = (not VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[i].fontSize) or (VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].fontSize) or module.db.colsDefaults.fontSize
		columnFrame.fontName = (not VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[i].fontName) or (VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].fontName) or module.db.colsDefaults.fontName
		columnFrame.fontOutline = (not VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[i].fontOutline) or (VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].fontOutline)
		columnFrame.fontShadow = (not VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[i].fontShadow) or (VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].fontShadow)
		columnFrame.textureFile = (not VExRT_ColumnOptions[i].textureGeneral and VExRT_ColumnOptions[i].textureFile) or (VExRT_ColumnOptions[i].textureGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].textureFile) or module.db.colsDefaults.textureFile
		columnFrame.textureBorderSize = (not VExRT_ColumnOptions[i].textureGeneral and VExRT_ColumnOptions[i].textureBorderSize) or (VExRT_ColumnOptions[i].textureGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].textureBorderSize) or module.db.colsDefaults.textureBorderSize

		columnFrame.textureBorderColorR = (not VExRT_ColumnOptions[i].textureGeneral and VExRT_ColumnOptions[i].textureBorderColorR) or (VExRT_ColumnOptions[i].textureGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].textureBorderColorR) or module.db.colsDefaults.textureBorderColorR
		columnFrame.textureBorderColorG = (not VExRT_ColumnOptions[i].textureGeneral and VExRT_ColumnOptions[i].textureBorderColorG) or (VExRT_ColumnOptions[i].textureGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].textureBorderColorG) or module.db.colsDefaults.textureBorderColorG
		columnFrame.textureBorderColorB = (not VExRT_ColumnOptions[i].textureGeneral and VExRT_ColumnOptions[i].textureBorderColorB) or (VExRT_ColumnOptions[i].textureGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].textureBorderColorB) or module.db.colsDefaults.textureBorderColorB
		columnFrame.textureBorderColorA = (not VExRT_ColumnOptions[i].textureGeneral and VExRT_ColumnOptions[i].textureBorderColorA) or (VExRT_ColumnOptions[i].textureGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].textureBorderColorA) or module.db.colsDefaults.textureBorderColorA

		local fontOtherAvailable = (not VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[i].fontOtherAvailable) or (VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].fontOtherAvailable)

		columnFrame.fontLeftSize = (not fontOtherAvailable and columnFrame.fontSize) or (not VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[i].fontLeftSize) or (VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].fontLeftSize) or module.db.colsDefaults.fontSize
		columnFrame.fontLeftName = (not fontOtherAvailable and columnFrame.fontName) or (not VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[i].fontLeftName) or (VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].fontLeftName) or module.db.colsDefaults.fontName
		columnFrame.fontLeftOutline = (not fontOtherAvailable and columnFrame.fontOutline) or (fontOtherAvailable and ((not VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[i].fontLeftOutline) or (VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].fontLeftOutline)))
		columnFrame.fontLeftShadow = (not fontOtherAvailable and columnFrame.fontShadow) or (fontOtherAvailable and ((not VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[i].fontLeftShadow) or (VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].fontLeftShadow)))

		columnFrame.fontRightSize = (not fontOtherAvailable and columnFrame.fontSize) or (not VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[i].fontRightSize) or (VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].fontRightSize) or module.db.colsDefaults.fontSize
		columnFrame.fontRightName = (not fontOtherAvailable and columnFrame.fontName) or (not VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[i].fontRightName) or (VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].fontRightName) or module.db.colsDefaults.fontName
		columnFrame.fontRightOutline = (not fontOtherAvailable and columnFrame.fontOutline) or (fontOtherAvailable and ((not VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[i].fontRightOutline) or (VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].fontRightOutline)))
		columnFrame.fontRightShadow = (not fontOtherAvailable and columnFrame.fontShadow) or (fontOtherAvailable and ((not VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[i].fontRightShadow) or (VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].fontRightShadow)))

		columnFrame.fontCenterSize = (not fontOtherAvailable and columnFrame.fontSize) or (not VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[i].fontCenterSize) or (VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].fontCenterSize) or module.db.colsDefaults.fontSize
		columnFrame.fontCenterName = (not fontOtherAvailable and columnFrame.fontName) or (not VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[i].fontCenterName) or (VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].fontCenterName) or module.db.colsDefaults.fontName
		columnFrame.fontCenterOutline = (not fontOtherAvailable and columnFrame.fontOutline) or (fontOtherAvailable and ((not VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[i].fontCenterOutline) or (VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].fontCenterOutline)))
		columnFrame.fontCenterShadow = (not fontOtherAvailable and columnFrame.fontShadow) or (fontOtherAvailable and ((not VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[i].fontCenterShadow) or (VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].fontCenterShadow)))

		columnFrame.fontIconSize = (not fontOtherAvailable and columnFrame.fontSize) or (not VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[i].fontIconSize) or (VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].fontIconSize) or module.db.colsDefaults.fontSize
		columnFrame.fontIconName = (not fontOtherAvailable and columnFrame.fontName) or (not VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[i].fontIconName) or (VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].fontIconName) or module.db.colsDefaults.fontName
		columnFrame.fontIconOutline = (not fontOtherAvailable and columnFrame.fontOutline) or (fontOtherAvailable and ((not VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[i].fontIconOutline) or (VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].fontIconOutline)))
		columnFrame.fontIconShadow = (not fontOtherAvailable and columnFrame.fontShadow) or (fontOtherAvailable and ((not VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[i].fontIconShadow) or (VExRT_ColumnOptions[i].fontGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].fontIconShadow)))

		for j=1,3 do
			for n=1,3 do
				local object = colorSetupFrameColorsObjectsNames[j]
				local state = colorSetupFrameColorsNames[n]
				if not columnFrame["optionColor"..object..state] then
					columnFrame["optionColor"..object..state] = {}
				end

				columnFrame["optionColor"..object..state].r = (not VExRT_ColumnOptions[i].textureGeneral and VExRT_ColumnOptions[i]["textureColor"..object..state.."R"]) or (VExRT_ColumnOptions[i].textureGeneral and VExRT_ColumnOptions[module.db.maxColumns+1]["textureColor"..object..state.."R"]) or module.db.colsDefaults["textureColor"..object..state.."R"]
				columnFrame["optionColor"..object..state].g = (not VExRT_ColumnOptions[i].textureGeneral and VExRT_ColumnOptions[i]["textureColor"..object..state.."G"]) or (VExRT_ColumnOptions[i].textureGeneral and VExRT_ColumnOptions[module.db.maxColumns+1]["textureColor"..object..state.."G"]) or module.db.colsDefaults["textureColor"..object..state.."G"]
				columnFrame["optionColor"..object..state].b = (not VExRT_ColumnOptions[i].textureGeneral and VExRT_ColumnOptions[i]["textureColor"..object..state.."B"]) or (VExRT_ColumnOptions[i].textureGeneral and VExRT_ColumnOptions[module.db.maxColumns+1]["textureColor"..object..state.."B"]) or module.db.colsDefaults["textureColor"..object..state.."B"]
			end
		end

		columnFrame.optionAlphaBackground = (not VExRT_ColumnOptions[i].textureGeneral and VExRT_ColumnOptions[i].textureAlphaBackground) or (VExRT_ColumnOptions[i].textureGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].textureAlphaBackground) or module.db.colsDefaults.textureAlphaBackground
		columnFrame.optionAlphaTimeLine = (not VExRT_ColumnOptions[i].textureGeneral and VExRT_ColumnOptions[i].textureAlphaTimeLine) or (VExRT_ColumnOptions[i].textureGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].textureAlphaTimeLine) or module.db.colsDefaults.textureAlphaTimeLine
		columnFrame.optionAlphaCooldown = (not VExRT_ColumnOptions[i].textureGeneral and VExRT_ColumnOptions[i].textureAlphaCooldown) or (VExRT_ColumnOptions[i].textureGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].textureAlphaCooldown) or module.db.colsDefaults.textureAlphaCooldown

		if VExRT_ColumnOptions[i].enabled then
			for n=1,linesTotal do
				columnFrame.lines[n]:UpdateStyle()
				if columnFrame.lines[n]:IsVisible() then
					columnFrame.lines[n]:UpdateStatus()
				end
			end
		
			local frameAnchorBottom = (not VExRT_ColumnOptions[i].methodsGeneral and VExRT_ColumnOptions[i].frameAnchorBottom) or (VExRT_ColumnOptions[i].methodsGeneral and VExRT_ColumnOptions[module.db.maxColumns+1].frameAnchorBottom)
			if frameAnchorBottom then
				local lastLine = nil
				for n=1,linesTotal do 
					local inLine = (n-1) % frameColumns
					local line = ((n-1) - inLine) / frameColumns
					columnFrame.lines[n]:ClearAllPoints() 
					columnFrame.lines[n]:SetPoint("BOTTOMLEFT", inLine*frameWidth, line*columnFrame.iconSize+line*frameBetweenLines) 
					
					if line ~= lastLine then
						columnFrame.lines[n].IsNewLine = true
					else
						columnFrame.lines[n].IsNewLine = nil
					end
					lastLine = line
				end
			else
				local lastLine = nil
				for n=1,linesTotal do 
					local inLine = (n-1) % frameColumns
					local line = ExRT.F.Round( ((n-1) - inLine) / frameColumns )
					columnFrame.lines[n]:ClearAllPoints()
					columnFrame.lines[n]:SetPoint("TOPLEFT", inLine*frameWidth, -line*columnFrame.iconSize-line*frameBetweenLines) 
					
					if line ~= lastLine then
						columnFrame.lines[n].IsNewLine = true
					else
						columnFrame.lines[n].IsNewLine = nil
					end
					lastLine = line
				end
			end
		end
		
		if VExRT_ColumnOptions[i].enabled and VExRT.ExCD2.enabled then
			columnFrame:Show()
		else
			columnFrame:Hide()
		end
		if not VExRT.ExCD2.SplitOpt then
			columnFrame:ClearAllPoints()
			columnFrame:SetPoint("TOPLEFT",module.frame,Width, 0)
		else
			if VExRT_ColumnOptions[i].posX and VExRT_ColumnOptions[i].posY then
				columnFrame:ClearAllPoints()
				columnFrame:SetPoint("TOPLEFT",UIParent,"BOTTOMLEFT",VExRT_ColumnOptions[i].posX,VExRT_ColumnOptions[i].posY)
			else
				columnFrame:ClearAllPoints()
				columnFrame:SetPoint("CENTER",UIParent,"CENTER",0,0)
			end
		end
		if VExRT_ColumnOptions[i].enabled then
			Width = Width + frameWidth*frameColumns
		end
	end
	module.frame:SetWidth(Width)
	module.frame:SetHeight(maxHeight*maxLine + maxBetweenLines)
	module.frame:SetAlpha((VExRT_ColumnOptions[module.db.maxColumns+1].frameAlpha or module.db.colsDefaults.frameAlpha)/100)
	if argScaleFix == "ScaleFix" then
		ExRT.F.SetScaleFix(module.frame,(VExRT_ColumnOptions[module.db.maxColumns+1].frameScale or module.db.colsDefaults.frameScale)/100)
	else
		module.frame:SetScale((VExRT_ColumnOptions[module.db.maxColumns+1].frameScale or module.db.colsDefaults.frameScale)/100) 
	end
	
 	SortAllData()
 	UpdateAllData()
end

function module:SplitExCD2Window()
	if VExRT.ExCD2.SplitOpt then
		for i=1,module.db.maxColumns do 
			module.frame.colFrame[i]:SetParent(UIParent)
			module.frame.colFrame[i]:EnableMouse(false)

			if not VExRT.ExCD2.lock then 
				ExRT.F.LockMove(module.frame.colFrame[i],true,module.frame.colFrame[i].lockTexture)
				ExRT.lib.AddShadowComment(module.frame.colFrame[i],nil,L.cd2,i,72,"OUTLINE")
			end
		end
		module.frame:Hide()
	else
		for i=1,module.db.maxColumns do 
			module.frame.colFrame[i]:SetParent(module.frame)
			ExRT.F.LockMove(module.frame.colFrame[i],nil,module.frame.colFrame[i].lockTexture)
			ExRT.lib.AddShadowComment(module.frame.colFrame[i],1)
		end
		module.frame:Show()
	end

end

function module:slash(arg1,arg2)
	if string.find(arg1,"runcd ") then
		local sid,name = arg2:match("%a+ (%d+) (.+)")
		if sid and name then
			print("Run CD "..sid.." by "..name)
			module.main:COMBAT_LOG_EVENT_UNFILTERED(nil,"SPELL_CAST_SUCCESS",nil,nil,name,nil,nil,nil,nil,nil,nil,sid)
		end
	elseif string.find(arg1,"resetcd ") then
		local sid,name = arg2:match("%a+ (%d+) (.+)")
		if sid and name then
			print("Reset CD "..sid.." by "..name)
			local j = module.db.cdsNav[name][sid]
			if j then
				j[3] = 0
			end
		end
	end
end

module.db.AllClassSpellsInText = [[
local module = GExRT.A.ExCD2
module.db.allClassSpells = {
["WARRIOR"] = {
	{107574,3,	{107574,90,	20},	nil,			nil,			nil,			},	--Avatar
	{18499,	3,	{18499,	30,	6},	nil,			nil,			nil,			},	--Berserker Rage
	{46924,	3,	{46924,	60,	6},	nil,			nil,			nil,			},	--Bladestorm
	{12292,	3,	{12292,	60,	12},	nil,			nil,			nil,			},	--Bloodbath
	{100,	3,	{100,	20,	0},	nil,			nil,			nil,			},	--Charge
	{1160,	3,	nil,			nil,			nil,			{1160,	60,	8},	},	--Demoralizing Shout
	{118038,3,	nil,			{118038,120,	8},	{118038,120,	8},	nil,			},	--Die by the Sword
	{118000,3,	{118000,60,	0},	nil,			nil,			nil,			},	--Dragon Roar
	{55694,	4,	{55694,	60,	5},	nil,			nil,			nil,			},	--Enraged Regeneration
	{52174,	3,	{52174,	45,	0},	nil,			nil,			nil,			},	--Heroic Leap
	{103840,4,	{103840,30,	0},	nil,			nil,			nil,			},	--Impending Victory
	{3411,	2,	{3411,	30,	10},	nil,			nil,			nil,			},	--Intervene
	{5246,	3,	{5246,	90,	0},	nil,			nil,			nil,			},	--Intimidating Shout
	{12975,	4,	nil,			nil,			nil,			{12975,	180,	15},	},	--Last Stand
	{114028,1,	{114028,30,	5},	nil,			nil,			nil,			},	--Mass Spell Reflection
	{114192,1,	nil,			nil,			nil,			{114192,180,	30},	},	--Mocking Banner
	{6552,	5,	{6552,	15,	0},	nil,			nil,			nil,			},	--Pummel
	{97462,	1,	nil,			{97462,	180,	10},	{97462,	180,	10},	nil,			},	--Rallying Cry
	{152277,3,	{152277,60,	10},	nil,			nil,			nil,			},	--Ravager
	{1719,	3,	nil,			{1719,	180,	10},	{1719,	180,	10},	nil,			},	--Recklessness
	{114029,2,	{114029,30,	6},	nil,			nil,			nil,			},	--Safeguard
	{64382,	3,	{64382,	300,	0},	nil,			nil,			nil,			},	--Shattering Throw
	{871,	4,	nil,			nil,			nil,			{871,	180,	8},	},	--Shield Wall
	{46968,	3,	{46968,	40,	0},	nil,			nil,			nil,			},	--Shockwave
	{176289,3,	nil,			{176289,45,	0},	{176289,45,	0},	nil,			},	--Siegebreaker
	{23920,	4,	{23920,	25,	5},	nil,			nil,			nil,			},	--Spell Reflection
	{107570,3,	{107570,30,	0},	nil,			nil,			nil,			},	--Storm Bolt
	{12328,	3,	nil,			{12328,	15,	0},	nil,			nil,			},	--Sweeping Strikes
	{355,	5,	{355,	8,	0},	nil,			nil,			nil,			},	--Taunt
	{114030,2,	{114030,120,	12},	nil,			nil,			nil,			},	--Vigilance
},
["PALADIN"] = {
	{31850,	4,	nil,			nil,			{31850,	180,	10},	nil,			},	--Ardent Defender
	{31842,	3,	nil,			{31842,	180,	0},	nil,			nil,			},	--Avenging Wrath
	{31884,	3,	nil,			nil,			nil,			{31884,	120,	0},	},	--Avenging Wrath
	{157007,3,	nil,			{157007,15,	0},	nil,			nil,			},	--Beacon of Insight
	{115750,3,	{115750,120,	0},	nil,			nil,			nil,			},	--Blinding Light
	{4987,	5,	{4987,	8,	0},	nil,			nil,			nil,			},	--Cleanse
	{31821,	1,	nil,			{31821,	180,	6},	nil,			nil,			},	--Devotion Aura
	{498,	4,	{498,	60,	8},	nil,			nil,			nil,			},	--Divine Protection
	{642,	3,	{642,	300,	10},	nil,			nil,			nil,			},	--Divine Shield
	{114157,3,	{114157,60,	10},	nil,			nil,			nil,			},	--Execution Sentence
	{105593,3,	{105593,30,	0},	nil,			nil,			nil,			},	--Fist of Justice
	{86659,	4,	nil,			nil,			{86659,	180,	8},	nil,			},	--Guardian of Ancient Kings
	{853,	3,	{853,	60,	0},	nil,			nil,			nil,			},	--Hammer of Justice
	{1044,	2,	{1044,	25,	6},	nil,			nil,			nil,			},	--Hand of Freedom
	{1022,	2,	{1022,	300,	10},	nil,			nil,			nil,			},	--Hand of Protection
	{114039,2,	{114039,30,	6},	nil,			nil,			nil,			},	--Hand of Purity
	{6940,	2,	{6940,	120,	12},	nil,			nil,			{6940,	90,	12},	},	--Hand of Sacrifice
	{1038,	2,	nil,			nil,			{1038,	120,	10},	nil,			},	--Hand of Salvation
	{105809,3,	{105809,120,	18},	nil,			nil,			nil,			},	--Holy Avenger
	{114165,3,	{114165,20,	0},	nil,			nil,			nil,			},	--Holy Prism
	{633,	2,	{633,	600,	0},	nil,			nil,			nil,			},	--Lay on Hands
	{114158,3,	{114158,60,	14},	nil,			nil,			nil,			},	--Light's Hammer
	{96231,	5,	{96231,	15,	0},	nil,			nil,			nil,			},	--Rebuke
	{62124,	5,	{62124,	8,	0},	nil,			nil,			nil,			},	--Reckoning
	{20066,	3,	{20066,	15,	0},	nil,			nil,			nil,			},	--Repentance
	{152262,3,	nil,			nil,			{152262,30,	15},	{152262,30,	15},	},	--Seraphim
	{85499,	3,	{85499,	45,	8},	nil,			nil,			nil,			},	--Speed of Light
	{10326,	3,	{10326,	15,	0},	nil,			nil,			nil,			},	--Turn Evil
},
["HUNTER"] = {
	{131894,3,	{131894,60,	0},	nil,			nil,			nil,			},	--A Murder of Crows
	--{172106,1,	{172106,180,	6},	nil,			nil,			nil,			},	--Aspect of the Fox	R.I.P. 6.0 - 6.1 Best CD ever :'(
	{120360,3,	{120360,20,	0},	nil,			nil,			nil,			},	--Barrage
	{19574,	3,	nil,			{19574,	60,	10},	nil,			nil,			},	--Bestial Wrath
	{109248,3,	{109248,45,	0},	nil,			nil,			nil,			},	--Binding Shot
	{51753,	4,	{51753,	60,	0},	nil,			nil,			nil,			},	--Camouflage
	{147362,5,	{147362,24,	0},	nil,			nil,			nil,			},	--Counter Shot
	{19263,	4,	{148467,180,	5},	nil,			nil,			nil,			},	--Deterrence
	{120679,3,	{120679,30,	15},	nil,			nil,			nil,			},	--Dire Beast
	{781,	4,	{781,	20,	0},	nil,			nil,			nil,			},	--Disengage
	{20736,	5,	{20736,	8,	0},	nil,			nil,			nil,			},	--Distracting Shot
	{109304,4,	{109304,120,	0},	nil,			nil,			nil,			},	--Exhilaration
	{13813,	3,	{13813,	30,	0},	nil,			nil,			{13813,	21,	0},	},	--Explosive Trap
	{5384,	4,	{5384,	30,	0},	nil,			nil,			nil,			},	--Feign Death
	{1543,	3,	{1543,	20,	0},	nil,			nil,			nil,			},	--Flare
	{1499,	3,	{1499,	30,	0},	nil,			nil,			{1499,	21,	0},	},	--Freezing Trap
	{117050,3,	{117050,15,	0},	nil,			nil,			nil,			},	--Glaive Toss
	{13809,	3,	{13809,	30,	0},	nil,			nil,			{13809,	21,	0},	},	--Ice Trap
	{19577,	3,	{19577,	60,	0},	nil,			nil,			nil,			},	--Intimidation
	{53271,	2,	{53271,	45,	4},	nil,			nil,			nil,			},	--Master's Call
	{34477,	3,	{34477,	30,	0},	nil,			nil,			nil,			},	--Misdirection
	{109259,3,	{109259,45,	0},	nil,			nil,			nil,			},	--Powershot
	{3045,	3,	nil,			nil,			{3045,	120,	0},	nil,			},	--Rapid Fire
	{121818,3,	{121818,300,	0},	nil,			nil,			nil,			},	--Stampede
	{19386,	3,	{19386,	45,	0},	nil,			nil,			nil,			},	--Wyvern Sting
},
["ROGUE"] = {
	{13750,	3,	nil,			nil,			{13750,	180,	15},	nil,			},	--Adrenaline Rush
	{2094,	3,	{2094,	120,	0},	nil,			nil,			nil,			},	--Blind
	{31224,	4,	{31224,	90,	5},	nil,			nil,			nil,			},	--Cloak of Shadows
	{74001,	4,	{74001,	120,	20},	nil,			nil,			nil,			},	--Combat Readiness
	{152150,3,	{152150,20,	0},	nil,			nil,			nil,			},	--Death from Above
	{1725,	3,	{1725,	30,	0},	nil,			nil,			nil,			},	--Distract
	{5277,	4,	{5277,	120,	10},	nil,			nil,			nil,			},	--Evasion
	{1776,	3,	{1776,	10,	0},	nil,			nil,			nil,			},	--Gouge
	{1766,	5,	{1766,	15,	0},	nil,			nil,			nil,			},	--Kick
	{408,	3,	{408,	20,	0},	nil,			nil,			nil,			},	--Kidney Shot
	{51690,	3,	nil,			nil,			{51690,	120,	3},	nil,			},	--Killing Spree
	{137619,3,	{137619,60,	0},	nil,			nil,			nil,			},	--Marked for Death
	{14183,	3,	nil,			nil,			nil,			{14183,	20,	0},	},	--Premeditation
	{14185,	3,	{14185,	300,	0},	nil,			nil,			nil,			},	--Preparation
	{51713,	3,	nil,			nil,			nil,			{51713,	60,	10},	},	--Shadow Dance
	{152151,3,	{152151,120,	8},	nil,			nil,			nil,			},	--Shadow Reflection
	{36554,	3,	{36554,	20,	0},	nil,			nil,			nil,			},	--Shadowstep
	{5938,	3,	{5938,	10,	0},	nil,			nil,			nil,			},	--Shiv
	{114018,1,	{114018,300,	15},	nil,			nil,			nil,			},	--Shroud of Concealment
	{76577,	1,	{76577,	180,	5},	nil,			nil,			nil,			},	--Smoke Bomb
	{2983,	3,	{2983,	60,	8},	nil,			nil,			nil,			},	--Sprint
	{57934,	3,	{57934,	30,	6},	nil,			nil,			nil,			},	--Tricks of the Trade
	{1856,	4,	{1856,	120,	6},	nil,			nil,			{1856,	90,	6},	},	--Vanish
	{79140,	3,	nil,			{79140,	120,	20},	nil,			nil,			},	--Vendetta
},
["PRIEST"] = {
	{81700,	3,	nil,			{81700,	30,	18},	nil,			nil,			},	--Archangel
	{121135,3,	nil,			{121135,25,	0},	{121135,25,	0},	{127632,25,	0},	},	--Cascade
	{81209,	3,	nil,			nil,			{81209,	10,	0},	nil,			},	--Chakra: Chastise
	{81206,	3,	nil,			nil,			{81206,	10,	0},	nil,			},	--Chakra: Sanctuary
	{81208,	3,	nil,			nil,			{81208,	10,	0},	nil,			},	--Chakra: Serenity
	{34861,	3,	nil,			nil,			{34861,	12,	0},	nil,			},	--Circle of Healing
	{19236,	4,	{19236,	120,	0},	nil,			nil,			nil,			},	--Desperate Prayer
	{47585,	4,	nil,			nil,			nil,			{47585,	120,	6},	},	--Dispersion
	{64843,	1,	nil,			nil,			{64843,	180,	8},	nil,			},	--Divine Hymn
	{110744,3,	nil,			{110744,15,	0},	{110744,15,	0},	{122121,15,	0},	},	--Divine Star
	{586,	4,	{586,	30,	10},	nil,			nil,			nil,			},	--Fade
	{6346,	2,	{6346,	180,	0},	nil,			nil,			nil,			},	--Fear Ward
	{47788,	2,	nil,			nil,			{47788,	180,	10},	nil,			},	--Guardian Spirit
	{120517,1,	nil,			{120517,40,	0},	{120517,40,	0},	{120644,40,	0},	},	--Halo
	{88625,	3,	nil,			nil,			{88625,	30,	0},	nil,			},	--Holy Word: Chastise
	{88684,	3,	{88684,	10,	0},	nil,			nil,			nil,			},	--Holy Word: Serenity
	{73325,	2,	{73325,	90,	0},	nil,			nil,			nil,			},	--Leap of Faith
	{126135,3,	nil,			nil,			{126135,180,	0},	nil,			},	--Lightwell
	{32375,	5,	{32375,	15,	0},	nil,			nil,			nil,			},	--Mass Dispel
	{123040,3,	{123040,60,	15},	nil,			nil,			nil,			},	--Mindbender
	{33206,	2,	nil,			{33206,	180,	8},	nil,			nil,			},	--Pain Suppression
	{10060,	3,	{10060,	120,	20},	nil,			nil,			nil,			},	--Power Infusion
	{62618,	1,	nil,			{62618,	180,	10},	nil,			nil,			},	--Power Word: Barrier
	{64044,	3,	nil,			nil,			nil,			{64044,	45,	0},	},	--Psychic Horror
	{8122,	3,	{8122,	45,	0},	nil,			nil,			nil,			},	--Psychic Scream
	{34433,	1,	{34433,	180,	0},	nil,			nil,			nil,			},	--Shadowfiend
	{15487,	3,	nil,			{15487,	45,	0},	nil,			{15487,	45,	0},	},	--Silence
	{112833,4,	{112833,30,	6},	nil,			nil,			nil,			},	--Spectral Guise
	{109964,1,	nil,			{109964,60,	10},	nil,			nil,			},	--Spirit Shell
	{15286,	1,	nil,			nil,			nil,			{15286,	180,	15},	},	--Vampiric Embrace
	{108920,3,	{108920,30,	0},	nil,			nil,			nil,			},	--Void Tendrils
	{527,	5,	nil,			{527,	8,	0},	{527,	8,	0},	nil,			},	--Очищение
},
["DEATHKNIGHT"] = {
	{48707,	4,	{48707,	45,	5},	nil,			nil,			nil,			},	--Anti-Magic Shell
	{51052,	1,	{51052,	120,	3},	nil,			nil,			nil,			},	--Anti-Magic Zone
	{42650,	3,	{42650,	600,	0},	nil,			nil,			nil,			},	--Army of the Dead
	{108194,3,	{108194,30,	0},	nil,			nil,			nil,			},	--Asphyxiate
	{49222,	4,	nil,			{49222,	60,	0},	nil,			nil,			},	--Bone Shield
	{152279,3,	{152279,120,	0},	nil,			nil,			nil,			},	--Breath of Sindragosa
	{49028,	3,	nil,			{49028,	90,	8},	nil,			nil,			},	--Dancing Rune Weapon
	{56222,	5,	nil,			{56222,	8,	0},	nil,			nil,			},	--Dark Command
	{77606,	3,	{77606,	60,	0},	nil,			nil,			nil,			},	--Dark Simulacrum
	{49576,	3,	{49576,	25,	0},	{49576,	20,	0},	nil,			nil,			},	--Death Grip
	{48743,	4,	{48743,	120,	0},	nil,			nil,			nil,			},	--Death Pact
	{43265,	3,	{43265,	30,	10},	nil,			nil,			nil,			},	--Death and Decay
	{96268,	4,	{96268,	30,	6},	nil,			nil,			nil,			},	--Death's Advance
	{152280,3,	{152280,30,	0},	nil,			nil,			nil,			},	--Defile
	{108201,4,	{108201,120,	10},	nil,			nil,			nil,			},	--Desecrated Ground
	{47568,	3,	{47568,	300,	0},	nil,			nil,			nil,			},	--Empower Rune Weapon
	{108199,1,	{108199,60,	0},	nil,			nil,			nil,			},	--Gorefiend's Grasp
	{48792,	4,	{48792,	180,	8},	nil,			nil,			nil,			},	--Icebound Fortitude
	{49039,	4,	{49039,	120,	10},	nil,			nil,			nil,			},	--Lichborne
	{47528,	5,	{47528,	15,	0},	nil,			nil,			nil,			},	--Mind Freeze
	{77575,	3,	{77575,	60,	0},	nil,			nil,			nil,			},	--Outbreak
	{51271,	3,	nil,			nil,			{51271,	60,	20},	nil,			},	--Pillar of Frost
	{123693,3,	{123693,25,	0},	nil,			nil,			nil,			},	--Plague Leech
	{61999,	3,	{61999,	600,	0},	nil,			nil,			nil,			},	--Raise Ally
	{46584,	3,	nil,			nil,			nil,			{46584,	60,	0},	},	--Raise Dead
	{108200,3,	{108200,60,	0},	nil,			nil,			nil,			},	--Remorseless Winter
	{47476,	3,	{47476,	60,	0},	nil,			nil,			nil,			},	--Strangulate
	{49206,	3,	nil,			nil,			nil,			{49206,	180,	40},	},	--Summon Gargoyle
	{115989,3,	{115989,90,	10},	nil,			nil,			nil,			},	--Unholy Blight
	{55233,	4,	nil,			{55233,	60,	10},	nil,			nil,			},	--Vampiric Blood
},
["SHAMAN"] = {
	{108281,1,	{108281,120,	10},	nil,			nil,			nil,			},	--Ancestral Guidance
	{16188,	3,	{16188,	90,	0},	nil,			nil,			nil,			},	--Ancestral Swiftness
	{114049,3,	{114049,180,	15},	{114050,180,	15},	{114051,180,	15},	{114052,180,	15},	},	--Ascendance
	{108271,4,	{108271,90,	6},	nil,			nil,			nil,			},	--Astral Shift
	{2825,	3,	{2825,	300,	40},	nil,			nil,			nil,			},	--Bloodlust
	{108285,3,	{108285,180,	0},	nil,			nil,			nil,			},	--Call of the Elements
	{108269,3,	{108269,45,	5},	nil,			nil,			nil,			},	--Capacitor Totem
	{51886,	5,	{51886,	8,	0},	nil,			nil,			{77130,	8,	0},	},	--Cleanse Spirit
	{157153,3,	nil,			nil,			nil,			{157153,30,	15},	},	--Cloudburst Totem
	{2062,	3,	{2062,	300,	0},	nil,			nil,			nil,			},	--Earth Elemental Totem
	{2484,	3,	{2484,	30,	20},	nil,			nil,			nil,			},	--Earthbind Totem
	{51485,	3,	{51485,	30,	20},	nil,			nil,			nil,			},	--Earthgrab Totem
	{117014,3,	{117014,12,	0},	nil,			nil,			nil,			},	--Elemental Blast
	{16166,	3,	{16166,	120,	20},	nil,			nil,			nil,			},	--Elemental Mastery
	{51533,	3,	nil,			nil,			{51533,	120,	30},	nil,			},	--Feral Spirit
	{2894,	3,	{2894,	300,	0},	nil,			nil,			nil,			},	--Fire Elemental Totem
	{8177,	1,	{8177,	25,	0},	nil,			nil,			nil,			},	--Grounding Totem
	{5394,	3,	{5394,	30,	15},	nil,			nil,			nil,			},	--Healing Stream Totem
	{108280,1,	nil,			nil,			nil,			{108280,180,	10},	},	--Healing Tide Totem
	{51514,	3,	{51514,	45,	0},	nil,			nil,			nil,			},	--Hex
	{152255,3,	nil,			{152255,45,	0},	{152255,45,	0},	nil,			},	--Liquid Magma
	{20608,	3,	{21169,	1800,	0},	nil,			nil,			nil,			},	--Reincarnation
	{30823,	4,	nil,			{30823,	60,	15},	{30823,	60,	15},	nil,			},	--Shamanistic Rage
	{98008,	1,	nil,			nil,			nil,			{98008,	180,	6},	},	--Spirit Link Totem
	{58875,	3,	nil,			nil,			{58875,	60,	15},	nil,			},	--Spirit Walk
	{79206,	3,	nil,			{79206,	120,	15},	nil,			{79206,	120,	15},	},	--Spiritwalker's Grace
	{108270,4,	{108270,60,	0},	nil,			nil,			nil,			},	--Stone Bulwark Totem
	{152256,3,	{152256,300,	0},	nil,			nil,			nil,			},	--Storm Elemental Totem
	{51490,	3,	nil,			{51490,	45,	0},	nil,			nil,			},	--Thunderstorm
	{108287,3,	{108287,10,	0},	nil,			nil,			nil,			},	--Totemic Projection
	{8143,	1,	{8143,	60,	10},	nil,			nil,			nil,			},	--Tremor Totem
	{73680,	3,	nil,			nil,			{73680,	15,	0},	nil,			},	--Unleash Elements
	{165462,3,	nil,			{165462,15,	0},	nil,			nil,			},	--Unleash Flame
	{57994,	5,	{57994,	12,	0},	nil,			nil,			nil,			},	--Wind Shear
	{108273,1,	{108273,60,	6},	nil,			nil,			nil,			},	--Windwalk Totem
},
["MAGE"] = {
	{108978,4,	{108978,60,	10},	nil,			nil,			nil,			},	--Alter Time
	--{159916,1,	{159916,120,	6},	nil,			nil,			nil,			},	--Amplify Magic
	{153626,3,	nil,			{153626,15,	0},	nil,			nil,			},	--Arcane Orb
	{12042,	3,	nil,			{12042,	90,	15},	nil,			nil,			},	--Arcane Power
	{108843,4,	{108843,25,	1.5},	nil,			nil,			nil,			},	--Blazing Speed
	{1953,	4,	{1953,	15,	0},	nil,			nil,			nil,			},	--Blink
	{11958,	4,	{11958,	180,	0},	nil,			nil,			nil,			},	--Cold Snap
	{11129,	3,	nil,			nil,			{11129,	45,	10},	nil,			},	--Combustion
	{153595,3,	nil,			nil,			nil,			{153595,30,	0},	},	--Comet Storm
	{120,	3,	{120,	12,	0},	nil,			nil,			nil,			},	--Cone of Cold
	{2139,	5,	{2139,	24,	0},	nil,			nil,			nil,			},	--Counterspell
	{44572,	3,	nil,			nil,			nil,			{44572,	30,	0},	},	--Deep Freeze
	{31661,	3,	nil,			nil,			{31661,	20,	0},	nil,			},	--Dragon's Breath
	{157913,4,	{157913,45,	3},	nil,			nil,			nil,			},	--Evanesce
	{12051,	3,	nil,			{12051,	90,	6},	nil,			nil,			},	--Evocation
	{122,	3,	{122,	30,	0},	nil,			nil,			nil,			},	--Frost Nova
	{102051,3,	{102051,20,	0},	nil,			nil,			nil,			},	--Frostjaw
	{84714,	3,	nil,			nil,			nil,			{84714,	60,	0},	},	--Frozen Orb
	{110959,4,	{110959,90,	20},	nil,			nil,			nil,			},	--Greater Invisibility
	{11426,	4,	{11426,	25,	0},	nil,			nil,			nil,			},	--Ice Barrier
	{45438,	4,	{45438,	300,	10},	nil,			nil,			nil,			},	--Ice Block
	{111264,2,	{111264,20,	0},	nil,			nil,			nil,			},	--Ice Ward
	{12472,	3,	nil,			nil,			nil,			{12472,	180,	20},	},	--Icy Veins
	{66,	4,	{66,	300,	20},	nil,			nil,			nil,			},	--Invisibility
	{153561,3,	nil,			nil,			{153561,45,	0},	nil,			},	--Meteor
	{55342,	3,	{55342,	120,	0},	nil,			nil,			nil,			},	--Mirror Image
	{12043,	3,	nil,			{12043,	90,	0},	nil,			nil,			},	--Presence of Mind
	{152087,3,	{152087,90,	0},	nil,			nil,			nil,			},	--Prismatic Crystal
	{475,	5,	{475,	8,	0},	nil,			nil,			nil,			},	--Remove Curse
	{113724,3,	{113724,45,	10},	nil,			nil,			nil,			},	--Ring of Frost
	{31687,	3,	nil,			nil,			nil,			{31687,	60,	0},	},	--Summon Water Elemental
	{80353,	3,	{80353,	300,	40},	nil,			nil,			nil,			},	--Time Warp
},
["WARLOCK"] = {
	{111397,4,	{111397,60,	0},	nil,			nil,			nil,			},	--Blood Horror
	{152108,3,	{152108,60,	0},	nil,			nil,			nil,			},	--Cataclysm
	{110913,4,	{110913,180,	8},	nil,			nil,			nil,			},	--Dark Bargain
	{108359,4,	{108359,120,	12},	nil,			nil,			nil,			},	--Dark Regeneration
	{77801,	3,	nil,			{113860,120,	20},	{113861,120,	20},	{113858,120,	20},	},	--Dark Soul: Instability
	{48020,	4,	{48020,	30,	0},	nil,			nil,			nil,			},	--Demonic Circle: Teleport
	{109151,4,	nil,			nil,			{109151,10,	0},	nil,			},	--Demonic Leap
	{120451,3,	nil,			nil,			nil,			{120451,60,	0},	},	--Flames of Xoroth
	{108503,3,	nil,			{108503,30,	0},	nil,			{108503,30,	0},	},	--Grimoire of Sacrifice
	{108501,3,	nil,			nil,			{108501,120,	0},	nil,			},	--Grimoire of Service
	{80240,	3,	nil,			nil,			nil,			{80240,	20,	0},	},	--Havoc
	{5484,	3,	{5484,	40,	0},	nil,			nil,			nil,			},	--Howl of Terror
	{137587,3,	{137587,35,	8},	nil,			nil,			nil,			},	--Kil'jaeden's Cunning
	{108508,3,	{108508,60,	10},	nil,			nil,			nil,			},	--Mannoroth's Fury
	{6789,	4,	{6789,	45,	0},	nil,			nil,			nil,			},	--Mortal Coil
	{108416,4,	{108416,60,	0},	nil,			nil,			nil,			},	--Sacrificial Pact
	{30283,	3,	{30283,	30,	0},	nil,			nil,			nil,			},	--Shadowfury
	{29858,	4,	{29858,	120,	0},	nil,			nil,			nil,			},	--Soulshatter
	{20707,	3,	{20707,	600,	0},	nil,			nil,			nil,			},	--Soulstone
	{18540,	3,	{18540,	600,	0},	nil,			nil,			nil,			},	--Summon Doomguard
	{1122,	3,	{1122,	600,	0},	nil,			nil,			nil,			},	--Summon Infernal
	{108482,4,	{108482,120,	0},	nil,			nil,			nil,			},	--Unbound Will
	{104773,4,	{104773,180,	8},	nil,			nil,			nil,			},	--Unending Resolve
},
["MONK"] = {
	{157535,3,	nil,			nil,			nil,			{157535,90,	10},	},	--Breath of the Serpent
	{119392,3,	{119392,30,	3},	nil,			nil,			nil,			},	--Charging Ox Wave
	{123986,3,	{123986,30,	0},	nil,			nil,			nil,			},	--Chi Burst
	{115098,3,	{115098,15,	0},	nil,			nil,			nil,			},	--Chi Wave
	{122278,4,	{122278,90,	0},	nil,			nil,			nil,			},	--Dampen Harm
	{115460,3,	nil,			nil,			nil,			{115460,10,	0},	},	--Detonate Chi
	{122783,4,	{122783,90,	6},	nil,			nil,			nil,			},	--Diffuse Magic
	{115288,3,	nil,			nil,			{115288,60,	6},	nil,			},	--Energizing Brew
	{115072,3,	{115072,15,	0},	nil,			nil,			nil,			},	--Expel Harm
	{113656,3,	nil,			nil,			{113656,25,	0},	nil,			},	--Fists of Fury
	{101545,3,	nil,			nil,			{101545,25,	0},	nil,			},	--Flying Serpent Kick
	{115203,4,	{115203,180,	15},	nil,			nil,			nil,			},	--Fortifying Brew
	{115295,4,	nil,			{115295,30,	0},	nil,			nil,			},	--Guard
	{152175,3,	nil,			nil,			{152175,45,	0},	nil,			},	--Hurricane Strike
	{123904,3,	{123904,180,	0},	nil,			nil,			nil,			},	--Invoke Xuen, the White Tiger
	{119381,3,	{119381,45,	0},	nil,			nil,			nil,			},	--Leg Sweep
	{116849,2,	nil,			nil,			nil,			{116849,100,	12},	},	--Life Cocoon
	{137562,4,	{137562,120,	6},	nil,			nil,			nil,			},	--Nimble Brew
	{115078,3,	{115078,15,	0},	nil,			nil,			nil,			},	--Paralysis
	{115546,5,	{115546,8,	0},	nil,			nil,			nil,			},	--Provoke
	{115310,1,	nil,			nil,			nil,			{115310,180,	0},	},	--Revival
	{116844,3,	{116844,45,	8},	nil,			nil,			nil,			},	--Ring of Peace
	{152173,3,	nil,			{152173,90,	5},	{152173,90,	10},	nil,			},	--Serenity
	{116705,5,	{116705,15,	0},	nil,			nil,			nil,			},	--Spear Hand Strike
	{116680,3,	nil,			nil,			nil,			{116680,45,	0},	},	--Thunder Focus Tea
	{116841,2,	{116841,30,	6},	nil,			nil,			nil,			},	--Tiger's Lust
	{115080,3,	{115080,90,	0},	nil,			nil,			nil,			},	--Touch of Death
	{122470,4,	nil,			nil,			{122470,90,	10},	nil,			},	--Touch of Karma
	{101643,3,	{101643,10,	0},	nil,			nil,			nil,			},	--Transcendence
	{119996,4,	{119996,25,	0},	nil,			nil,			nil,			},	--Transcendence: Transfer
	{115176,4,	nil,			{115176,180,	8},	{115176,180,	8},	nil,			},	--Zen Meditation
	{115450,5,	{115450,8,	0},	nil,			nil,			nil,			},	--Детоксикация
},
["DRUID"] = {
	{22812,	4,	nil,			{22812,	60,	12},	nil,			{22812,	60,	12},	{22812,	60,	12},	},	--Barkskin
	{106952,3,	nil,			nil,			{106951,180,	15},	{50334,	180,	15},	nil,			},	--Berserk
	{155835,4,	nil,			nil,			nil,			{155835,30,	3},	nil,			},	--Bristling Fur
	{112071,3,	nil,			{112071,180,	15},	nil,			nil,			nil,			},	--Celestial Alignment
	{102351,3,	{102351,30,	0},	nil,			nil,			nil,			nil,			},	--Cenarion Ward
	{1850,	3,	{1850,	180,	15},	nil,			nil,			nil,			nil,			},	--Dash
	{102280,3,	{102280,30,	4},	nil,			nil,			nil,			nil,			},	--Displacer Beast
	{6795,	5,	{6795,	8,	0},	nil,			nil,			nil,			nil,			},	--Growl
	{108294,3,	nil,			{108291,360,	40},	{108292,360,	40},	{108293,360,	40},	{108294,360,	40},	},	--Heart of the Wild
	{99,	3,	{99,	30,	0},	nil,			nil,			nil,			nil,			},	--Incapacitating Roar
	{33891,	3,	nil,			nil,			nil,			nil,			{33891,	180,	30},	},	--Incarnation: Tree of Life
	{102342,2,	nil,			nil,			nil,			nil,			{102342,60,	12},	},	--Ironbark
	{102359,3,	{102359,30,	20},	nil,			nil,			nil,			nil,			},	--Mass Entanglement
	{5211,	3,	{5211,	50,	0},	nil,			nil,			nil,			nil,			},	--Mighty Bash
	{132158,3,	nil,			nil,			nil,			nil,			{132158,60,	0},	},	--Nature's Swiftness
	{124974,3,	{124974,90,	30},	nil,			nil,			nil,			nil,			},	--Nature's Vigil
	{20484,	3,	{20484,	600,	0},	nil,			nil,			nil,			nil,			},	--Rebirth
	{2782,	5,	{2782,	8,	0},	nil,			nil,			nil,			{88423,	8,	0},	},	--Remove Corruption
	{108238,4,	{108238,120,	0},	nil,			nil,			nil,			nil,			},	--Renewal
	{106839,5,	nil,			nil,			{106839,15,	0},	{106839,15,	0},	nil,			},	--Skull Bash
	{78675,	5,	nil,			{78675,	60,	8},	nil,			nil,			nil,			},	--Solar Beam
	{106898,1,	{106898,120,	0},	nil,			{77764,	120,	8},	{77761,	120,	8},	nil,			},	--Stampeding Roar
	{61336,	4,	nil,			nil,			{61336,	180,	6},	{61336,	180,	6},	nil,			},	--Survival Instincts
	{5217,	3,	nil,			nil,			{5217,	30,	8},	nil,			nil,			},	--Tiger's Fury
	{740,	1,	nil,			nil,			nil,			nil,			{740,	480,	8},	},	--Tranquility
	{132469,3,	{132469,30,	0},	nil,			nil,			nil,			nil,			},	--Typhoon
	{102793,3,	{102793,60,	10},	nil,			nil,			nil,			nil,			},	--Ursol's Vortex
	{102401,3,	{102401,15,	0},	nil,			nil,			nil,			nil,			},	--Wild Charge
},
["DEMONHUNTER"] = {

},
["PET"] = {
	{90355,	3,	"HUNTER"},
	{160011,3,	"HUNTER"},
	{159926,3,	"HUNTER"},
	{160063,3,	"HUNTER"},
	{159931,3,	"HUNTER"},
	{26064,	3,	"HUNTER"},
	{159956,3,	"HUNTER"},
	{61684,	3,	"HUNTER"},
	{55709,	3,	"HUNTER"},
	{53490,	3,	"HUNTER"},
	{53480,	2,	"HUNTER"},
	{90339,	3,	"HUNTER"},
	{53478,	3,	"HUNTER"},
	{61685,	3,	"HUNTER"},
	{159953,3,	"HUNTER"},
	{126393,3,	"HUNTER"},
	{137798,3,	"HUNTER"},
	{90361,	3,	"HUNTER"},
	{160044,3,	"HUNTER"},
	{91802,	5,	"DEATHKNIGHT"},
	{91797,	3,	"DEATHKNIGHT"},
	{89751,	3,	"WARLOCK"},
	{89766,	5,	"WARLOCK"},
	{115276,5,	"WARLOCK"},
	{17767,	3,	"WARLOCK"},
	{89808,	5,	"WARLOCK"},
	{119899,4,	"WARLOCK"},
	{89792,	3,	"WARLOCK"},
	{115781,5,	"WARLOCK"},
	{115284,3,	"WARLOCK"},
	{115831,3,	"WARLOCK"},
	{115268,3,	"WARLOCK"},
	{6358,	3,	"WARLOCK"},
	{19647,	5,	"WARLOCK"},
	{19505,	3,	"WARLOCK"},
	{135029,3,	"MAGE"},
	{33395,	3,	"MAGE"},
},
["RACIAL"] = {
	{68992,	3,	{68992,	120,	10},	},	--Worgen
	{20589,	3,	{20589,	60,	0},	},	--Gnome
	{20594,	3,	{20594,	120,	8},	},	--Dwarf
	{121093,3,	{121093,180,	5},	},	--Draenei
	{58984,	3,	{58984,	120,	0},	},	--NightElf
	{59752,	3,	{59752,	120,	0},	},	--Human
	{69041,	3,	{69041,	90,	0},	},	--Goblin
	{69070,	3,	{69070,	90,	0},	},	--Goblin
	{7744,	3,	{7744,	120,	0},	},	--Undead
	{20577,	3,	{20577,	120,	10},	},	--Undead
	{20572,	3,	{20572,	120,	15},	},	--Orc
	{20549,	3,	{20549,	90,	0},	},	--Tauren
	{26297,	3,	{26297,	180,	10},	},	--Troll
	{28730,	3,	{28730,	90,	0},	},	--BloodElf
	{107079,3,	{107079,120,	4},	},	--Pandaren
},
["ITEMS"] = {
	{67826,	3,	{67826,	3600,	0},	},	--Jeevs
	{177592,3,	{177592,120,	0},	},	--Candle
	{176873,3,	{176873,120,	20},	},	--Tank BRF
	{176875,3,	{176875,120,	20},	},	--Shard of nothing
	{177597,3,	{177597,120,	20},	},	--Coin
	{177594,3,	{177594,120,	20},	},	--Couplend
	{177189,3,	{177189,90,	15},	},	--Kyanos
	{176460,3,	{176460,120,	20},	},	--Kyb
	{183929,3,	{183929,90,	15},	},	--Intuition's Gift
	{184270,3,	{184270,60,	20},	},	--Mirror of the Blademaster
	{201414,3,	{201414,60,	0},	},	--Purified Shard of the Third Moon
	{201371,3,	{201371,60,	0},	},	--Judgment of the Naaru
},
}
]]


-------------------------------------------
-----------------         -----------------
----------------- Inspect -----------------
-----------------         -----------------
-------------------------------------------


local moduleInspect = ExRT.mod:New("Inspect",nil,true)

moduleInspect.db.inspectDB = {}
moduleInspect.db.inspectDBAch = {}
moduleInspect.db.inspectQuery = {}
moduleInspect.db.inspectItemsOnly = {}
moduleInspect.db.inspectID = nil
moduleInspect.db.inspectCleared = nil

module.db.inspectDB = moduleInspect.db.inspectDB	--Quick fix for other modules

local inspectForce = false
function moduleInspect:Force() inspectForce = true end
function moduleInspect:Slowly() inspectForce = false end

moduleInspect.db.statsNames = {
	haste = {L.cd2InspectHaste,L.cd2InspectHasteGem},
	mastery = {L.cd2InspectMastery,L.cd2InspectMasteryGem},
	crit = {L.cd2InspectCrit,L.cd2InspectCritGem,L.cd2InspectCritGemLegendary},
	spirit = {L.cd2InspectSpirit,L.cd2InspectAll},
	
	intellect = {L.cd2InspectInt,L.cd2InspectIntGem,L.cd2InspectAll},
	agility = {L.cd2InspectAgi,L.cd2InspectAll},
	strength = {L.cd2InspectStr,L.cd2InspectStrGem,L.cd2InspectAll},
	spellpower = {L.cd2InspectSpd},
	
	multistrike = {L.cd2InspectMultistrike,L.cd2InspectMultistrikeGem},
	versatility = {L.cd2InspectVersatility,L.cd2InspectVersatilityGem},
	leech = {L.cd2InspectLeech},
	armor = {L.cd2InspectBonusArmor},
	avoidance = {L.cd2InspectAvoidance},
	speed = {L.cd2InspectSpeed},
	
}

moduleInspect.db.itemsSlotTable = {
	1,	--INVSLOT_HEAD
	2,	--INVSLOT_NECK
	3,	--INVSLOT_SHOULDER
	15,	--INVSLOT_BACK
	5,	--INVSLOT_CHEST
	9,	--INVSLOT_WRIST
	10,	--INVSLOT_HAND
	6,	--INVSLOT_WAIST
	7,	--INVSLOT_LEGS
	8,	--INVSLOT_FEET
	11,	--INVSLOT_FINGER1
	12,	--INVSLOT_FINGER2
	13,	--INVSLOT_TRINKET1
	14,	--INVSLOT_TRINKET2
	16,	--INVSLOT_MAINHAND
	17,	--INVSLOT_OFFHAND
}

local inspectScantip = CreateFrame("GameTooltip", "ExRTInspectScanningTooltip", nil, "GameTooltipTemplate")
inspectScantip:SetOwner(UIParent, "ANCHOR_NONE")

local inspectLastTime = 0
local function InspectNext()
	if RaidInCombat() or (InspectFrame and InspectFrame:IsShown()) then
		return
	end
	local nowTime = GetTime()
	for name,timeAdded in pairs(moduleInspect.db.inspectQuery) do
		if name and CanInspect(name) and CheckInteractDistance(name,1) then
			NotifyInspect(name)
			
			if (VExRT and VExRT.InspectViewer and VExRT.InspectViewer.EnableA4ivs) and not moduleInspect.db.inspectDBAch[name] then
				if AchievementFrameComparison then
					AchievementFrameComparison:UnregisterEvent("INSPECT_ACHIEVEMENT_READY")
					ExRT.F.Timer(AchievementFrameComparison.RegisterEvent, 1, AchievementFrameComparison, "INSPECT_ACHIEVEMENT_READY")
				end
				ClearAchievementComparisonUnit()
				SetAchievementComparisonUnit(name)
			end
			
			moduleInspect.db.inspectQuery[name] = nil
			return
		elseif (timeAdded + 300) < nowTime or not UnitName(name) then
			moduleInspect.db.inspectQuery[name] = nil
		end
	end
end

local function InspectQueue()
	local n = GetNumGroupMembers() or 0
	local timeAdded = GetTime()
	for j=1,n do
		local name,_,subgroup,_,_,_,_,online = GetRaidRosterInfo(j)
		if name and not moduleInspect.db.inspectDB[name] and online then
			moduleInspect.db.inspectQuery[name] = timeAdded
		end
	end
end

function moduleInspect:AddToQueue(name) 
	if not moduleInspect.db.inspectQuery[name] then
		moduleInspect.db.inspectQuery[name] = GetTime()
	end
end


local function ExCD2_ClearTierSetsInfoFromUnit(name)
	for tierUID,tierData in pairs(module.db.tierSetsSpells) do
		if tierData[1] then
			if type(tierData[1]) ~= "table" then
				module.db.session_gGUIDs[name] = -tierData[1]
			else
				for i=1,#tierData[1] do
					module.db.session_gGUIDs[name] = -tierData[1][i]
				end
			end
		end
		if tierData[2] then
			if type(tierData[2]) ~= "table" then
				module.db.session_gGUIDs[name] = -tierData[2]
			else
				for i=1,#tierData[2] do
					module.db.session_gGUIDs[name] = -tierData[2][i]
				end
			end
		end
	end
	for itemID,spellID in pairs(module.db.itemsToSpells) do
		module.db.session_gGUIDs[name] = -spellID
	end
end

local InspectItems = nil
do
	local ITEM_LEVEL = (ITEM_LEVEL or "NO DATA FOR ITEM_LEVEL"):gsub("%%d","(%%d+)")
	function InspectItems(name,inspectedName,inspectSavedID)
		if moduleInspect.db.inspectCleared or moduleInspect.db.inspectID ~= inspectSavedID then
			return
		end
		moduleInspect.db.inspectDB[name] = moduleInspect.db.inspectDB[name] or {}
		local inspectData = moduleInspect.db.inspectDB[name]
		inspectData['ilvl'] = 0
		inspectData['tiersets'] = {}
		inspectData['items'] = {}
		inspectData['items_ilvl'] = {}
		for stateName,stateData in pairs(moduleInspect.db.statsNames) do
			inspectData[stateName] = 0
		end
		local ilvl_count = 0
		
		ExCD2_ClearTierSetsInfoFromUnit(name)	--------> ExCD2
		
		for i=1,#moduleInspect.db.itemsSlotTable do
			local itemSlotID = moduleInspect.db.itemsSlotTable[i]
			local itemLink = GetInventoryItemLink(inspectedName, itemSlotID)
			if itemLink then
				inspectData['items'][itemSlotID] = itemLink
				inspectScantip:SetInventoryItem(inspectedName, itemSlotID)
				local itemID = itemLink:match("item:(%d+):")
				for j=2, inspectScantip:NumLines() do
					local tooltipLine = _G["ExRTInspectScanningTooltipTextLeft"..j]
					local text = tooltipLine:GetText()
					if text and text ~= "" then
						for stateName,stateData in pairs(moduleInspect.db.statsNames) do
							inspectData[stateName] = inspectData[stateName] or 0
							local findText = text:gsub(",","")
							for k=1,#stateData do
								local findData = findText:match(stateData[k])
								if findData then
									local cR,cG,cB = tooltipLine:GetTextColor()
									cR = abs(cR - 0.5)
									cG = abs(cG - 0.5)
									cB = abs(cB - 0.5)
									if cR < 0.01 and cG < 0.01 and cB < 0.01 then
										findData = 0
									end
									inspectData[stateName] = inspectData[stateName] + tonumber(findData)
								end
							end
						end
						
						local ilvl = text:match(ITEM_LEVEL)
						if ilvl then
							ilvl = tonumber(ilvl)
							inspectData['ilvl'] = inspectData['ilvl'] + ilvl
							ilvl_count = ilvl_count + 1
							
							inspectData['items_ilvl'][itemSlotID] = ilvl
						end
					end
				end
				inspectScantip:ClearLines()
				itemID = tonumber(itemID or 0)
				
				--------> ExCD2
				local tierSetID = module.db.tierSetsList[itemID]
				if tierSetID then
					inspectData['tiersets'][tierSetID] = inspectData['tiersets'][tierSetID] and inspectData['tiersets'][tierSetID] + 1 or 1
				end
				local isTrinket = module.db.itemsToSpells[itemID]
				if isTrinket then
					module.db.session_gGUIDs[name] = isTrinket
				end
				
				if itemID == 124634 or itemID == 124636 or itemID == 124635 or itemID == 124637 or itemID == 124638 then
					UpdateLegendaryRingState()
				end
			end
		end
		inspectData['ilvl'] = inspectData['ilvl'] / (inspectData['items'][17] and 16 or 15)

		--------> ExCD2
		for tierUID,count in pairs(inspectData['tiersets']) do
			local p2 = module.db.tierSetsSpells[tierUID][1]
			local p4 = module.db.tierSetsSpells[tierUID][2]
			if p2 and count >= 2 then
				if type(p2) ~= "table" then
					module.db.session_gGUIDs[name] = p2
				else
					for i=1,#p2 do
						module.db.session_gGUIDs[name] = p2[i]
					end
				end
			end
			if p4 and count >= 4 then
				if type(p4) ~= "table" then
					module.db.session_gGUIDs[name] = p4
				else
					for i=1,#p4 do
						module.db.session_gGUIDs[name] = p4[i]
					end
				end
			end
		end
		UpdateAllData()
	end
end

hooksecurefunc("NotifyInspect", function() moduleInspect.db.inspectID = GetTime() moduleInspect.db.inspectCleared = nil end)
hooksecurefunc("ClearInspectPlayer", function() moduleInspect.db.inspectCleared = true end)

hooksecurefunc("SetAchievementComparisonUnit", function() moduleInspect.db.achievementCleared = nil end)
hooksecurefunc("ClearAchievementComparisonUnit", function() moduleInspect.db.achievementCleared = true end)

do
	local tmr = 0
	local queueTimer = 0
	function moduleInspect:timer(elapsed)
		tmr = tmr + elapsed
		if tmr > (inspectForce and 1.2 or 3.5) then
			queueTimer = queueTimer + tmr
			tmr = 0
			if queueTimer > 60 then
				queueTimer = 0
				InspectQueue()
			end
			InspectNext()
		end
	end
	function moduleInspect:ResetTimer() tmr = 0 end
	function moduleInspect:AddonLoaded() tmr = -5 end
end

function moduleInspect:Enable()
	moduleInspect:RegisterTimer()
	moduleInspect:RegisterEvents('PLAYER_SPECIALIZATION_CHANGED','INSPECT_READY','UNIT_INVENTORY_CHANGED','PLAYER_EQUIPMENT_CHANGED','GROUP_ROSTER_UPDATE','ZONE_CHANGED_NEW_AREA','INSPECT_ACHIEVEMENT_READY')
end
function moduleInspect:Disable()
	moduleInspect:UnregisterTimer()
	moduleInspect:UnregisterEvents('PLAYER_SPECIALIZATION_CHANGED','INSPECT_READY','UNIT_INVENTORY_CHANGED','PLAYER_EQUIPMENT_CHANGED','GROUP_ROSTER_UPDATE','ZONE_CHANGED_NEW_AREA','INSPECT_ACHIEVEMENT_READY')	
end

function moduleInspect.main:ADDON_LOADED()
	if ExRT.SDB.charName then
		moduleInspect.db.inspectQuery[ExRT.SDB.charName] = GetTime()
	end
	moduleInspect:Enable()
	moduleInspect:AddonLoaded()
end

function moduleInspect.main:PLAYER_SPECIALIZATION_CHANGED(arg)
	if arg and UnitName(arg) then
		local name = UnitCombatlogname(arg)
		moduleInspect.db.inspectDB[name] = nil
		
		--------> ExCD2
		VExRT.ExCD2.gnGUIDs[name] = nil		
		local _,class = UnitClass(name)
		if module.db.spell_talentsList[class] then
			for i=1,18 do
				if type(module.db.spell_talentsList[class][i]) == "table" then
					for j=1,#module.db.spell_talentsList[class][i] do
						module.db.session_gGUIDs[name] = -(module.db.spell_talentsList[class][i][j] or 0)
					end
				else
					module.db.session_gGUIDs[name] = -(module.db.spell_talentsList[class][i] or 0)
				end
			end
		end
		if module.db.spell_glyphsList[class] then
			for spellId,_ in pairs(module.db.spell_glyphsList[class]) do
				module.db.session_gGUIDs[name] = -spellId
			end
		end
		
		UpdateAllData()
		--------> / ExCD2
		
		moduleInspect.db.inspectQuery[name] = GetTime()
	end
end

do
	local scheludedQueue = nil
	local function funcScheduledUpdate()
		scheludedQueue = nil
		InspectQueue()
	end
	function moduleInspect.main:GROUP_ROSTER_UPDATE()
		if not scheludedQueue then
			scheludedQueue = ScheduleTimer(funcScheduledUpdate,2)
		end
	end


	local prevDiff = nil
	function moduleInspect.main:ZONE_CHANGED_NEW_AREA()
		local _,_,difficulty = GetInstanceInfo()
		if difficulty == 8 or prevDiff == 8 then
			local n = GetNumGroupMembers() or 0
			if IsInRaid() then
				n = min(n,5)
				for j=1,n do
					local name,_,subgroup = GetRaidRosterInfo(j)
					if name and subgroup == 1 then
						moduleInspect.db.inspectItemsOnly[name] = true
						moduleInspect.db.inspectQuery[name] = GetTime()
					end
				end
			else
				for j=1,5 do
					local uid = "party"..j
					if j==5 then
						uid = "player"
					end
					local name = UnitCombatlogname(uid)
					if name then
						moduleInspect.db.inspectItemsOnly[name] = true
						moduleInspect.db.inspectQuery[name] = GetTime()
					end
				end
			end
		end
		prevDiff = difficulty
		
		if not scheludedQueue then
			scheludedQueue = ScheduleTimer(funcScheduledUpdate,4)
		end
	end
end

do
	local lastInspectTime = {}
	function moduleInspect.main:INSPECT_READY(arg)
		if not moduleInspect.db.inspectCleared then
			ExRT.F.dprint('INSPECT_READY',arg)
			local time_ = GetTime()
			if arg and lastInspectTime[arg] and (time_ - lastInspectTime[arg]) < 0.2 then
				return
			end
			if arg then
				lastInspectTime[arg] = time_
			end
			local _,_,_,race,_,name,realm = GetPlayerInfoByGUID(arg)
			if name then
				if realm and realm ~= "" then name = name.."-"..realm end
				local inspectedName = name
				if UnitName("target") == DelUnitNameServer(name) then 
					inspectedName = "target"
				elseif not UnitName(name) then
					return
				end
				moduleInspect:ResetTimer()
				local _,class,classID = UnitClass(inspectedName)
				
				for i,slotID in ipairs(moduleInspect.db.itemsSlotTable) do
					local link = GetInventoryItemLink(inspectedName, slotID)
				end
				ScheduleTimer(InspectItems, inspectForce and 0.8 or 1.5, name, inspectedName, moduleInspect.db.inspectID)
	
				if moduleInspect.db.inspectDB[name] and moduleInspect.db.inspectItemsOnly[name] then
					moduleInspect.db.inspectItemsOnly[name] = nil
					return
				end
				moduleInspect.db.inspectItemsOnly[name] = nil
				
				if moduleInspect.db.inspectDB[name] then
					wipe(moduleInspect.db.inspectDB[name])
				else
					moduleInspect.db.inspectDB[name] = {}
				end
				local data = moduleInspect.db.inspectDB[name]
				
				data.spec = round( GetInspectSpecialization(inspectedName) )
				if data.spec < 1000 then
					VExRT.ExCD2.gnGUIDs[name] = data.spec
				end
				data.class = class
				data.level = UnitLevel(inspectedName)
				data.race = race
				data.time = time()
				data.GUID = UnitGUID(inspectedName)
				for i=1,6 do
					data[i] = 0
				end
				data.talentsIDs = {}
				for i=0,20 do
					local t_id,_,_,t = GetTalentInfo((i-i%3)/3+1,i%3+1,nil,true,inspectedName)
					if t then
						data[(i-i%3)/3+1] = i%3+1
						data.talentsIDs[(i-i%3)/3+1] = t_id
					end
					
					--------> ExCD2
					local talentID = module.db.spell_talentsList[class] and module.db.spell_talentsList[class][i+1]
					if talentID then
						if type(talentID) == "table" then
							for j,sID in ipairs(talentID) do
								if t then
									module.db.session_gGUIDs[name] = sID
								else
									module.db.session_gGUIDs[name] = -sID
								end
							end
						else
							if t then
								module.db.session_gGUIDs[name] = talentID
							else
								module.db.session_gGUIDs[name] = -talentID
							end
						end
					end
					--------> /ExCD2
				end
				for i=1,6 do
					local _,_,_,t = GetGlyphSocketInfo(i,nil,1,inspectedName)
					data[i+7] = t
					
					--------> ExCD2
					if t and module.db.spell_glyphsList[class][t] then
						module.db.session_gGUIDs[name] = t
					end
					--------> /ExCD2
				end
				InspectItems(name, inspectedName, moduleInspect.db.inspectID)
				
				UpdateAllData() 	--------> ExCD2
			end
		end
	end
	
	if ExRT.is7 then
		function moduleInspect.main:INSPECT_READY(arg)
			if not moduleInspect.db.inspectCleared then
				ExRT.F.dprint('INSPECT_READY',arg)
				local time_ = GetTime()
				if arg and lastInspectTime[arg] and (time_ - lastInspectTime[arg]) < 0.2 then
					return
				end
				if arg then
					lastInspectTime[arg] = time_
				end
				local _,_,_,race,_,name,realm = GetPlayerInfoByGUID(arg)
				if name then
					if realm and realm ~= "" then name = name.."-"..realm end
					local inspectedName = name
					if UnitName("target") == DelUnitNameServer(name) then 
						inspectedName = "target"
					elseif not UnitName(name) then
						return
					end
					moduleInspect:ResetTimer()
					local _,class,classID = UnitClass(inspectedName)
					
					for i,slotID in ipairs(moduleInspect.db.itemsSlotTable) do
						local link = GetInventoryItemLink(inspectedName, slotID)
					end
					ScheduleTimer(InspectItems, inspectForce and 0.8 or 1.5, name, inspectedName, moduleInspect.db.inspectID)
		
					if moduleInspect.db.inspectDB[name] and moduleInspect.db.inspectItemsOnly[name] then
						moduleInspect.db.inspectItemsOnly[name] = nil
						return
					end
					moduleInspect.db.inspectItemsOnly[name] = nil
					
					if moduleInspect.db.inspectDB[name] then
						wipe(moduleInspect.db.inspectDB[name])
					else
						moduleInspect.db.inspectDB[name] = {}
					end
					local data = moduleInspect.db.inspectDB[name]
					
					data.spec = round( GetInspectSpecialization(inspectedName) )
					if data.spec < 1000 then
						VExRT.ExCD2.gnGUIDs[name] = data.spec
					end
					data.class = class
					data.level = UnitLevel(inspectedName)
					data.race = race
					data.time = time()
					data.GUID = UnitGUID(inspectedName)
					
					local specIndex = 1
					for i=1,GetNumSpecializationsForClassID(classID) do
						if GetSpecializationInfoForClassID(classID,i) == data.spec then
							specIndex = i
							break
						end
					end
					
					
					for i=1,6 do
						data[i] = 0
					end
					data.talentsIDs = {}
					for i=0,20 do
						local t_id,_,_,t = GetTalentInfo((i-i%3)/3+1,i%3+1,specIndex,true,inspectedName)
						if t then
							data[(i-i%3)/3+1] = i%3+1
							data.talentsIDs[(i-i%3)/3+1] = t_id
						end
						
						--------> ExCD2
						local talentID = module.db.spell_talentsList[class] and module.db.spell_talentsList[class][i+1]
						if talentID then
							if type(talentID) == "table" then
								for j,sID in ipairs(talentID) do
									if t then
										module.db.session_gGUIDs[name] = sID
									else
										module.db.session_gGUIDs[name] = -sID
									end
								end
							else
								if t then
									module.db.session_gGUIDs[name] = talentID
								else
									module.db.session_gGUIDs[name] = -talentID
								end
							end
						end
						--------> /ExCD2
					end
					for i=1,7 do
						local t_id,_,_,t = GetInspectPvpTalent(i)
						if t then
							data[7+i] = 0
							data.talentsIDs[7+i] = t_id
						end
						
						--------> ExCD2
						local talentID = module.db.spell_talentsList[class] and module.db.spell_talentsList[class][i+1]
						if talentID then
							if type(talentID) == "table" then
								for j,sID in ipairs(talentID) do
									if t then
										module.db.session_gGUIDs[name] = sID
									else
										module.db.session_gGUIDs[name] = -sID
									end
								end
							else
								if t then
									module.db.session_gGUIDs[name] = talentID
								else
									module.db.session_gGUIDs[name] = -talentID
								end
							end
						end
						--------> /ExCD2
					end
					InspectItems(name, inspectedName, moduleInspect.db.inspectID)
					
					UpdateAllData() 	--------> ExCD2
				end
			end
		end
	end
end

do
	local lastInspectTime,lastInspectGUID = 0
	moduleInspect.db.acivementsIDs = {} 
	function moduleInspect.main:INSPECT_ACHIEVEMENT_READY(guid)
		ExRT.F.dprint('INSPECT_ACHIEVEMENT_READY',guid)
		if moduleInspect.db.achievementCleared then
			C_Timer.NewTimer(.3,ClearAchievementComparisonUnit)	--prevent client crash on opening statistic 
			return
		end
		local currTime = GetTime()
		if not guid or (lastInspectGUID == guid and (currTime - lastInspectTime) < 0.2) then
			C_Timer.NewTimer(.3,ClearAchievementComparisonUnit)	--prevent client crash on opening statistic 
			return
		end
		lastInspectGUID = guid
		lastInspectTime = currTime
		local _,_,_,_,_,name,realm = GetPlayerInfoByGUID(guid)
		if name then
			if realm and realm ~= "" then name = name.."-"..realm end
			
			if moduleInspect.db.inspectDBAch[name] then
				wipe(moduleInspect.db.inspectDBAch[name])
			else
				moduleInspect.db.inspectDBAch[name] = {}
			end
			local data = moduleInspect.db.inspectDBAch[name]
			data.guid = guid
			for _,id in pairs(moduleInspect.db.acivementsIDs) do
				if id > 0 then
					local completed, month, day, year, unk1 = GetAchievementComparisonInfo(id)
					if completed then
						data[id] = month..":"..day..":"..year
					end
				else
					id = -id
					local info = GetComparisonStatistic(id)
					info = tonumber(info or "-")
					if info then
						data[id] = info
					end
				end
			end
		end
		if not AchievementFrame or not AchievementFrame:IsShown() then
			C_Timer.NewTimer(.3,ClearAchievementComparisonUnit)	--prevent client crash on opening statistic 
		end
	end
end

function moduleInspect.main:UNIT_INVENTORY_CHANGED(arg)
	if arg=='player' then return end
	local name = UnitCombatlogname(arg or "?")
	if name and name ~= ExRT.SDB.charName then
		moduleInspect.db.inspectItemsOnly[name] = true
		moduleInspect.db.inspectQuery[name] = GetTime()
	end
end

function moduleInspect.main:PLAYER_EQUIPMENT_CHANGED()
	local name = UnitCombatlogname("player")
	moduleInspect.db.inspectItemsOnly[name] = true
	moduleInspect.db.inspectQuery[name] = GetTime()
end

-------------------------------------------
-------------                --------------
------------- Legendary ring --------------
-------------                --------------
-------------------------------------------

if not ExRT.isLegionContent then

local module_legendary = ExRT.mod:New("LegendaryRing",ExRT.L.LegendaryRing,nil,true)

function module_legendary.options:Load()
	self:CreateTilte()

	self.enableChk = ELib:Check(self,L.LegendaryRingEnable,VExRT.LegendaryRing.enabled):Point(5,-30):OnClick(function(self) 
		if self:GetChecked() then
			VExRT.LegendaryRing.enabled = true
			module_legendary:RegisterEvents("COMBAT_LOG_EVENT_UNFILTERED")
			module_legendary:RegisterAddonMessage()
		else
			VExRT.LegendaryRing.enabled = nil
			module_legendary:UnregisterEvents("COMBAT_LOG_EVENT_UNFILTERED")
			module_legendary:UnregisterAddonMessage()
		end
	end)
	
	self.typeChk = ELib:Check(self,L.LegendaryRingType,VExRT.LegendaryRing.ShowType):Point(5,-55):OnClick(function(self) 
		if self:GetChecked() then
			VExRT.LegendaryRing.ShowType = true
		else
			VExRT.LegendaryRing.ShowType = nil
		end
	end)
	
	self.raidWarningChk = ELib:Check(self,RAID_WARNING,VExRT.LegendaryRing.raidWarning):Point(5,-80):OnClick(function(self) 
		if self:GetChecked() then
			VExRT.LegendaryRing.raidWarning = true
		else
			VExRT.LegendaryRing.raidWarning = nil
		end
	end)	
	

end

function module_legendary.main:ADDON_LOADED()
	if not VExRT then
		return
	end
	VExRT.LegendaryRing = VExRT.LegendaryRing or {}
	
	if VExRT.LegendaryRing.enabled then
		module_legendary:RegisterAddonMessage()
		module_legendary:RegisterEvents("COMBAT_LOG_EVENT_UNFILTERED")
	end
end

do
	local isSendByMe = true
	local function SendToChat(name,ringtype)
		if isSendByMe then
			local chat_type,chat_tar = ExRT.F.chatType()
			ringtype = VExRT.LegendaryRing.ShowType and ringtype
			if chat_type == "RAID" and VExRT.LegendaryRing.raidWarning then
				chat_type = "raid_warning"
			elseif chat_type == "WHISPER" then
				return
			end
			SendChatMessage(format("%s: %s",L.LegendaryRingFrodo,name)..(ringtype and " ["..ringtype.."]" or ""),chat_type,nil,chat_tar)
		end
	end
	function module_legendary.Ring(name,ringtype)
		if not VExRT.LegendaryRing or not VExRT.LegendaryRing.enabled then
			return
		end
		isSendByMe = true
		ExRT.F.ScheduleTimer(ExRT.F.SendExMsg, 0.15, "legendary","RING")
		ExRT.F.ScheduleTimer(SendToChat, 1.3, name, ringtype)
	end
	
	function module_legendary:addonMessage(sender, prefix, sub_type)
		if prefix == "legendary" then
			if sender then
				if ExRT.F.IsPlayerRLorOfficer(ExRT.SDB.charName) == 2 then
					return
				end
				if sender < ExRT.SDB.charName or ExRT.F.IsPlayerRLorOfficer(sender) == 2 then
					if sub_type == "RING" then
						isSendByMe = nil
					end
				end
			end
		end
	end
end
module_legendary_ring = module_legendary.Ring

module_legendary.db.types = {
	[187614] = DAMAGER,
	[187615] = DAMAGER,
	[187611] = DAMAGER,
	[187613] = TANK,
	[187612] = HEALER,
} 
function module_legendary.main:COMBAT_LOG_EVENT_UNFILTERED(_,_,event,_,sourceGUID,sourceName,_,_,_,_,_,_,spellID)
	if event == "SPELL_CAST_SUCCESS" and (spellID == 187614 or spellID == 187615 or spellID == 187611 or spellID == 187613 or spellID == 187612) then
		if not sourceName or not UnitName(sourceName) then
			return
		end
		module_legendary_ring(sourceName,module_legendary.db.types[spellID])
	end
end

end